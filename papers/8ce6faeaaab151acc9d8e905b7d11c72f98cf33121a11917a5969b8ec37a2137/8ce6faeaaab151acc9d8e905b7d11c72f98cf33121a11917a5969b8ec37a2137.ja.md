# Modeling and Discovering Vulnerabilities with Code Property Graphs

ファビアン・ヤマグチ∗、ニコ・ゴルデ†、ダニエル・アルプ∗、コンラッド・リーク∗  
∗ゲッティンゲン大学（ドイツ）  
†Qualcomm Research Germany

今日発生しているセキュリティ侵害の大多数は、不適切なコードが直接の原因となっています。そのため、コンピュータシステムの保護は、ソフトウェアの脆弱性を厳密に特定することに大きく依存していますが、これは多大な専門知識を必要とする面倒でエラーが発生しやすい作業です。残念ながら、システムのセキュリティを損なうにはたった一つの欠陥で十分であり、監査すべきコードの膨大な量が攻撃者に有利に働いてしまいます。本論文では、大量のソースコードから効果的に脆弱性を発見する手法を提案します。そのために、*code property graph* と呼ばれるソースコードの新しい表現方法を導入します。これは、従来のプログラム解析の概念、すなわち抽象構文木、制御フローグラフ、プログラム依存グラフを統合したデータ構造です。この包括的な表現により、*graph traversals* を用いて一般的な脆弱性のテンプレートをスマートにモデル化することが可能になります。例えば、バッファオーバーフロー、整数オーバーフロー、フォーマット文字列の脆弱性、メモリ情報漏洩などを特定できます。我々は一般的なグラフデータベースを用いて本手法を実装し、Linuxカーネルのソースコードから従来知られていなかった18件の脆弱性を特定することで、その有効性を実証しました。

#### *Keywords*—*Vulnerabilities; Static Analysis; Graph Databases*

# I. INTRODUCTION

コンピュータシステムのセキュリティは、根底にあるソフトウェアの品質に本質的に依存しています。学術界や産業界で長年にわたり研究が行われてきたにもかかわらず、バッファ境界を考慮しないことや入力データの検証が不十分であることなど、セキュリティ上の脆弱性はプログラムコード内に定期的に現れます。その結果、ソフトウェア内の脆弱性は依然として今日のセキュリティ侵害の主な原因の一つとなっています。例えば、2013年にはユニバーサルプラグアンドプレイライブラリの単一のバッファオーバーフローにより、2,300万台以上のルーターがインターネットからの攻撃に対して脆弱になりました[26]。同様に、現在も多くのユーザーがJavaランタイム環境のさまざまな欠陥を悪用するウェブベースのマルウェアの被害に遭っています[29]。

ソフトウェアの脆弱性の発見は、古典的でありながらも困難なセキュリティ上の問題です。プログラムが他のプログラムの非自明な特性を特定できないため、ソフトウェア脆弱性の一般的な発見問題は決定不可能です[33]。その結果、現在のセキュリティ欠陥の検出手法は、特定の種類の脆弱性に限定されているか、あるいは面倒で手作業による監査に依存しています。特に、オペレーティングシステムカーネルのような大規模ソフトウェアプロジェクトのセキュリティの確保は困難な作業であり、単一の欠陥がコードベース全体のセキュリティを脅かす可能性があります。バッファオーバーフローやフォーマット文字列脆弱性のように、ソフトウェア全体で繰り返し見られる脆弱性のクラスはいくつか長年存在していますが、特定のソフトウェアプロジェクトにおけるそれらの具体的な発現を自動的に検出することは、依然として重要な専門知識がなければ実現できない場合が多いです[16]。

このような状況の結果として、セキュリティ研究は当初、不安全なライブラリ関数による欠陥[6]、バッファオーバーフロー[45]、整数オーバーフロー[40]、不十分な入力データ検証[18]など、特定の種類の脆弱性を静的に発見することに注力してきました。ソフトウェアテストの概念に基づき、動的プログラム解析を用いることで、より幅広い脆弱性の検出が達成されました。これは単純なファズテスト[例: 38, 42]から、より高度なテイントトラッキングやシンボリック実行[例: 2, 35]まで多岐にわたります。これらの手法はさまざまな種類の欠陥を発見することができる一方、実際には効率的に運用することが難しく、実行時コストが高すぎたり、考慮すべき実行経路数の指数関数的増加により、適切な結果を提供できないことがよくあります[16, 21]。この解決策として、セキュリティ研究は、アナリストを置き換えるのではなく、監査作業中に支援する手法の探索を最近始めています。提案された手法は、専門家の知識を静的プログラム解析に付加することで監査プロセスを加速し、脆弱性の探索をガイドすることができます[例: 39, 43, 44]。

本論文では、この研究の方向性を引き継ぎ、大量のソースコードから脆弱性を発見するための新しいアプローチを提案します。私たちの手法は、プログラム解析の古典的な概念とグラフマイニング分野における最近の発展を組み合わせています。本手法の根底にある重要な洞察は、多くの脆弱性がコードの構造、制御フロー、依存関係を同時に考慮することで初めて適切に発見できるということです。この要件に対応するために、*code property graph* と呼ばれるソースコードの新しい表現を導入します。このグラフは、抽象構文木、制御フローグラフ、プログラム依存グラフの特徴を一つのデータ構造に統合します。コードを包括的に捉えるこのアプローチにより、共通する脆弱性のテンプレートを *graph traversals* を用いてエレガントにモデル化できます。データベースのクエリと同様に、グラフトラバーサルはコードプロパティグラフを走査し、コード構造、制御フロー、および各ノードに関連するデータ依存性を調査します。異なるコード特性への統合的なアクセスにより、さまざまな種類の脆弱性に対する簡潔なテンプレートの作成が可能となり、大規模なコードの脆弱性監査に役立ちます。

私たちは、人気のあるグラフデータベースを使用して私たちの手法を実装し、バッファオーバーフロー、整数オーバーフロー、フォーマット文字列の脆弱性、メモリ漏洩といった、いくつかのよく知られた脆弱性タイプに対するグラフトラバーサルを設計することで、その実用的な利点を示します。実例として、私たちは Linux カーネルのソースコード――大規模で十分に監査されたコードベース――を分析します。私たちは、報告されているほとんどすべての脆弱性が

© 2014年、Fabian Yamaguchi。IEEEへのライセンスの下で。DOI 10.1109/SP.2014.44

![](_page_0_Picture_14.jpeg)

2012年のLinuxカーネルは、そのコードプロパティグラフ内でのトラバーサルを用いて記述することができます。オープンソースコミュニティがカーネルのセキュリティ向上に多大な努力を重ねてきたにもかかわらず、これらのトラバーサルにより、*18件のこれまで知られていなかった脆弱性*をLinuxカーネル内で発見することができました。これは、コードプロパティグラフの実用的な能力を示しています。

要約すると、私たちは脆弱性発見の課題に対して以下の貢献を行います。

- *Code property graph.* 私たちは、抽象構文木、制御フローグラフ、およびプログラム依存グラフの特性を組み合わせた、ソースコードの新しい表現方法を共通のデータ構造として導入します。
- *脆弱性タイプのためのトラバーサル。* 一般的な脆弱性のタイプは、コードプロパティグラフのトラバーサルとして巧みにモデル化でき、効率的な検出テンプレートを生み出すことを示します。
- *効率的な実装。* コードプロパティグラフをグラフデータベースにインポートすることで、Linuxカーネルのような大規模なコードベース上でもトラバーサルを効率的に実行できることを示します。

本論文の残りの部分は次のように構成されています。セクションIIではコードの表現に関する背景情報を提供し、セクションIIIではプロパティグラフとグラフトラバーサルの概念を定義します。セクションIVでは新しい表現であるコードプロパティグラフを紹介し、セクションVでこれを用いて脆弱性を特徴付ける方法を示します。セクションVIで本手法の評価を行います。関連研究および制限事項についてはそれぞれセクションVIIとVIIIで議論します。セクションIXで本論文を締めくくります。

#### II. REPRESENTATIONS OF CODE

プログラム解析やコンパイラ設計の分野では、プログラムの特性を論理的に扱うために、さまざまなコード表現が開発されてきました。これらの表現は主にコードの解析や最適化を目的として設計されていますが、本研究で探求するように、コードの特徴付けにも適しています。特に、私たちは本手法の基礎となる3つの古典的な表現、すなわち*抽象構文木*、*制御フローグラフ*、*プログラム依存グラフ*に注目します。コード表現についての詳細な議論は、Ahoらの著書[1]で参照できます。

| void foo()        | 1 |
|-------------------|---|
| {                 | 2 |
| int x = source(); | 3 |
| if (x < MAX)      | 4 |
| {                 | 5 |
| int y = 2 * x;    | 6 |
| sink(y);          | 7 |
| }                 | 8 |
| }                 | 9 |
|                   |   |

図1：例示的なコードサンプル（図2を参照）。

簡単な例として、本節で扱うさまざまな表現を説明するため、図1に示すコードサンプルを考えます。

#### *A. Abstract Syntax Trees (AST)*

抽象構文木（AST）は、通常、コンパイラのコードパーサによって最初に生成される中間表現の一つであり、多くの他のコード表現の生成の基礎となります。これらの木構造は、文や式がどのように入れ子になってプログラムが構築されているかを正確に記述します。しかし、*構文解析木*とは対照的に、抽象構文木はもはやプログラムを表現するために選ばれた具体的な構文を示してはいません。例えば、C言語では、カンマで区切られた宣言のリストは、通常、2つの連続した宣言と同じ抽象構文木を生成します。

抽象構文木は順序付き木であり、内部ノードは*演算子*（例えば加算や代入）を表し、葉ノードは*オペランド*（例えば定数や識別子）に対応します。一例として、図1に示したコードサンプルの抽象構文木を図2aに示します。抽象構文木は単純なコード変換には適しており、意味的に類似したコードを識別するためにも利用されています[3, 43]が、デッドコードや未初期化変数の検出といった、より高度なコード解析には適用できません。この欠点の理由は、このコード表現では制御フローやデータ依存性が明示されていないためです。

# *B. Control Flow Graphs (CFG)*

制御フローグラフは、コードの文が実行される順序や、特定の実行経路が選択されるために満たすべき条件を明示的に記述します。この目的のために、文と述語はノードとして表され、制御の移動を示すために有向エッジで結ばれます。これらのエッジは抽象構文木の場合のように順序付けされている必要はありませんが、各エッジには*true*、*false*、または-のラベルを割り当てる必要があります。特に、文ノードは1つの出力エッジを持ち、そのラベルは-です。一方、述語ノードは2つの出力エッジを持ち、それぞれ述語の評価が*true*または*false*である場合に対応します。制御フローグラフは、抽象構文木から2段階の手順で構築できます。まず、構造化制御文（例：*if*、*while*、*for*）を考慮して暫定的な制御フローグラフを作成します。次に、*goto*、*break*、*continue*などの非構造化制御文も考慮することで、暫定的な制御フローグラフを修正します。図2bは、図1に示したコードサンプルに対するCFGを示しています。

制御フローグラフは、セキュリティの文脈でさまざまな用途に利用されてきました。例えば、既知の悪意あるアプリケーションの亜種を検出することや[11]、ファズテストツールの指針として活用することなどです[37]。さらに、制御フローグラフはプログラムの理解を支援するために、リバースエンジニアリングにおける標準的なコード表現となっています。しかし、制御フローグラフはアプリケーションの制御フローを明らかにする一方で、データフローの情報を提供することはできません。特に脆弱性分析においては、これは制御フローグラフだけでは、攻撃者に影響を受けたデータを処理する文を容易に特定できないことを意味します。

## *C. Program Dependence Graphs (PDG)*

Ferrante ら [9] によって導入されたプログラム依存グラフは、もともとプログラムスライスを実行するために開発されました。

![](_page_2_Figure_0.jpeg)

Fig. 2: 図1の例に対するコードの表現です。プログラム依存グラフでは、制御依存関係とデータ依存関係がCとDで示されています。

[41]によれば、つまり、指定された文における変数の値に影響を与えるプログラム内のすべての文と述語を特定することである。プログラム依存グラフは、文と述語間の依存関係を明示的に表す。特に、このグラフは2種類のエッジを用いて構築される。1つは、ある変数が別の変数に与える影響を表すデータ依存エッジ、もう1つは、述語が変数の値に与える影響を表す制御依存エッジである。プログラム依存グラフのエッジは、制御フローグラフから計算することができる。そのためには、まず各文によって*定義*される変数と*使用*される変数の集合を決定し、各文と述語のために*到達定義*を計算する。これは、コンパイラ設計の標準的な問題である[1参照]。

例として、Figure 2c は Figure 1 に示したコードサンプルのプログラム依存グラフを示しています。制御依存エッジは単なる制御フローエッジではなく、特に、文が実行される順序はこのグラフからはもはや判断できない一方で、文と述語との間の依存関係は明確に可視化されています。

#### III. PROPERTY GRAPHS AND TRAVERSALS

提示された各表現は、ソースコードに対する独自の視点を提供しており、基礎となるプログラムの異なる側面を強調しています。これらの視点を脆弱性発見のための統合的な表現に結合するために、私たちは*プロパティグラフ* [34]の概念を利用します。これは多くのグラフデータベース（例えば ArangoDB、Neo4J、OrientDB）で構造化データを表現する基本的な方法です。正式には、プロパティグラフは次のように定義されます。

Definition 1. *プロパティグラフ* G = (V, E, λ, μ) は、有向エッジラベル付き属性マルチグラフである。ここで、V はノードの集合、E ⊆ (V × V ) は有向エッジの集合、λ : E → Σ はエッジごとにアルファベット Σ からラベルを割り当てるエッジラベリング関数である。エッジやノードには、μ : (V ∪ E) × K → S という関数によってプロパティを割り当てることができる。ここで、K はプロパティキーの集合、S はプロパティ値の集合である。

Figure 3 は、4つのノードを持つシンプルなプロパティグラフを示しています。プロパティグラフはマルチグラフであるため、2つのノードは複数のエッジによって接続される場合があります。たとえば、Figure 3 のノードAとBがそれにあたります。さらに、この例では、各ノードにキー k ∈ K を持つプロパティが割り当てられており、ノードAとBのみが集合 S = {x, w} からのプロパティ値を保持しています。

![](_page_2_Figure_8.jpeg)

Fig. 3: プロパティグラフの例。ノードに割り当てられたプロパティは破線で示されています。

プロパティグラフにおける情報抽出の主な手法は、いわゆる*グラフトラバーサル*（または単に*トラバーサル*）であり、これはラベルやプロパティに応じてグラフの辺に沿って移動するために使用されます。形式的には、グラフのトラバーサルは次のように定義されます。

Definition 2. *traversal* とは、性質グラフ G に従ってノードの集合を別のノードの集合に写像する関数 T : P(V ) → P(V ) であり、ここで P は V の冪集合を表します。

この一般的な定義により、複数のトラバーサルを連結することができます。たとえば、2つのグラフトラバーサル T<sup>0</sup> と T<sup>1</sup> は、関数合成 ◦ を用いて T<sup>0</sup> ◦ T<sup>1</sup> のように連結できます。この連結に基づき、いくつかの基本的なトラバーサルを定義することができ、これらは本論文で論じるすべての他のトラバーサルを構築する基盤となります。まずは単純なフィルタトラバーサルを定義します。

$$
\text{Filter}_p(X) = \{ v \in X : p(v) \}
$$

これは、たとえば特定のプロパティをチェックすることによって、ブール述語 p(v) に一致する集合 X 内のすべてのノードを返します。

プロパティグラフのエッジに沿って移動するために、次の順方向トラバーサルを定義します。

$$
OUT(X) = \bigcup_{v \in X} \{u : (v, u) \in E\},
$$
  
\n
$$
OUT_l(X) = \bigcup_{v \in X} \{u : (v, u) \in E \text{ かつ } \lambda((v, u)) = l\},
$$
  
\n
$$
OUT_l^{k,s}(X) = \bigcup_{v \in X} \{u : (v, u) \in E \text{ かつ } \lambda((v, u)) = l\}
$$
  
\nおよび  $\mu((v, u), k) = s\}$

セット X のノードから到達可能なノードを返します。詳細には、トラバーサル OUT は X から到達可能なすべてのノードを返し、OUT<sup>l</sup> はラベル l を持つエッジを介して到達可能なすべてのノードを返します。また、OUTk,s <sup>l</sup> はラベル l かつプロパティ <sup>k</sup>:s を持つエッジを介して到達可能なすべてのノードを返します。同様に、グラフ内を後方に移動するためのトラバーサル IN、IN<sup>l</sup> および INk,s l を定義します。

$$
IN(X) = \bigcup_{u \in X} \{v : (v, u) \in E\},
$$
  
\n
$$
IN_l(X) = \bigcup_{u \in X} \{v : (v, u) \in E \text{ かつ } \lambda((v, u)) = l\},
$$
  
\n
$$
IN_l^{k,s}(X) = \bigcup_{u \in X} \{v : (v, u) \in E \text{ かつ } \lambda((v, u)) = l\}
$$
  
\nそして  $\mu((v, u), k) = s\}.$

最後に、他のトラバーサルの出力を集約するために、OR と AND という 2 種類のトラバーサルを次のように定義します。

$$
OR(\mathcal{T}_1, ..., \mathcal{T}_N)(X) = \mathcal{T}_1(X) \cup ... \cup \mathcal{T}_N(X)
$$
  
AND( $\mathcal{T}_1, ..., \mathcal{T}_N$ )(X) =  $\mathcal{T}_1(X) \cap ... \cap \mathcal{T}_N(X)$

やや技術的な定義ではありますが、いくつかのグラフデータベースはこれらの基本的なトラバーサルの効率的な実装を提供しています。特に、FILTER、OUT、INの各トラバーサルは、人気のあるデータベースでサポートされているグラフ言語 *Gremlin* の基本的な機能です。グラフトラバーサルの実装の詳細と、私たちのアプローチの評価については、セクションVIで議論します。

#### IV. CODE PROPERTY GRAPHS

Section II で提示されたそれぞれの表現は、基盤となるソフトウェアの特定の特性を捉えています。しかし、単一の表現だけでは、ほとんどの場合、脆弱性のタイプを特徴づけるには不十分です。したがって、Section III で導入したプロパティグラフの概念を用いて、これら三つの表現を統合したデータ構造にまとめます。具体的には、まず AST、CFG、PDG をプロパティグラフとしてモデル化し、続いてそれらを一つのグラフに統合することで、個々の表現が持つすべての利点を提供します。

#### *A. Transforming the Abstract Syntax Tree*

ソースコードを言語構成要素に詳細に分解して表現できる唯一の表現はASTです。したがって、私たちはまず、ASTをプロパティグラフ G<sup>A</sup> = (V<sup>A</sup>, E<sup>A</sup>, λ<sup>A</sup>, μ<sup>A</sup>) として表現することで、統合表現の構築を始めます。ここで、ノード V<sup>A</sup> はツリーのノードであり、エッジ E<sup>A</sup> は対応するツリーエッジであり、ラベリング関数 λ<sup>A</sup> によってASTエッジとしてラベル付けされます。さらに、各ノードには μ<sup>A</sup> を用いてプロパティ *code* を割り当て、そのプロパティ値はノードが表す演算子またはオペランドに対応します。最後に、ツリーの順序構造を反映するために、各ノードに *order* プロパティを割り当てます。その結果、このグラフのプロパティキーは K<sup>A</sup> = {*code*, *order*} となり、プロパティ値の集合 S<sup>A</sup> はすべての演算子とオペランド、および自然数からなります。

#### *B. Transforming the Control Flow Graph*

次のステップとして、CFGを統合表現に組み込む準備を行います。このために、CFGをプロパティグラフ G<sup>C</sup> = (V<sup>C</sup> , E<sup>C</sup> , λ<sup>C</sup> , ·) として表現します。ここで、ノード V<sup>C</sup> はAST内の文や述語、すなわちキー *code* に対してプロパティ値 *STMT* および *PRED* を持つ全てのノード V<sup>A</sup> に対応します。さらに、プロパティグラフ内の全てのエッジに対し、集合 Σ<sup>C</sup> = {*true*, *false*, -} からラベルを割り当てるエッジラベリング関数 λ<sup>C</sup> を定義します。

#### *C. Transforming the Program Dependence Graph*

PDGは、文と述語間のデータ依存性および制御依存性を表します。このグラフのノードはCFGのノードと同じであり、両者の違いはエッジのみです。したがって、PDGは新たなエッジ集合 E<sup>P</sup> とそれに対応するエッジラベル付け関数 λ<sup>P</sup> : E<sup>p</sup> → Σ<sup>P</sup> を定義することで、性質グラフ G<sup>P</sup> = (V<sup>C</sup> , E<sup>P</sup> , λ<sup>P</sup> , μp) として表せます。ここで、Σ<sup>P</sup> = {*C*, *D*} は制御依存性とデータ依存性に対応します。さらに、各データ依存性には対応するシンボルを示すプロパティ *symbol* を、各制御依存性には元の述語が *true* か *false* かを示すプロパティ *condition* を割り当てます。

#### *D. Combining the Representations*

最後のステップとして、私たちは3つのプロパティグラフを*code property graph*と呼ばれる統合データ構造に結合します。このグラフを構築するために必要な重要な洞察は、これら3つのグラフのそれぞれにおいて、ソースコード内の各ステートメントおよび述語に対応するノードが存在するということです。実際、ASTはこの3つの表現の中で唯一、追加のノードを導入しています。そのため、ステートメントおよび述語ノードは自然と表現同士を結びつけ、ある表現から別の表現への遷移点として機能します。

定義 3. *コードプロパティグラフ*は、ソースコードのAST、CFG、PDGから構成されるプロパティグラフG = (V, E, λ, μ)である。

- V = VA,
- E = E<sup>A</sup> ∪ E<sup>C</sup> ∪ E<sup>P</sup> 、
- λ = λ<sup>A</sup> ∪ λ<sup>C</sup> ∪ λ<sup>P</sup> そして
- μ = μ<sup>A</sup> ∪ μE,

ここでは、記法を若干乱用してラベリング関数とプロパティ関数を組み合わせています。

Figure 1に示されたコードサンプルに対するコードプロパティグラフの例をFigure 4に示します。簡単のため、プロパティキーや値、ASTエッジ上のラベルは

![](_page_4_Figure_0.jpeg)

図4: 図1に示したコードサンプルのコードプロパティグラフ。

示されています。グラフのノードは、主に図2aのASTに対応しています（無関係な*FUNC*および*IF*ノードを除く）。一方、変換されたCFGとPDGは、色付きのエッジで示されています。

## V. TRAVERSALS FOR WELL-KNOWN TYPES OF VULNERABILITIES

コードプロパティグラフは多様な種類のプログラミングパターンを表現することができますが、これがどのように脆弱性の発見に利用できるのかはすぐには明らかではありません。このセクションでは、コードプロパティグラフがさまざまな種類のセキュリティ上の欠陥を特定するために有効に活用でき、また脆弱性記述のためのテンプレートを作成できることを示します。まず、セクションV-Bでコードの純粋な構文的記述の限界を考察し、その後追加の制御フロー情報がわずかな改善しかもたらさないことを示します（セクションV-C）。最後にセクションV-Dでは、データフロー、制御フロー、構文情報を組み合わせることにより、幅広い脆弱性への対応が可能になることを説明します。

## *A. Motivational Example*

まず、Esser [7] によってSSH実装で発見され、多くのApple iOSアプリケーションを攻撃にさらしたバッファオーバーフローの最近の例から始めます。Esserは、図5に示す脆弱なコードを見つけるために正規表現を使用しました。

このコードは、チャネルが存在する場合にシグナル名（"SIG"プレフィックスなし）のメモリ領域を確保してコピーし、null終端します。これにより、チャネルに関連付けられた終了シグナルの名前を安全に保持することができます。

Fig. 5: libssh2のコードの抜粋で、関数 *libssh2 packet add* における脆弱性を示しています

脆弱な文（赤で示されています）は、6行目で*LIBSSH2 ALLOC*関数を使用してバッファ*exit signal*のメモリを割り当てています。割り当てるメモリの量は、*namelen*変数に1を加えることで直接引数内で計算されています。しかし残念ながら、この変数は攻撃者によって制御可能であり、32ビット符号なし整数の最大値が選択された場合、加算がオーバーフローし、割り当て関数には0が渡されてしまい、わずかなパディングバイトのみが割り当てられます。その後、9行目で*namelen*バイトがこの過小サイズのバッファにコピーされると、バッファオーバーフローが発生します。

エッサーは、次の正規表現を使用して6行目の脆弱な文を発見することができました。

ALLOC[A-Z0-9\_]\*\s\*\([ˆ,]\*,[ˆ;]\*[\*+-][ˆ>][ˆ;]\*\)\s\*; .

残念ながら、正規表現は割り当て呼び出し内の合計部分だけを記述しており、これは脆弱性の必要条件の一つに過ぎません。さらに、正規表現ではコードの入れ子構造を一致させることができないため、記述は本質的に曖昧です。しかし、この定式化の最大の欠点は、攻撃者が変数 *namelen* を制御できることをモデル化できていない点です。さらに、変数が適切にサニタイズされていれば、脆弱性は存在しなかったはずです。最後に、変数のビット幅もこの脆弱性にとって非常に重要です。

この簡単な例は、脆弱性パターンの特徴付けに関与するコードのさまざまな性質についての洞察を与えます。まとめると、以下の側面を考慮する必要があります。

- 1) *Sensitive operations.* セキュリティ上重要な操作、たとえば保護された機能への呼び出し、バッファへのコピーやメモリの割り当てなどは、記述可能である必要があります。例が示すように、割り当ての内部にある算術演算のようなネストされたコードは非常に重要であり、そのためASTへの完全なアクセスが必要です。
- 2) *型の使用法.* 多くの脆弱性は、プログラムで使用されるデータ型に密接に関連しています。たとえば、図5に示されている脆弱性は、*namelen* が32ビットの整数ではなく16ビットの整数であれば、存在しなかったでしょう。この情報はAST内に存在します。
- 3) *Attacker control.* アナリストは、どのデータソースが攻撃者の制御下にあるかを表現できなければなりません。例に言及すると、*libssh2 ntohu32* によって返される変数は攻撃者によって制御されている可能性が非常に高いです。なぜなら、このルーチンはネットワークからホストバイトオーダーへの整数変換を行うため、その整数はほとんどの場合外部から受信したものだからです。

ネットワーク。これをモデル化するためには、PDGによって表現されるデータ依存性が必要です。

4) *サニタイズ（無害化）.* 最後に、多くの脆弱性は、プログラムが攻撃者によって制御されたデータを適切にサニタイズしていない場合にのみ発生します。例えば、*namelen* という変数がメモリ割り当ての*前に*安全な範囲にあるかどうかをチェックしていれば、この脆弱性は存在しませんでした。このように、CFGによって明示的に示される文の順序をモデル化することが重要です。

ここでは、コードプロパティグラフによって提供されるさまざまなビューが、脆弱性発見のためのグラフトラバーサルの構築にどのように貢献しているかを詳しく分析します。

## *B. Syntax-Only Vulnerability Descriptions*

コードプロパティグラフは、もともと抽象構文木に含まれていたすべての情報を公開します。この情報は、攻撃者が制御するソース、センシティブな操作、サニタイザーを記述するには十分ですが、このセクションで示されているような文同士の相互作用を捉えることはできません。

まず、図5に示された脆弱な文をその構文構造によって説明します。脆弱性の主な特徴は、総和演算が直接割り当て関数の引数で行われていることです。この単純な例だけでもすでに2つの課題が生じます。第一に、関数が総和と呼び出しを含むかどうか判断する必要があります。第二に、コードのネスト構造を把握する必要があります。

最初の問題は、関数のすべてのノードを取得し、その後、それらのノードの中に総和や呼び出しを表すものがあるかどうかをフィルタリングすることで対処できます。AST のすべてのノードの中から特定の基準に合致するものを見つけることは、繰り返し発生する問題です。私たちは、この問題に対処するために、AST のルートからすべてのノードをたどる再利用可能な走査 TNODES を定義します。これにより、TNODES と FILTER を組み合わせることで、AST に総和や呼び出しノードが含まれているかどうかを簡単に判定できるようになります。

$$
MATCH_p(V) = FILTER_p \circ TNODES(V)
$$

すべてのv ∈ Vを根とするASTに含まれるすべてのノードを走査し、述語pに従ってこれらのノードをフィルタリングします。コード内のすべてのアロケーション関数呼び出しを走査するには、Vをすべての関数ノードの集合とし、p(v)がvがアロケーション関数の呼び出しであるときにtrueとなるようにして、MATCHトラバーサルを実行すれば簡単に実現できます。

2番目の問題、すなわち関数呼び出しの引数内にネストされた総和（Σ記号）を特定することも簡単に解決できるようになります。これは、MATCHのトラバーサルを関数合成によって単純に連結できるからです。たとえば、関数fのi番目の引数内にある総和を特定するには、次のトラバーサルを使用します。

$$
\mathrm{MATCH}_p \circ \mathrm{ARG}_f^i
$$

ここで、ARG<sup>i</sup> <sup>f</sup> は f という名前の関数への呼び出しの i 番目の引数を返す MATCH トラバーサルであり、p(v) は μ(v, *code*) = *Summation* の場合に真、それ以外の場合は偽です。

ただし、MATCH トラバーサルだけでは文同士の相互作用を特徴づけることはできませんが、大多数の脆弱性タイプにおいて、機微な操作、サニタイザー、および攻撃者が制御するソースを正確に記述するための基礎を形成します。さらに、図5の例で見られるように、単一の文を特徴づけるだけで、ある種の脆弱性の探索範囲をすでに絞り込むことができる場合もあります。以下は、MATCH トラバーサルのみでも同様に成功する脆弱性タイプの例です。

• *安全でない引数。* 安全でない引数は、脆弱性の一般的な原因です。たとえば、フォーマット文字列の脆弱性 [参照 12, 31, 36] は、攻撃者が制御するフォーマット文字列が *printf* や *sprintf* などの関数に渡される場合に発生し、複数のプラットフォームで任意のコード実行を引き起こす可能性があります。フォーマット文字列の脆弱性の必要条件は、*printf*、*sprintf*、あるいは *fprintf* などのユーティリティ関数に渡されるフォーマット文字列が定数文字列でないことです。これは、次のような MATCH トラバーサルを使って説明できます。

#### MATCH<sup>p</sup> ◦ ARG<sup>1</sup> sprintf

p は、v が定数文字列を表していない場合、すなわち μ(v, *code*) = *String* である場合に true です。このトラバーサルは攻撃者の制御をモデル化してはいませんが、非定数のフォーマット文字列を指定する理由がほとんどないため、実際にはうまく機能します。

• *整数オーバーフロー*。割り当て関数の引数内で算術演算が行われる場合は、Figure 5 に示されている動機付け例のように、整数オーバーフローによってメモリの破損につながる典型的なケースです。これらは以下のようなトラバーサルによって容易に表現できます。

#### MATCH<sup>p</sup> ◦ ARG<sup>1</sup> malloc

p(v) は、v が算術演算である場合に真となります。たとえば、μ(v, code) = *Multiplication* のようになります。

• *整数型の問題。* 複数の脆弱性は、開発者が想定していなかった型変換によって直接的に引き起こされます。特に、バッファオーバーフローは、暗黙の整数型キャストによって計算または検証が不適切なバッファサイズにより発生することがよくあります。たとえば、*整数の切り捨て* は、代入の右辺の整数が左辺よりも幅広い場合に発生します。これらのタイプの脆弱性を発見するには、前述の二例よりも少し高度な手法が必要であり、代入の左右の部分木を比較して脆弱なケースを特定する必要があります。この目的のために、関数 PAIRS<sup>T</sup><sup>2</sup> <sup>T</sup><sup>1</sup> を定義します。たとえば、すべての代入ノードの集合から始めて、PAIRS は2つの独立した走査 T<sup>1</sup> と T2 を行います。例えば、一方が代入の左部分木、もう一方が右部分木を探索し、その結果をペアとして結合します。これらのペアは、FILTER2 と同様に定義される関数 PAIRFILTER<sup>p</sup> を用いて、述語 p に従ってフィルタリングすることができます。MATCH と組み合わせてこの二つの関数を利用することで、整数の切り捨てを簡単に検出できます。

> PAIRFILTER<sup>p</sup><sup>1</sup> ◦ PAIRS<sup>T</sup><sup>2</sup> <sup>T</sup><sup>1</sup> ◦ MATCH<sup>p</sup><sup>2</sup>

<sup>1</sup>正式な定義は付録IX-Aで示されています。

<sup>2</sup>PAIＲとPAIＲFILＴERの正式な定義は付録 IX-C に記載されています。

ここで、p<sup>1</sup> は、2 番目のノードが 1 番目のノードよりも広い型を持つ変数を示す場合に真となり、p<sup>2</sup> はそのノードが代入である場合に真となります。最後に、T<sup>1</sup> と T<sup>2</sup> はそれぞれ代入の左部分木および右部分木をたどります。

ほとんどの試みが、MATCH のトラバーサルのみに基づいて脆弱性を特徴付けようとしても失敗に終わるのは、ステートメント同士の関連付けができないためですが、Section III で導入した AND や OR を使って複数の MATCH トラバーサルを組み合わせることで、潜在的に興味深いコードに絞り込むことが可能です。たとえば、*許可チェックの欠如* [27, 44 参照] は、セキュリティに重要な操作と攻撃者が制御できるソースが発生し、かつチェックが発生しない場合にコードが脆弱になるという特徴で表現できます。残念ながら、抽象構文木を用いる場合でもこれができる最善の方法となり、これを捉えるために以下の定義を示します。

Definition 4. *構文のみの脆弱性記述* S は、2つ組 (M0, M1) であり、M<sup>0</sup> と M<sup>1</sup> は MATCH トラバーサルの集合です。あるASTノードが構文のみの記述にマッチするのは、それが M<sup>0</sup> のすべての MATCH トラバーサルにマッチし、かつ M1 のいずれのトラバーサルにもマッチしない場合です。

構文のみの脆弱性記述は、実際には効果的であることが多いですが、攻撃者の制御や文同士の相互作用を表現することができないため、しばしば多くの誤検出（偽陽性）を生じます。次のセクションでは、この問題に部分的に対処する制御フローに基づく記述について議論します。

#### *C. Control-Flow Vulnerability Descriptions*

コードプロパティグラフの制御フローエッジを使用することで、文の実行順序をモデル化できるため、より広範な脆弱性にアクセスできるようになります。特に、制御フローグラフ内のパスに対応する脆弱性は、以下のようにうまく記述することができます。

- *リソースリーク。* 多くの脆弱性は、リソースが割り当てられた後、すべてのエラーパスで適切に解放されない場合に発生します。一般的なケースでは、これによりシステムが利用不可能になりますが、更なる脆弱性を誘発するために悪用されることもあります。
- *ロックの解放失敗。* 一般的な場合の並行性の問題を検出するのは困難ですが、単純な制御フロー解析を用いることで、エラーパスでロックが解放されていないケースを検出することができます。
- *Use-after-free 脆弱性。* すでに解放されたメモリ領域にアクセスするコードによるソフトウェアの欠陥は、任意のコード実行に悪用されることが多いです。これらの脆弱性は、いくつかの一見無関係な関数同士の複雑な相互作用から発生することが多いですが、単純な制御フロー解析だけでも、関数内でこの種の脆弱性を特定できる場合があります。

いずれのケースにおいても、脆弱性は制御フローグラフ内の特定の経路に関連付けることができます。たとえば、リソースリークは、メモリを獲得する文（例：*malloc*の呼び出し）から、リソースを解放する文（例：*free*の呼び出し）を通らずに関数の終端に至る制御フローグラフ上の経路に結び付けられます。しかし、その経路が関係するのは、割り当て関数が割り当てられたメモリへのポインタを返す場合のみなので、制御フローグラフ上の経路に追加の制約を付与する必要があります。これらの観察を次の定義でまとめます。

定義5. *制御フロー脆弱性記述*は4つ組 (Ssrc, Send, Sdst, {(S<sup>i</sup> cnd, ti)}<sup>i</sup>=1...N ) である。ここで、Ssrc はソース文の構文のみの記述、Send はエンド文のもの、Sdst はデスティネーション文のもの、{(S<sup>i</sup> cnd, ti)}<sup>i</sup>=1...N は条件の構文のみの記述とそれに関連する結果 t<sup>i</sup> ∈ {true, false} のリストである。ノード v が制御フロー脆弱性記述に一致するのは、以下の条件が成り立つ場合である。

- v を根とするASTには、Ssrc に一致する根ノード vsrc を持つ部分木が含まれています。
- vsrc から Send に一致するノードへの制御フローグラフ内の経路が存在し、その経路は Sdst に一致するノードを通らない。
- すべての 1 ≤ i ≤ N について、ノードが説明 Si cnd に一致する場合、そのノードから始まるパス上のすべての辺には ti というラベルが付けられていなければなりません。

コントロールベースの脆弱性は、与えられたソースノードのセットから、宛先の説明に一致するノードを経由せず、条件記述と関連する結果に従うエンドノードまでのすべての経路を深さ優先探索で見つけるトラバーサルを用いて表現することができます。このトラバーサルの正式な定義は、簡潔さのためここでは省略します。

残念ながら、制御フローや構文情報だけでは、脆弱性パターンを特定するには通常十分ではありません。特に、次のセクションで述べるように、攻撃者が制御するデータの流れを追跡することに関心があるためです。

#### *D. Taint-Style Vulnerability Descriptions*

最後に、構文、制御フロー、データフローの情報を組み合わせて脆弱性をモデル化します。構文のみや制御フローのみの脆弱性記述と比べて、データフローのエッジを用いることで攻撃者による制御をモデル化できる追加の能力を得られます。

各ステートメントノードには、そのノードに到達するすべての代入や変数定義からの入力データフローエッジが含まれているため、これらのエッジをたどるだけで、ステートメントが使用している変数を生成したすべてのステートメントへ簡単にたどることができます。しかし、わずかな困難として、データフローエッジで接続されているのはステートメントノードのみであるため、例えば関数呼び出しの引数からそのデータ生成元へたどりたい場合には、まずその引数を含むステートメントノードへ進む必要があります。幸いなことに、これは付録IX-Bで正式に定義されているSTATEMENTトラバーサルを用いることで簡単に達成できます。ノード集合に対する変数の生成元は、このトラバーサルを用いて計算できます。

$$
PRODUCERS_{\mathcal{N}} = \bigcup_{n \in \mathcal{N}} IN_{D}^{symbol,n} \circ \text{STATEMENT}
$$

ここで N は関心のある識別子の集合であり、これによって文で使用されている変数の部分集合に解析を制限することができます。便宜上、文で使用されているいずれかの変数に対してデータを生成するすべての文を記述するトラバーサル SOURCES も定義します。

SOURCESは貴重なトラバーサルであり、機微な操作やデータソースに対する構文のみの記述と組み合わせることで、攻撃者が制御するデータが機微な操作に使用されているケースを特定することができます。例えば、Linuxカーネルにおけるバッファオーバーフローの一般的な形は、*get user*関数によって生成されたユーザー提供の整数が、そのまま*memcpy*操作のサイズフィールドとして使用される場合です。このような脆弱性を特定するために、次のようなトラバーサルを定式化できます。

$$
MATCH_p \circ \text{SOURCES} \circ \text{ARG}^3_{memory}
$$

ここで、pはノードが*get user*への呼び出しを表している場合にtrueを返す述語です。つまり、*memcpy*の第3引数を直接生成する*get user*へのすべての呼び出しをたどります。さらに、トラバーサルSOURCESは任意の回数連鎖可能であり、引数が攻撃者制御のソースによって間接的にのみ生成される場合も特定できます。

この定式化の弱点は、データのサニタイズ処理を考慮しておらず、データが有害でないことを確認するためにチェックされている場合でもケースが返されてしまう点です。サニタイザーを考慮する一つの可能性として、追加の構文のみの記述を導入することが挙げられますが、これでは文の順序が考慮されず、チェックが正しく配置されているかどうかを検出することができません。私たちはこの欠点に対処するために、制御フローとデータフローの情報を組み合わせて使用します。特に、SOURCESと同じ機能を持つ走査を作成しつつ、さらにサニタイザーに対して構文のみの記述を提供できるようにすることに関心があります。

トラバーサル UNSANITIZED<sup>3</sup> を、SOURCES のドロップイン置換として定義します。これにより、記号特有の構文のみのサニタイザー記述 S<sup>s</sup> val を記号 s に対して追加で指定でき、適切にサニタイズされたすべてのケースを除外できます。トラバーサルは、次の 2 つの条件を満たす場合にのみ、攻撃者制御のソースを返します。

- 制御フローグラフにおいて、ソース文からシンク文への経路が存在し、その経路上のいずれのノードもサニタイザーの説明と一致しません。
- ソースで定義され、シンクで使用される変数が、制御フローパスを通じてシンクに到達する、つまりそのパス上のどのノードによってもその変数が再定義されていない場合です。

構文のみの記述とUNSANITIZEDトラバーサルを組み合わせて、私たちは「テイントスタイル」の脆弱性記述を次のように定義します。

定義6. *汚染スタイルの脆弱性記述* とは、攻撃者が制御可能なソースの構文のみの記述 Ssrc、セキュリティ的に重要なシンク（Sdst）、およびサニタイザの構文のみの記述の集合（S<sup>s</sup> san）からなる3組 (Ssrc, Sdst, S<sup>s</sup> san) である。ノード v が汚染スタイルの記述に一致するのは、v を根とするASTが、Ssrc に一致する根ノード vsource を持つ部分木と、Sdst に一致する根ノード vsink を持つ別の部分木を含む場合である。

- vsource から vsink までデータ依存エッジの経路が存在する、すなわち (v0,...,vn) というノードの列が存在し、v<sup>0</sup> = vsource、v<sup>n</sup> = vsink、e<sup>i</sup> = (vi, v<sup>i</sup>+1) ∈ E であり、すべての i = 0,...,n − 1 について λ(ei) = D となる。
- これらのデータ依存エッジ e<sup>i</sup> = (vi, v<sup>i</sup>+1) のそれぞれについて、制御フローグラフ内に v<sup>i</sup> から v<sup>i</sup>+1 へのパス (v0,...,vm) が存在します。また、すべての k, 0 ≤ k ≤ m について、v<sup>k</sup>

μ(ei,*symbol*) および v<sup>k</sup> はサニタイザの説明 <sup>S</sup><sup>μ</sup>((vi,vi+1),*symbol*) san と一致しません。

汚染スタイルの記述は、検証されたソース・シンクシステムで記述できる脆弱性の走査を定義するのに適しています[18を参照]。これらの種類の脆弱性の例としては、インジェクション脆弱性、バッファオーバーフロー、整数オーバーフロー、整数型の脆弱性、安全でない引数、権限チェックの欠如、さらにはメモリ公開などが挙げられます。以下の例でこれを説明します。

• *バッファオーバーフローの脆弱性。* フローベースの記述を動機付けるために述べた通り、多くのバッファオーバーフローは、コピー操作に渡される長さフィールドの検証が不十分であることが原因です。例えば、Linuxカーネルのコードでは、多くのバッファオーバーフローが、関数 *get user* によって読み取られ、*memcpy* や *copy from user* の第3引数として渡されるサイズフィールドが検証されないことで発生します。この脆弱性のパターンは、次のようなトラバーサルで表現できます。

$$
\text{ARG}^{1}_{get\_user} \circ \text{UNSANITIZED}_{\{\mathcal{T}_s\}} \circ \text{ARG}^{3}_{memory}
$$

この横断は、*get user* の最初の引数によって直接汚染されており、トラバーサル Ts に一致するノードによって検証されていない *memcpy* のすべての三番目の引数を選択します。例えば、追跡されている変数 s を含む関係式に一致するようなマッチトラバーサルが該当します。この種類の横断は、UNSANITIZED トラバーサルを連鎖させることで、間接的に汚染された引数も簡単に含めることができます。

• *コードインジェクションの脆弱性。* SQLインジェクションやコマンドインジェクションのような脆弱性は、テイントスタイルの記述でうまく説明することができます。例えば、攻撃者が任意のシェルコマンドを実行できる典型的なコマンドインジェクションの脆弱性は、次のようなトラバーサルで説明することができます。

$$
ARG_{recv}^2 \circ \text{UNSANITIZED}_{\{\mathcal{T}_s\}} \circ \text{ARG}_{system}^1
$$

ここで T<sup>s</sup> は、比較がセミコロンおよびよく知られたバリデーション関数への呼び出しにマッチするトラバーサルです。このトラバーサルは、*recv* の第2引数がセミコロンを含むかどうかを確認せずに *system* の第1引数に到達するすべてのケースを返します。

• *権限チェックの欠如。* ウェブアプリケーションやカーネルコードの両方で、操作を実行する前にユーザーの権限を確認する必要がありますが、これを怠ると特権昇格が可能になります［27, 44参照］。このタイプの脆弱性は次のように表現できます。

$$
\text{Match}_{p1} \circ \text{UNSANITIZED}_{\{\text{Match}_{p2}\}} \circ \text{MACH}_{p3}
$$

ここで、p1、p2、およびp3は、それぞれ攻撃者が制御するソース、ユーザーが十分な権限を持っていることを確認するチェック、およびセキュリティに敏感な操作を表す述語です。

汚染スタイルの記述を用いることで、攻撃者が制御するソースや、セキュリティ上重要な操作、サニタイザー、型情報、さらにはデータフローや制御フローにおける文同士の相互作用まで記述することができます。これにより、幅広い種類の脆弱性をカバーする検索クエリを提供することが可能になります。次のセクションでは、

<sup>3</sup>UNSANITIZEDの正式な定義は付録IX-Eに記載されています

私たちの手法の評価を提示し、対象としている脆弱性の種類が、今日のセキュリティ重視のコードにとって実際に重要であることを示します。

#### VI. EVALUATION

私たちは、いくつかのソフトウェアベンダーやオープンソースコミュニティによって定期的に脆弱性監査が行われている大規模なコードベースであるLinuxカーネルのソースコードを用いて、本手法の実用的な有効性を評価します。評価は2つのステップで行います。まず、2012年に報告されたLinuxカーネルのすべての脆弱性のコードを調査し、どの脆弱性のタイプがグラフトラバーサルを用いてモデル化可能かを判定する*カバレッジ分析*を実施します（Section VI-B）。次に、よく見られる脆弱性に対してトラバーサルを構築し、それをLinuxカーネルのコードプロパティグラフに適用することで、本手法が脆弱性を*発見する能力*を調査します（Section VI-C）。

#### *A. Implementation*

私たちの評価のために、コードプロパティグラフのアイデアに基づいた静的コード解析システムを実装しました。本システムは堅牢なC/C++パーサーを用いて、まず与えられたコードベース内の各関数についてASTを抽出します。次に、これらのASTをCFGおよびPDGへと変換し、第IV節で概説したとおり三つの表現を統合してコードプロパティグラフを構築します。さらに、コード中のグローバル変数や構造体宣言のためのノードも導入します。最終的に、すべての関数のグラフを、可視な呼び出し元と呼び出し先の関係に基づいて接続し、コードベース全体を一つの大きなコードプロパティグラフとして表現します。

Linuxカーネルのソースコードに対しては、5,200万個のノードと8,700万本のエッジを持つグラフを得ることになります。明らかに、このような大規模なグラフからコンシューマー向けハードウェア上で情報を抽出するのは、決して簡単な作業ではありません。幸いにも、非常に大規模なプロパティグラフへの効率的なアクセスを提供できる、特化されたグラフデータベースを利用することができます（ここでは *Neo4J Version 1.9.5* を使用しています）。さらに、これらのグラフデータベースを活用することで、グラフ探索を高速化する高度なキャッシュアルゴリズムの恩恵も受けられます。

試作実装を使用した場合、約130万行のコードを持つLinuxカーネルバージョン3.10-rc1のインポートには、2.5 GHzのIntel Core i5 CPUと8 GBのメインメモリを搭載したノートパソコンで合計110分かかります。作成されるデータベースは、ノードとエッジ用に14 GB、および効率的なインデックス作成のためにさらに14 GBのディスク容量を必要とします。

グラフ探索を実装するために、*Gremlin* は非常に適したグラフ言語であると考えています。なぜなら、ユーザー定義の探索処理を連結してデータベースに提供できるため、SQL データベースにおけるストアドプロシージャに似た仕組みを実現できるからです。これにより、第V節で提示した様々な探索処理を Gremlin コードに直接変換することが可能になります。さらに、Gremlin は *Blueprints* という互換性レイヤーを介してデータベースと連携する数少ない言語の一つであり、これによって作成したすべての探索処理を、他のグラフデータベース実装に対しても修正することなく実行することができます。

この論文で提示された脆弱性発見のためのトラバーサルを実行する場合、コールドデータベース、すなわちデータベースの内容をハードディスクから読み込む必要がある場合でも40秒未満で完了します。一旦ノードとエッジがメインメモリにキャッシュされると、実行時間は30秒に短縮されます。この際、ほとんどの時間は、トラバーサルUNSANITIZEDを使用して大きな関数内の有効な制御フローパスを決定するために費やされます。

# *B. Coverage Analysis*

私たちは分析を始めるにあたり、MITRE 組織が管理する中央の脆弱性データベースを検索し、2012年にLinuxカーネルの脆弱性に割り当てられたすべてのCVE識別子を調べました。合計で69の識別子を取得し、カーネルのソースコードに存在する88個のユニークな脆弱性に対応しています。これらの脆弱性をさまざまなタイプに分類するために、それぞれの脆弱性のパッチを手動で調査し、報告された欠陥の根本原因を特定しました。この情報により、88個の脆弱性を表Iに示す12の一般的なタイプに割り当てることができました。脆弱性の半数以上（88件中47件）は、メモリ情報漏洩、バッファオーバーフロー、またはリソースリークのいずれかであり、これらはいずれもセクションVで述べるようにグラフトラバーサルを用いてうまく表現できます。

私たちのアプローチのカバレッジを評価するために、Linuxカーネルで発見された12種類の脆弱性タイプを記述するのに必要なコード表現を分析します。特に、(a) AST単独、(b) ASTとPDGの組み合わせ、(c) ASTとCFGの組み合わせ、(d) AST、PDG、CFGの組み合わせ、という4つのケースについてカバレッジを分析します。この分析の結果はTable IIに示されています。

| 脆弱性の種類             | コード表現            |         |         |             |
|---------------------------|----------------------|---------|---------|-------------|
|                           | AST                  | AST+PDG | AST+CFG | AST+CFG+PDG |
| メモリ開示                |                      |         |         |             |
| バッファオーバーフロー    |                      | (<br>)  |         |             |
| リソースリーク            |                      |         |         |             |
| 設計ミス                  |                      |         |         |             |
| ヌルポインタ参照          |                      |         |         |             |
| 権限チェックの不足        |                      |         |         |             |
| レースコンディション      |                      |         |         |             |
| 整数のオーバーフロー      |                      |         |         |             |
| ゼロ除算                  |                      |         |         |             |
| 解放後使用（Use After Free）|                      |         | (<br>)  | (<br>)      |
| 整数型の問題              |                      |         |         |             |
| 安全でない引数            |                      |         |         |             |

TABLE II: 脆弱性タイプをモデル化するためのさまざまなコード表現のカバレッジ。

明らかに、AST だけではセキュリティ上の欠陥を見つけるための情報はほとんど得られず、この表現を使って発見できるのは、たとえば型変換の誤りのような限られた形式の安全でない引数だけです。ASTとPDGの情報を組み合わせることで、コードをよりよく理解し、バッファオーバーフローのさまざまな種類や、権限チェックの欠落、ゼロによる除算などを記述できるようになります。しかし、ASTとPDGの組み合わせは、たとえばセキュリティチェックの場所を特定する必要がある場合など、ステートメントの順序が重要となるケースでは、利用価値が限定されます。また、ASTとCFGの組み合わせも、多くの場合ではいくつかの脆弱性を見逃してしまいます。

<sup>4</sup>http://mlsec.org/joern/

| Vulnerability types          | Description                                                                                                                       | #  |
|------------------------------|-----------------------------------------------------------------------------------------------------------------------------------|----|
| Memory Disclosure            | 構造体がユーザースペースにコピーされる際に、すべてのフィールドやパディングバイトが適切に初期化されていないため、メモリが漏洩します。                 | 21 |
| Buffer Overflows             | コピー操作に関わる長さフィールドがチェックされていないため、バッファオーバーフローが発生します。                                           | 16 |
| Resource Leaks               | 関数がリソースを生成しますが、すべてのエラーパスで破棄されていません。                                                                 | 10 |
| Design Errors                | プログラム設計がセキュリティポリシーを十分に実装していません。                                                                       | 10 |
| Null Pointer Dereference     | 攻撃者によって制御されるポインタが、NULLかどうかを確認せずに参照されています。                                                        | 8  |
| Missing Permission Checks    | セキュリティに関わる操作が、事前の権限チェックを経ずにアクセス可能です。                                                              | 6  |
| Race Conditions              | 並行して実行されるプロセスにより、様々な種類の脆弱性が発生します。                                                                   | 6  |
| Integer Overflows            | コピー操作に関わる長さフィールドがチェックされてはいるものの、整数オーバーフローが考慮されておらず、十分ではありません。                 | 3  |
| Division by Zero             | 攻撃者が制御する値が割り算の分母になっており、ゼロになることが許されています。                                                         | 3  |
| Use After Free               | 割り当てられたメモリブロックが、アロケータによって解放された後にも使用されています。                                                   | 3  |
| Integer Type Vulnerabilities | コピー操作に関わる長さフィールドがチェックされていますが、そのフィールドが符号付き整数で十分なチェックになっていません。                | 1  |
| Insecure Arguments           | 関数に引数を渡す際、暗黙的かつ安全でない型変換が行われます。                                                                         | 1  |
| Total vulnerabilities        |                                                                                                                                   | 88 |

表I：2012年にLinuxカーネルで発見された脆弱性を脆弱性の種類ごとに分類したもの。

脆弱性の種類によっては、攻撃者が制御するデータのフローをモデル化する必要があります。ただし、リソースリークや一部のuse-after-free脆弱性は、CFGにエンコードされた文の流れから特定することができます。

コードプロパティグラフでこれら3つの表現をすべて組み合わせることにより、AST、CFG、PDGから得られる情報を活用して12種類の脆弱性タイプのうち10種類をモデル化することがついに可能になりました。残りの2つのタイプであるレースコンディションと設計ミスについては、前者は実行時の特性に依存し、後者はプログラムの意図した設計の詳細がなければモデル化が困難なため、グラフトラバーサルを用いて表現するのが難しいです。さらに、多くの不自然なuse-after-free（解放後利用）脆弱性のケースでは、実行時の情報がなければ説明が難しいこともあります。本手法の限界については、セクションVIIで議論します。

# *C. Discovery of Vulnerabilities*

コードプロパティグラフ上でのグラフ探索は多くの脆弱性タイプを記述するのに適していますが、実際に有効であるかどうかはまだ示されていません。この目的のために、私たちはさまざまな種類の脆弱性に対する探索を用いて、Linuxカーネルのコードプロパティグラフを解析し、我々の手法を実践的に評価します。

まず、2012年によく見られた2種類の脆弱性である、*境界チェックの欠如によるバッファオーバーフロー*と、*初期化が不完全な構造体によるメモリ漏洩*のためのトラバーサルの指定から始めます。次に、2012年には確認されなかった脆弱性、すなわち*メモリマッピングの脆弱性*と*ゼロバイト割り当て*のためのトラバーサルを構築します。これらはどちらもLinuxカーネルに特有の脆弱性であり、従来のツールでは発見が困難です。まとめると、私たちの実験では以下のトラバーサルを使用しました。

- *バッファオーバーフロー。* 攻撃者が制御する長さフィールドに対するチェックが不足していることによって発生するバッファオーバーフローのためのトラバーサルを構築します。このトラバーサルについては、セクションVI-Dで詳しく説明します。
- *メモリの情報漏洩。* 2012年にLinuxカーネルで発見されたセキュリティ上重大な脆弱性の大部分は、適切に初期化されていない構造体がユーザ空間にコピーされることによって引き起こされています。これらの脆弱性は、攻撃者によってカーネルメモリ内に保存されている機密オブジェクトを漏洩させるために利用される可能性があります。

これらの脆弱性に対処するために、私たちは構造体のローカル宣言からユーザ空間へのコピー操作まで、*memset*を通過しない場合にタイントスタイルのトラバーサルを構築します。さらに、構造体の型を調べ、構文のみの記述を用いて、構造体のすべてのフィールドに値が代入されているかどうかを判定します。

- *メモリマッピング.* カーネルは、ユーザーが任意の物理メモリアドレスをユーザースペースにマッピングできないようにしなければなりません。これは、機密情報の漏洩や任意のコード実行を防ぐためです。これはカーネルに非常に特有な脆弱性のタイプです。私たちは、これらの脆弱性を特定するために単純な構文のみの脆弱性記述を策定しており、本手法がプログラム固有のバグにも十分適応できることを示します。
- *ゼロバイトの割り当て。* 攻撃者が割り当て関数にゼロバイトの長さフィールドを渡せる場合、多くの割り当て関数が割り当てられたメモリーではなくエラーコードを返すため、Linuxカーネルではクラッシュにつながることがよくあります。これは他のアロケーターと比べて一般的ではなく、そのため比較的プログラム特有の脆弱性となります。これらの場合には、我々はテイントスタイルのトラバーサルによって対処します。

全体として、4つのトラバーサルを実施することで、これまで知られていなかった18件の脆弱性を特定することができ、そのすべてがカーネル開発者によって対処されました。特に懸念されるのは、合計18件のうち9件が、昨年普及していた脆弱性タイプであったことです。これは、攻撃者が既存の脆弱性パターンをモデル化することで、トラバーサルを用いてコードベース内の類似した欠陥を効果的に発見できることを示しています。私たちの調査結果の概要を表IIIに示します。

次に、グラフトラバーサルを用いた脆弱性発見プロセスを例示するケーススタディについて説明します。ここでは、シンプルなトラバーサルによって、わずか11個の関数をレビューするだけで、以前は知られていなかった7つのバッファオーバーフローの脆弱性を特定できたことを示します。

# *D. Case Study: Buffer Overflow Identification*

以下では、長さフィールドに対する検証チェックの欠如によって引き起こされるバッファオーバーフローを特定するためのトラバーサルを示します。これらの種類の脆弱性は、テイントスタイルの記述を用いることでエレガントに表現できるため、T<sup>0</sup> ◦ UNSANITIZED<sup>T</sup> <sup>s</sup> <sup>1</sup> ◦ T2 という形でトラバーサルとして表せます。この目的のために、私たちは単に定義する必要があります

| Type                 | Location                                 | Developer Feedback | Identifier    |
|----------------------|------------------------------------------|--------------------|---------------|
| Buffer Overflow      | arch/um/kernel/exitcode.c                | 修正済み             | CVE-2013-4512 |
| Buffer Overflow      | drivers/staging/ozwpan/ozcdev.c          | 修正済み             | CVE-2013-4513 |
| Buffer Overflow      | drivers/s390/net/qeth_core_main.c        | 修正済み             | CVE-2013-6381 |
| Buffer Overflow      | drivers/staging/wlags49_h2/wl_priv.c     | 修正済み             | CVE-2013-4514 |
| Buffer Overflow      | drivers/scsi/megaraid/megaraid_mm.c      | 修正済み             | -             |
| Buffer Overflow      | drivers/infiniband/hw/ipath/ipath_diag.c | 修正済み             | -             |
| Buffer Overflow      | drivers/infiniband/hw/qib/qib_diag.c     | 修正済み             | -             |
| Memory Disclosure    | drivers/staging/bcm/Bcmchar.c            | 修正済み             | CVE-2013-4515 |
| Memory Disclosure    | drivers/staging/sb105x/sb_pci_mp.c       | 修正済み             | CVE-2013-4516 |
| Memory Mapping       | drivers/video/au1200fb.c                 | 修正済み             | CVE-2013-4511 |
| Memory Mapping       | drivers/video/au1100fb.c                 | 修正済み             | CVE-2013-4511 |
| Memory Mapping       | drivers/uio/uio.c                        | 修正済み             | CVE-2013-4511 |
| Memory Mapping       | drivers/staging//drv_interface.c         | 修正済み             | -             |
| Memory Mapping       | drivers/gpu/drm/i810/i810_dma.c          | 修正対応中           | -             |
| Zero-byte Allocation | fs/xfs/xfs_ioctl.c                       | 修正済み             | CVE-2013-6382 |
| Zero-byte Allocation | fs/xfs/xfs_ioctl32.c                     | 修正済み             | CVE-2013-6382 |
| Zero-byte Allocation | drivers/net/wireless/libertas/debugfs.c  | 修正済み             | CVE-2013-6378 |
| Zero-byte Allocation | drivers/scsi/aacraid/commctrl.c          | 修正済み             | CVE-2013-6380 |

TABLE III: 私たちの4つのグラフトラバーサルを用いて発見されたゼロデイ脆弱性

攻撃者が制御するソースには適切なトラバーサル T<sup>0</sup>、サニタイザには T <sup>s</sup> <sup>1</sup>、そして最後に、セキュリティ上重要なシンクには T<sup>2</sup> を用います。まず、攻撃者が制御するソースから始めますが、これは調査対象のアプリケーションに固有です。Linuxカーネルの場合、潜在的に有害な入力の代表的な2つのソースが考慮されます。

- *ユーザー／カーネル空間のインターフェース.* データは、さまざまなAPI関数を使用してユーザー空間からカーネル空間にコピーできます。例として、攻撃者が制御するデータによって最初の引数が汚染される *copy from user* 関数を考えます。これは、トラバーサル T <sup>0</sup> <sup>0</sup> = ARG<sup>1</sup> *copy from user* によって表現できます。
- *システムコールハンドラのパラメータ*。攻撃者は、対応するシステムコールを呼び出すことによって、システムコールハンドラのパラメータを直接制御することができます。例えば、write システムコールの *count* パラメータを考えます。ここでは、PARAM<sup>p</sup> および FUNC<sup>f</sup> がそれぞれ p という名前のパラメータや、名前に f という部分文字列を含む関数のノードに対して非空であるとし、T <sup>1</sup> <sup>0</sup> = FUNC( *write*) ◦ PARAM*cnt* というトラバーサルを使います。

データシンクとして、攻撃者がバッファ内にコピーされるデータ量を制御できるケースを特定することに関心があるため、*copy from user* および *memcpy* 呼び出し時に渡される長さフィールド（すなわち第3引数）を考慮します。システムコールハンドラの場合、解析をさらに制限し、*copy from user* への呼び出しのみを解析することで、長さフィールドだけでなくコピーされるデータそのものも攻撃者の制御下にあることを保証します。このようにしてシンクのトラバーサルは T<sup>0</sup><sup>2</sup> = ARG<sup>3</sup> *memcpy* および T<sup>1</sup><sup>2</sup> = ARG<sup>3</sup> *copy from user* によって与えられます。

最後に、長さフィールドが適切にサニタイズされているとみなせる、少なくとも次のいずれかの条件が満たされている場合、誤検知の数を減らします。

- *宛先バッファの動的割り当て。* 宛先バッファは、長さフィールドを使用してバッファのサイズを指定することで動的に割り当てられます。そのため、バッファはデータを十分に格納できる大きさになります。
- *Relational expressions.* 長さフィールドは条件内の関係式で使用されます。例えば、x <

バッファサイズ、またはマクロ *min* への呼び出しにおいて。なお、このようなチェックは誤っている場合があり、このルールは偽陽性と偽陰性のトレードオフに関する実用的な例です。

したがって、サニタイザーのトラバーサル T<sup>s</sup><sup>1</sup> を <sup>T</sup><sup>s</sup><sup>1</sup> = OR(V<sup>s</sup><sup>0</sup>, <sup>V</sup><sup>s</sup><sup>1</sup>) と定義します。ここで、<sup>V</sup><sup>s</sup><sup>0</sup> は最初の引数に s を含むアロケーションにマッチするトラバーサルであり、V<sup>s</sup><sup>1</sup> は s を含む相対式および *min* への呼び出しにマッチするトラバーサルです。最終的なトラバーサルは次のようになります。

OR(
$$
\mathcal{T}_0^0 \circ \text{UNSANITIZED}_{\mathcal{T}_1^s} \circ \text{OR}(\mathcal{T}_2^0, \mathcal{T}_2^1),
$$
 $\mathcal{T}_0^1 \circ \text{UNSANITIZED}_{\mathcal{T}_1^s} \circ \mathcal{T}_2^1$ )

このトラバーサルをLinuxのソースコード全体で実行すると、表IVに示されている11個の関数が返されます。そのうち7つの関数はバッファオーバーフローの脆弱性です。例として、図6は脆弱な関数*qeth snmp command*を示しています。13行目で攻撃者によって制御されるデータがローカル変数req lenの初期化に使用されています。この変数は28行目でサニタイズされることなくコピー操作の長さフィールドとして利用されています。そのため、攻撃者はバッファ*snmp*をオーバーフローさせ、任意のコードが実行される可能性があります。

| Filename                                 | Function             |
|------------------------------------------|----------------------|
| arch/um/kernel/exitcode.c                | exitcode proc write  |
| security/smack/smackfs.c                 | smk write rules list |
| drivers/staging/ozwpan/ozcdev.c          | oz cdev write        |
| drivers/infiniband/hw/ipath/ipath_diag.c | ipath diagpkt write  |
| drivers/infiniband/hw/qib/qib_diag.c     | qib diagpkt write    |
| drivers/scsi/megaraid/megaraid_mm.c      | mimd to kioc         |
| drivers/scsi/megaraid.c                  | megadev ioctl        |
| drivers/char/xilinx_/xilinx_hwicap.c     | hwicap write         |
| drivers/s390/net/qeth_core_main.c        | qeth snmp command    |
| drivers/staging/wlags49_h2/wl_priv.c     | wvlan uil put info   |
| arch/ia64/sn/kernel/sn2/sn_hwperf.c      | sn hwperf ioctl      |

この表は、さまざまなLinuxカーネルソースファイルと、それぞれの主要な機能を示しています。各ファイルは異なるドライバーやサブシステムに属しており、それぞれの行の Function 列は、そのソースファイルで実装されている主なインターフェースや処理内容を簡単に説明しています。

TABLE IV: このセクションで説明したグラフトラバーサルを用いてLinuxカーネルから抽出された11個の関数です。脆弱性のあるものは網掛けされています。

Here is your translation, with only the prose (comments) translated to Japanese. All code, headings, etc., remain unchanged.

```markdown
| int qeth_snmp_command(struct qeth_card *card, | 1  |
|-----------------------------------------------|----|
|                                               |    |
| char __user *udata)<br>{                      | 2  |
|                                               | 3  |
| struct qeth_cmd_buffer *iob;                  | 4  |
| struct qeth_ipa_cmd *cmd;                     | 5  |
| struct qeth_snmp_ureq *ureq;                  | 6  |
| int req_len;                                  | 7  |
| struct qeth_arp_query_info qinfo = {0, };     | 8  |
| int rc = 0;                                   | 9  |
| // []                                         | 10 |
| /* 4バイト（data_len 構造体メンバ）をスキップして | 11 |
| req_len を取得する */                         | 12 |
| if (copy_from_user(&req_len, udata            | 13 |
| + sizeof(int),sizeof(int)))                   | 14 |
| return -EFAULT;                               | 15 |
|                                               | 16 |
| ureq = memdup_user(udata, req_len +           | 17 |
| sizeof(struct qeth_snmp_ureq_hdr));           | 18 |
| if (IS_ERR(ureq)) {                           | 19 |
| QETH_CARD_TEXT(card, 2, "snmpnome");          | 20 |
| return PTR_ERR(ureq);                         | 21 |
| }                                             | 22 |
| // []                                         | 23 |
| iob = qeth_get_adapter_cmd(card,              | 24 |
| IPA_SETADP_SET_SNMP_CONTROL,                  | 25 |
| QETH_SNMP_SETADP_CMDLENGTH + req_len);        | 26 |
| // []                                         | 27 |
| memcpy(&cmd->data.setadapterparms.data.snmp,  | 28 |
| &ureq->cmd, req_len);                         | 29 |
| rc = qeth_send_ipa_snmp_cmd(card, iob,        | 30 |
| QETH_SETADP_BASE_LEN + req_len,               | 31 |
|                                               |    |
| qeth_snmp_command_cb, (void *)&qinfo);        | 32 |
| // []                                         | 33 |
| kfree(ureq);                                  | 34 |
| kfree(qinfo.udata);                           | 35 |
| return rc;                                    | 36 |
| }                                             | 37 |
```
Only the comment in lines 11–12 has been translated as requested. No other prose was found in the code portion.

Fig. 6: 私たちの手法を用いて発見されたLinuxカーネルドライバ内のバッファオーバーフロー脆弱性。

#### VII. LIMITATIONS

Linuxカーネルにおいていくつかの未知の脆弱性を発見できたことは、私たちの手法の有効性を明確に示しています。しかしながら、考慮すべき制限事項も存在します。まず、私たちの手法は純粋に静的であるため、静的プログラム解析が本質的に持つ限界を克服することはできません。制御フローおよびデータフローの追跡は実装していますが、たとえばシンボリック実行を用いた場合のように、同等でありながら異なる形で記述された式を見つけるためにコードを解釈することは行いません。その結果、競合状態のような実行時の振る舞いによって引き起こされる脆弱性は、コードプロパティグラフを用いてモデル化することができません。

第二に、脆弱性発見の問題が一般の場合には決定不能であるという事実により[33]、私たちの手法は潜在的に脆弱なコードのみを発見できます。特定の種類の脆弱性を対象とした手法とは対照的に、私たちはセキュリティ上の欠陥の存在を必ずしも保証しませんが、非常に大規模なソフトウェアプロジェクトにおいて潜在的な脆弱性を特定できる一般的な脆弱性発見手法に注目しています。

第三に、私たちの現在の実装は、手続き間解析には対応していません。グラフデータベース内で呼び出し関係に従って関数をリンクしていますが、効果的な手続き間トラバーサルを定式化するには追加の課題があります。これは私たちのアプローチ自体の本質的な制限ではなく、制御フローグラフやプログラム依存グラフの手続き間バリアントとして、手続き間制御フローグラフやシステム依存グラフが存在しています［17を参照］。今後は、手続き間解析にも本研究を拡張することを目指しています。

#### VIII. RELATED WORK

ソースコード内の脆弱性パターンをスキャンする手法は長い歴史があり、Microsoft PREfast [23] や PScan [5]、RATS [4] など、実際に使用されている多くの脆弱性スキャナがこのアイデアを採用して、いくつかのよく知られた脆弱性を検出してきました。これらのツールは特に開発プロセス中に有用ですが、通常、複雑で微妙な脆弱性をコード内で特定することはできません。また、これらのツールを特定のコードベースの特徴に合わせて適応させることもできません。その対策として、専門家の知識を静的解析手法に組み込むことを検討する研究者も現れました。例えば Evans と Larochelle [8] は Splint を説明しており、これはアナリストがアノテーションを付与することで、バッファオーバーフローやフォーマット文字列脆弱性のさまざまな実装形態を見つけることを可能にします。さらに、Vanegue と Lahiri [39] は、Microsoft COM コンポーネント内の脆弱性を特定するための拡張静的チェッカー HAVOC-Lite を提案しています。私たちのアプローチもこれらと関連していますが、より広範な脆弱性を扱える一方で、精度がやや劣る解析となっています。

セキュリティ研究の別の分野では、ソースコード内の脆弱性[e.g., 22, 25]やその他の欠陥[e.g., 14, 15, 30]を発見するためのクエリ言語が研究されています。例えば、LivshitsとLam[24]は、クエリ言語PQLで記述された高水準のプログラム記述から静的チェッカーを構築しています。彼らはその後、JavaコードにおけるクロスサイトスクリプティングやSQLインジェクションの脆弱性を発見するために静的汚染解析を用いています。同様に、Shankarら[36]もCプログラムにおけるフォーマット文字列の脆弱性を特定するために静的汚染解析を利用しています。これらの手法は特定の種類の脆弱性の識別には非常に効果的ですが、メモリ漏洩やリソースリークなど、より広範な種類の脆弱性には適用できることが示されていません。さらに、静的汚染解析はデータフローに対する受動的な観点に本質的に制約されており、たとえば式の評価ができないという限界があります。

静的プログラム解析の欠点に対処するために、ファズテスト[10, 13, 42]や動的テイントトラッキング[例: 28, 40]といった動的解析手法が提案されています。しかしながら、この方法では実行時に引き起こされる脆弱性しか発見できないため、通常とは異なる制御経路に存在するセキュリティ上の欠陥が見逃されることがよくあります。この問題を解決するために、いくつかの研究者はファズテストとシンボリック実行を組み合わせて、解析を積極的に珍しい経路の探索に導く手法を提案しています。ただし、これらのアプローチは考慮すべきプログラム経路の数が指数関数的に増加するため、コストが高く、実際には運用が難しい場合が多いです。

最後に、脆弱性発見と直接関係はありませんが、Reps [32] はグラフ到達可能性問題を解くことでプログラム解析を行うというアイデアを提唱し、多くのデータフロー問題やプログラムスライシングがグラフ探索によって解決できることを示しました。さらに、Kinloch と Munro [19] は、バグ検出やプログラム理解を支援するための新しい表現の作成について検討しています。彼らは本質的にシステム全体のプログラム依存グラフである Combined C Graph（CCG）を提示しました。同様に、Krinke と Snelting [20] は、構文情報だけでなく制御およびデータフロー情報も組み合わせることで、制約解決による精密なプログラムスライス計算を可能とする細粒度のシステム依存グラフを提示しています。しかし、彼らは本研究で扱うグラフトラバーサルによるバグや脆弱性パターンの記述については検討していません。

#### IX. CONCLUSION

ソフトウェアにおける脆弱性を発見するための実用的な手段をアナリストに提供することは、コンピュータシステムのセキュリティを確保する上で非常に重要です。本稿では、大量のコードから脆弱性を検出するための手法を提案しました。この手法は、ソースコードの新しい表現方法である「コードプロパティグラフ」に基づいており、グラフ探索によって一般的な脆弱性のパターンをモデル化することを可能にします。この表現を用いることで、バッファオーバーフローやフォーマット文字列脆弱性、メモリアドレスリークなど、多くのよく知られた脆弱性タイプに対して、小さく簡潔なトラバーサルを提示しました。さらに、私たちはLinuxカーネルという大規模なコードベースをコードプロパティグラフで監査し、ベンダーによって確認・修正された、合計18件のこれまで知られていなかった脆弱性を特定しました。

コードプロパティグラフとグラフトラバーサルは、一般的な種類の脆弱性を見つけるのに適していますが、より重要なのは、特定のコードベースに固有の脆弱性を識別するためにうまく調整できることです。トラバーサルを洗練させることで、アナリストは誤検知率と見逃し率を完全にコントロールすることができ、分析の発見フェーズではあいまいなトラバーサルを策定し、十分に理解された脆弱性タイプの事例を捉えるためには非常に正確なトラバーサルを作成することが可能です。

#### ACKNOWLEDGMENTS

著者らは、プロジェクトPROSEC（FKZ 01BY1145）におけるBMBFからの資金提供、およびプロジェクトDEVIL（RI 2469/1-1）におけるDFGからの資金提供を謝辞します。

#### REFERENCES

- [1] A. Aho, R. Sethi, and J. Ullman. *Compilers Principles, Techniques, and Tools*. Addison-Wesley, 1985.
- [2] T. Avgerinos, S. K. Cha, B. L. T. Hao, and D. Brumley. AEG: Automatic Exploit Generation. In *Proc. of Network and Distributed System Security Symposium (NDSS)*, 2011.
- [3] I. D. Baxter, A. Yahin, L. Moura, M. S. Anna, and L. Bier. 抽象構文木を用いたクローン検出。In *Proc. of International Conference on Software Maintenance (ICSM)*, 1998.
- [4] B. Chess と M. Gerschefske によるセキュリティのためのラフ監査ツール。Google Code、http://code.google.com/p/rough-auditing-tool-for-security/、2013年11月に訪問。
- [5] A. DeKok. Pscan: Cソースファイル用の限定的な問題スキャナー。http://deployingradius.com/pscan/, 2013年2月閲覧。
- [6] S. Eidemiller と E. Dalci. CWE-676: 潜在的に危険な関数の使用。MITRE Corporation., 2012.
- [7] S. Esser. Mountain Lion/iOSの脆弱性ガレージセール。SyScan Conferenceでのプレゼンテーション, 2013年.
- [8] D. Evans と D. Larochelle. 拡張可能な軽量静的解析を用いたセキュリティの向上。*IEEE Software*, 19 (1):42–51, 2002.
- [9] J. Ferrante, K. J. Ottenstein, and J. D. Warren. プログラム依存グラフとその最適化への利用について。*ACM Transactions on Programming Languages and Systems*, 9:319–349, 1987.
- [10] V. Ganesh、T. Leek、および M. Rinard。テイントに基づく指向性のホワイトボックスファジング。*Proc. of the International Conference on Software Engineering*、2009年。
- [11] H. Gascon、F. Yamaguchi、D. Arp、K. Rieck。埋め込まれたコールグラフを用いたAndroidマルウェアの構造的検出。*Proc. of ACM CCS Workshop on Artificial Intelligence and Security (AISEC)*、2013年11月。
- [12] gera と riq。フォーマット文字列の悪用における進歩。*Phrack Magazine*, 0x3b(0x07), 2002.
- [13] P. Godefroid、M. Y. Levin、D. Molnar。「SAGE: セキュリティテストのためのホワイトボックスファジング」。*Communications of the ACM*、55(3):40–44、2012年。
- [14] S. F. Goldsmith、R. O'Callahan、A. Aikenによる「Relational queries over program traces」。*Proc. of ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages and Applications (OOPSLA)*、2005年。
- [15] S. Hallem、B. Chelf、Y. Xie、D. Engler。システム固有の静的解析を構築するためのシステムと言語。*Proc. of ACM SIGPLAN International Conference on Programming Languages Design and Implementation (PLDI)*, 2002。
- [16] S. Heelan. 脆弱性検出システム：ロボットではなくサイボーグを考えよう。*IEEE Security & Privacy*, 9(3):74–77, 2011.
- [17] S. Horwitz, T. Reps, and D. Binkley. 依存グラフを用いた手続き間スライシング。In *Proc. of ACM SIGPLAN International Conference on Programming Languages Design and Implementation (PLDI)*, pages 35–46, 1988.
- [18] N. Jovanovic、C. Kruegel、E. KirdaによるPixyは、Webアプリケーションの脆弱性を検出するための静的解析ツールです。*Proc. of IEEE Symposium on Security and Privacy*にて、2006年、ページ6–263で発表されました。
- [19] D. A. Kinloch と M. Munro．Cプログラムを統合Cグラフ表現を用いて理解する．In *Proc. of International Conference on Software Maintenance (ICSM)*, 1994.
- [20] J. Krinke と G. Snelting. スライシングと制約解決を応用した測定ソフトウェアの検証。 *Information and Software Technology*, 40(11):661–675, 1998.
- [21] J. A. KupschとB. P. Miller。手動と自動の脆弱性評価の比較: ケーススタディ。In *Proc. of Workshop on Managing Insider Security Threats (MIST)*, pages 83–97, 2009.
- [22] M. S. Lam, J. Whaley, V. B. Livshits, M. C. Martin, D. Avots, M. Carbin, and C. Unkel. コンテキスト感応型プログラム解析をデータベースクエリとして扱う。In *Proc. of Symposium on principles of database systems*, 2005.
- [23] J. R. Larus, T. Ball, M. Das, R. DeLine, M. Fahndrich, ¨

J. Pincus、S. K. Rajamani、および R. Venkatapathy による「Righting software」は、2004年に発表された論文であり、*IEEE Software* の21巻3号、ページ92–100に掲載されています。

- [24] V. B. Livshits と M. S. Lam による論文。静的解析を用いてJavaアプリケーションのセキュリティ脆弱性を発見します。*Proc. of USENIX Security Symposium*, 2005 に掲載されました。
- [25] M. Martin、B. Livshits、および M. S. Lam。プログラムクエリ言語 PQL を使用してアプリケーションのエラーやセキュリティの脆弱性を発見する。 In *Proc. of ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages and Applications (OOPSLA)*, 2005.
- [26] H. Moore. ユニバーサルプラグアンドプレイ（UPnP）におけるセキュリティ上の欠陥：プラグを抜き、利用しないでください。 技術報告書、Rapid 7、2013年。
- [27] D. Muthukumaran, T. Jaeger, and V. Ganapathy. 権限付与フックの配置を自動化するために選択肢を活用する。In *Proc. of ACM conference on Computer and Communications Security*, 2012.
- [28] J. Newsome と D. Song による、コモディティソフトウェア上のエクスプロイトの自動検出、解析、およびシグネチャ生成のための動的テイント解析。*ネットワークおよび分散システムセキュリティシンポジウム（NDSS）* 論文集、2005年。
- [29] J. W. Oh. 最近のJava悪用の傾向とマルウェア。Black Hat Las Vegas 2012での講演。
- [30] S. PaulとA. Prakashによる、プログラムパターンを用いたソースコード検索のためのフレームワーク。*IEEE Transactions on Software Engineering*, 1994年。
- [31] C. Planet. フォーマット文字列への追悼. *Phrack Magazine*, 0x43(0x09), 2010.
- [32] T. Reps. グラフ到達可能性によるプログラム解析。*Information and Software Technology*, 1998.
- [33] H. G. Rice. 再帰的に列挙可能な集合のクラスとそれらの決定問題。*Transactions of the American Mathematical Society*, 74:358–366, 1953.
- [34] M. A. RodriguezとP. Neubauer。「グラフトラバーサルパターン」。*Graph Data Management: Techniques and Applications*, 2011年。
- [35] E. Schwartz, T. Avgerinos, and D. Brumley. 動的テイント解析と前方シンボリック実行について知りたかったすべてのこと（でも聞くのが怖かったかもしれないこと）. In *Proc. of IEEE Symposium on Security and Privacy*, pages 317–331, 2010.
- [36] U. Shankar, K. Talwar, J. S. Foster, and D. Wagner. 型修飾子を用いたフォーマット文字列の脆弱性検出。In *Proc. of USENIX Security Symposium*, pages 201–218, 2001.
- [37] S. Sparks, S. Embleton, R. Cunningham, and C. C. Zou. 自動脆弱性分析: 進化的な入力生成のために制御フローを活用する。In *Proc. of Annual Computer Security Applications Conference (ACSAC)*, pages 477–486. IEEE Computer Society, 2007.
- [38] M. Sutton、A. Greene、P. Amini。*Fuzzing: Brute Force Vulnerability Discovery*。Addison-Wesley Longman、2007年。
- [39] J. Vanegue、L. Bloomberg、S. K. Lahiri。拡張スタティックチェッカーを用いた実用的なリアクティブセキュリティ監査に向けて。In *Proc. of IEEE Symposium on Security and Privacy*, 2013.
- [40] T. Wang、T. Wei、Z. Lin、およびW. Zou。IntScope: x86における整数オーバーフロー脆弱性を自動的に検出します

binary をシンボリック実行を用いて解析する。

- [41] M. Weiser. プログラムスライシング。*Proc. of International Conference on Software Engineering*, 1981。
- [42] M. Woo, S. K. Cha, S. Gottlieb, and D. Brumley. ブラックボックスの突然変異型ファジングのスケジューリングについて。In *Proc. of ACM Conference on Computer and Communications Security (CCS)*, 2013.
- [43] F. Yamaguchi, M. Lottmann, and K. Rieck. 抽象構文木を用いた一般化された脆弱性の外挿法について。In *Proc. of Annual Computer Security Applications Conference (ACSAC)*, pages 359–368, Dec. 2012.
- [44] F. Yamaguchi, C. Wressnegger, H. Gascon, and K. Rieck. Chucky: 脆弱性発見のためにソースコード中の不足しているチェックを明らかにする。In *Proc. of ACM Conference on Computer and Communications Security (CCS)*, 2013.
- [45] M. Zitser、R. Lippmann、T. Leek。オープンソースコードからの悪用可能なバッファオーバーフローを使用して静的解析ツールをテストしました。In *Proc. of ACM SIGSOFT International Symposium on Foundations of Software Engineering SIG-SOFT FSE*, pages 97–106, 2004.

# APPENDIX

# *A. The Traversal* TNODES

TNODES の走査は、集合 X に含まれる任意のノードを根とする AST のすべての子ノードを識別するために使用されます。この走査は、形式的には次のように定義できます。

$$
\text{TNODES}(X) = \bigcup_{v \in X} \left( v \cup \left( \bigcup_{v_c \in \text{OUT}_{\mathcal{A}}(\{v\})} \text{TNODES}(\{v_c\}) \right) \right).
$$

再帰的定義は、ASTのエッジ（Aとラベル付けされた）に適用される基本的なトラバーサルOUT<sup>l</sup>のみに基づいており、木に含まれるノードはそのノード自身と、その部分木に含まれるノードによって与えられることを単純に述べています。

# *B. The Traversals* STATEMENT *and* FUNCTION

ステートメントノードは、コードプロパティグラフが提供する3つのビューの中心的な接続点です。その結果、任意のステートメントでないノードから、それを囲むステートメントへのトラバースがしばしば必要になります。この目的のために、V-D節で使用したトラバースSTATEMENTを導入し、集合X内のすべてのノードに対してステートメントノードを特定します。

$$
\texttt{STATEMENT}(X) = \bigcup_{v \in X} s(\{v\})
$$

どこ

$$
s(X) = \begin{cases} X_1, & \text{もし } \mu(X_1, code) = \text{Strut} \text{ の場合} \\ s(\text{IN}_{\mathcal{A}}(X)), & \text{それ以外の場合} \end{cases}
$$

そして、X<sup>1</sup>は集合Xの唯一のメンバーを示します。この走査は、*Stmt*型のノードに到達するまで、ASTの入力エッジに沿って進みます。同様の定義は、トラバーサルFUNCTIONについても与えることができ、これは親ノードをたどっていき、囲んでいる関数ノードが見つかったところで停止します。

#### *C.* PAIRS *and* PAIRFILTER

ASTの2つのサブツリーを比較することは、脆弱性を検出するトラバーサルを策定する際に繰り返し発生する問題です。この目的のために、2つのトラバーサルT<sup>1</sup>とT<sup>2</sup>に対して関数PAIRS<sup>T</sup><sup>2</sup> <sup>T</sup><sup>1</sup>を定義します。

$$
\mathrm{PAIRS}_{\mathcal{T}_1}^{\mathcal{T}_2}(X) = \bigcup_{v \in X} \{(\mathcal{T}_1(\{v\}), \mathcal{T}_2(\{v\})\}
$$

対応する関数も

$$
PAIRFILTER_p(X) = \{(v_1, v_2) : (v_1, v_2) \in X \text{ かつ } p(v_1, v_2)\}
$$

抽象構文木のすべてのペア (v1, v2) について、基準 p(v1, v2) が真であるものを取得します。

#### *D. Traversals for Type Information*

Section IV で説明されているコードプロパティグラフにより、次のようなトラバーサルを使って抽象構文木から変数の型を判定することがすでに可能です。

$$
\text{Type}_s = \text{TypeNode} \circ \text{Filter}_{p_s} \circ \text{Twodes}
$$

ここで、ps(v) は、v がシンボル s の識別子またはパラメータ宣言である場合に真となり、TYPENODE は識別子またはパラメータ宣言の型ノードへとたどります。しかし、実際には、変数の定義や文で使用されるシンボルへの迅速なアクセスを提供するために、コードプロパティグラフに追加のグラフ構造を付加します。制御フローグラフからプログラム依存グラフを構築する際には、すでに全ての文で *使用される* および *定義される* シンボルが計算されている必要があるため、この情報を *関数シンボルグラフ* として明示的にします。

関数シンボルグラフ G<sup>S</sup> = (VS, ES, λS, μS) はプロパティグラフであり、V<sup>S</sup> には関数で使用される各シンボルに対する属性付きノードが含まれます。関数 μ<sup>S</sup> は、各ノードに対応するシンボルを保持する *code* という名前のプロパティを追加します。プロパティキーと値の集合は、それぞれASTの集合の部分集合となっています。さらに、エッジ集合 E<sup>S</sup> には、各文からその文で使用または定義された各シンボルへのエッジが含まれており、エッジラベリング関数 λ<sup>S</sup> : E<sup>S</sup> → Σ<sup>S</sup> により、それぞれ D および U というラベルが付けられます。

関数記号グラフによって、私たちの作業で有用であることが分かった次のトラバーサルを定義することができます。

• DEFINES。DEFINES のトラバーサル

$$
\mathsf{DEFINES}(V) = \mathsf{OUT}_{\mathcal{D}}(V)
$$

ノードを、そのノードが定義しているすべてのシンボルのノードへ変換します。

• USES. このトラバーサルは、ノードを使用されているすべてのシンボルへ変換します

$$
USES(V) は OUT_{\mathcal{U}}(V) となります。
$$

• TYPEs。トラバーサルTYPE<sup>s</sup>は、ASTノードから始めてローカルシンボルsの型を決定するために使用できます。

$$
\text{Type}_s = \text{TypeNode} \circ \text{Filter}_{p_s} \circ \text{In}_{\mathcal{D}} \circ \text{Uses}
$$

ps(v) は、v がシンボル s の識別子またはパラメータ宣言ノードである場合に真となり、それ以外の場合は偽となります。

これらのトラバーサルを備えることで、次のセクションで示すUNSANITIZEDトラバーサルを表現するのが容易になります。

# *E. The Traversal* UNSANITIZED

最後に、トラバーサルUNSANITIZEDMの正式な定義を示します。これは、汚染追跡型の脆弱性記述の中核となる要素です。このトラバーサルは、深さ優先で外向きの制御フローエッジに従い、次の場合にはノードで終了します：ノードが到達先ノードである場合、または次の3つの条件のいずれかが成立する場合です。(1) ノードがMのサニタイザー記述のいずれかに一致する場合、(2) ノードが追跡対象のシンボルに代入し、それを上書きする場合、(3) ノードがすでに2回訪問されている場合。

これらの終了基準を捉えるために、述語 ps <sup>M</sup>(v, V) を定義します。これは、任意の 0 ≤ i ≤ |M|−1 について、Mi({v}) = ∅、すなわち v が M<sup>i</sup> にマッチするか、または FILTER(μ(v,*code*)=s)◦DEFINES({v}) = ∅、すなわち v がシンボル s に割り当てている場合に true となります。さらに、ノードが訪問された回数を記録するためにマルチセット V を管理し、したがって p<sup>s</sup> <sup>M</sup>(v, V) は V(v)=2 の場合にも true となります。

私たちは、関数 u(v, d)<sup>s</sup> <sup>M</sup> を定義します。これは、制御フローグラフにおいて、始点ノード v から終点ノード d までのすべてのパスであって、M による検証を受けず、かつシンボル s を再定義しないものを表します。

$$
u(v, d)_{\mathcal{M}}^s = g(v, d, \emptyset, [])_{\mathcal{M}}^s
$$

g は次のように再帰的に定義されます。

Proseが含まれていないため、翻訳は不要です。数式や構造はそのままにしています。

<sup>v</sup>c∈OUTC({v})

この定義において、OUTC(v)はvから出る制御フローエッジによって接続されているノードを示し、Vはノードが訪問された回数を記録するためのマルチセットであり、pはこれまでにたどった経路です。関数uは単にこれら2つの変数をそれぞれ空集合と空リストに初期化し、深さ優先探索を実装した再帰的定義gを参照します。最後に、UPATH関数を定義でき、これは文で使用されているすべての記号についてuを計算します。

$$
\text{UPATH}_{\mathcal{M}}(d) = \bigcup_{s \in \text{USES}(\{d\})} \bigcup_{\text{src} \in S(s,d)} u(\text{src}, d)^s_{\mathcal{M}}
$$

ここで S(s, d) = PRODUCERS{s}({d}) となり、そして最後に

$$
\text{UNSANITIZED}_{\mathcal{M}}(X) = \text{FIRST} \circ \bigcup_{d \in \text{STATEMENT}(X)} \text{UPATH}_{\mathcal{M}}(d)
$$

これは、集合Xのすべての要素についてUPATHを計算し、トラバーサルFIRSTを使って各パスの開始ノードを抽出します。

実際には、非サニタイズパスが存在するかどうか *だけ* を判定できれば十分なことが多いため、私たちの実装ではパスのいずれかが見つかった時点でUPATHの計算を終了します。さらに、UNSANITIZEDは、Sに曖昧なソース記述を渡すことを許可することで、uが考慮するソース／シンクペアの数を減らし、さらに最適化することができます。最後に、深さ優先探索を最大パス長までの探索に制限することで、精度と必要な計算時間の間でトレードオフを図ることも可能です。
