# (State of) The Art of War: Offensive Techniques in Binary Analysis

Yan Shoshitaishvili、Ruoyu Wang、Christopher Salls、Nick Stephens、Mario Polino、Andrew Dutcher、John Grosen、Siji Feng、Christophe Hauser、Christopher Kruegel、Giovanni Vigna は、UC Santa Barbara に所属しています。

{yans,fish,salls,stephens,mario,dutcher,jmg,slipper,christophe,chris,vigna}@cs.ucsb.edu

*Abstract*—バイナリコードの脆弱性を発見し、悪用することは困難な作業です。データ構造や制御構造に関する高水準で意味的に豊かな情報が不足しているため、プログラムの特性解析を大規模に行うことが難しくなります。しかしながら、バイナリ解析の重要性は高まっています。多くの状況において、実際に*実行*されているコードについて何らかの特性を証明（あるいは否定）する唯一の方法がバイナリ解析なのです。

本論文では、過去に提案された多くの解析手法を実装するバイナリ解析フレームワークを紹介します。これらの手法を体系的に実装することにより、他の研究者がそれらを組み合わせて新しい手法を開発できるようにしています。さらに、これらの手法を統一的なフレームワーク内で実装することで、各アプローチを直接比較し、それぞれの長所と短所を特定することが可能となります。本論文で行った評価は、バイナリ脆弱性解析手法の有効性を評価するためにDARPAによって作成された最新のデータセットを用いて実施しました。

私たちのフレームワークはオープンソース化されており、セキュリティコミュニティで利用可能です。

# I. INTRODUCTION

インタプリタ言語やWorld Wide Webの普及にもかかわらず、バイナリ解析はコンピュータセキュリティの分野で依然として非常に重要な話題となっています。これにはいくつかの理由があります。第一に、インタプリタ言語も、結局はバイナリプログラムによって解釈されるか、またはJust-In-Time（JIT）コンパイルによってバイナリコードに変換されます。第二に、「コア」となるOSの構造やパフォーマンスが重要なアプリケーションは、依然として（通常、CやC++といった）バイナリコードにコンパイルされる言語で記述されています。第三に、Internet of Thingsの普及は、一般的に非常にリソースが限られているデバイスによって支えられています。これらのデバイスのファームウェアは、インタプリタやJust-In-Timeコンパイルにかける余分な処理能力がないため、やはり通常C言語で記述され、バイナリコードにコンパイルされる傾向があります。

残念ながら、多くの低水準言語はセキュリティ保証がほとんどなく、しばしば脆弱性の原因となっています。たとえば、バッファオーバーフローは、そのような脆弱性を軽減するための技術開発が継続的に行われているにもかかわらず、依然として最も一般的なソフトウェアの欠陥のひとつです。さらに悪いことに、「メモリ破損脆弱性」と呼ばれる広範なカテゴリの問題もほとんどが安全ではない言語の利用に起因しており、最も一般的な脆弱性のかなりの割合を占めています[2]。この問題は汎用コンピュータ機器のソフトウェアに限られたものではなく、スマートロックやペースメーカー、自動車に至るまで、遠隔から悪用可能な脆弱性が発見されています[10]。

もう一つ重要な点として考慮すべきなのは、コンパイラやツールチェーンにバグが全くないわけではないということです。プログラムのソースコードを解析することで証明された特性が、同じプログラムをコンパイルした後には保証されない場合があります。これは実際によくあることで、最近ではXcodeの悪意あるバージョンであるXcode Ghostが、数十以上の人気iOSアプリケーションにコンパイル時に悪意あるコードをこっそり挿入し、数百万ものユーザーのデバイスを危険にさらしました。こうした脆弱性は深刻で現実的な影響を及ぼすため、悪用される前に発見することが極めて重要です。このため、セキュリティ研究コミュニティは、バイナリプログラムの脆弱性を見つけ出すための解析手法の開発に多大な努力を注いできました。こうした「攻撃的」（解析対象のアプリケーションへの「攻撃」を見つけ出すため）な解析手法は、アプローチや対象とする脆弱性の種類に大きな幅がありますが、2つの主な問題を抱えています。

まず、バイナリ解析手法の多くの実装は、研究用プロトタイプとして開発されるだけで終わってしまいます。こうした場合、その貢献に費やされた多くの労力が無駄になり、将来の研究者はこれらの手法に基づいた作業を実装する際、しばしば最初からやり直さなければなりません。このような初期コストは進歩を妨げます。以前の手法を再実装するのに費やす一週間は、新しい解決策の開発に使われるはずだった一週間を失うことになるのです。

第二に、これらのシステムを再現するために必要な作業量や、それらが頻繁に一般公開されていないことから、その結果を複製するのは非現実的になります。そのため、個々のバイナリ解析技術の*適用性*が他の技術と比べてどのような位置づけにあるのかが不明確になります。これに加え、現代のオペレーティングシステムの本質的な複雑さや、アプリケーションとその環境との相互作用を正確かつ一貫してモデル化することの難しさがあるため、比較のための共通の基盤を確立するのは非常に困難です。比較が行われる場合でも、異なる実装の詳細や異なる評価用データセットを持つシステム同士で比較されがちです。

最初の課題を緩和するために、私たちはangrというバイナリ解析フレームワークを作成しました。これは、文献にある最先端のバイナリ解析技術の多くを統合したものです。私たちの目的は、この分野を体系化し、アクセスしやすくオープンで実用的な方法で、現在の研究から効果的な技術を実装することで、次世代のバイナリ解析技術の開発を促進することでした。それにより、さまざまな技術が容易に比較できるようにしています。angrは

© 2016, Yan Shoshitaishvili. IEEE にライセンス提供。DOI 10.1109/SP.2016.17

![](_page_0_Picture_16.jpeg)

静的手法と動的手法の両方を用いた多様な分析のための構成要素であり、提案された研究手法を容易に実装できるだけでなく、それらの有効性を相互に比較することも可能にします。さらに、これらの構成要素によって、さまざまな分析を組み合わせてそれぞれの強みを活かすことができます。

過去1年間で、2つ目の問題にも解決策が導入され、分析手法やツールの比較、そして研究の再現性を念頭に置いたアプローチが進められました。具体的には、DARPAがCyber Grand Challengeを組織し、自動バイナリ解析、脆弱性の発掘、エクスプロイトの生成、ソフトウェアパッチ作成の現状を探求することを目的とした競技大会を開催しました。この大会の一環として、DARPAは自動解析システムに現実的な課題を提示するよう特別に設計されたアプリケーション群を作成し、これらの課題のための*ground truth*（ラベル付けされた脆弱性とエクスプロイト）も同時に用意して公開しました。このバイナリのデータセットは、近年文献で提案されてきたさまざまな解析手法の相対的な有効性を評価するための完璧なテストスイートとなっています。さらに、DARPA CGCの予選イベントでは、世界中のチームが自動バイナリ解析システムを用いてこれらのバイナリへの攻撃と防御に挑戦しました。これらの結果は公開されており、既存の攻撃技術を文献上のものと競技参加者たちが提供した最良の手法と比較する機会となっています1。

私たちの目標は、現代の攻撃的手法の相対的な有効性を、これらをバイナリアナリシスシステムに実装することで理解することです。本論文では、次世代バイナリアナリシスエンジンであるangrの実装について詳述します。これらの手法を用いて開発したいくつかの攻撃的解析（具体的には、文献で現在説明されているアプローチの再現）を紹介し、脆弱性発見、エクスプロイトのリプレイ、自動エクスプロイト生成、ROPシェルコードのコンパイル、エクスプロイトのハーデニングといった分野での結果を再現します。また、これらの技術を組み合わせて能力を拡張することによって克服した課題や実現した改良点についても説明します。共通の解析エンジンの上にこれらの手法を実装することで、基盤となる解析エンジンの実装の違いではなく、アプローチの理論的な違いから生じる有効性の差を調査できます。これにより、DARPAが提供するデータセット上でこれらの手法の比較評価を実施することが可能となりました。

要約すると、私たちは以下の貢献を行います。

- 1) 私たちは、多くの既存の攻撃的バイナリアナリシス手法を単一で統一されたフレームワーク内で再現し、現在の攻撃的バイナリアナリシス技術の相対的な有効性を理解できるようにします。
- 2) 私たちは、多様なバイナリアナリシス手法を組み合わせて大規模に適用する際に生じる困難と、その困難に対する解決策を示します。
- 3) 私たちはフレームワークであるangrをオープンソース化し、将来のバイナリコード解析に関する研究に役立ててもらうことを目指します。

上位7チームはそれぞれ75万米ドルの賞金を獲得しました。このような動機付けがあったことで、各チームは自分たちに可能な限り最良の解析を行ったと考えられます。

# II. AUTOMATED BINARY ANALYSIS

研究者たちは長年にわたり、自動化されたバイナリ解析技術の実現に取り組んできました。しかし、この分野における近年の進歩にもかかわらず、そのようなシステムを実際の現場で開発・運用するのは依然として困難です。これは、対象となる技術によっては、現実世界のソフトウェアに対して自動解析を行うために克服すべき重大な制限が存在するためです。本節では、自動解析の課題に触れ、なぜDARPA Cyber Grand Challengeコンテストが異なる解析手法を比較するうえで有意義な手段となりうるのかについて論じます。

# *A. Trade-offs*

バイナリ解析が困難である理由は明らかです。ある意味で「クラッシュするか？」と問うことは「停止するか？」と問うのと同様であり、この種の解析はすぐに停止問題[32]という難題に直面します。プログラム解析、特に攻撃的なバイナリ解析は、実現可能性を維持するために慎重にバランスの取れた理論的なトレードオフに導かれる傾向があります。こうしたトレードオフが必要になる主な領域は二つあります。

リプレイ可能性。バグにもさまざまな種類があります。システムがどんなトレードオフをしているかによって、ある解析によって発見されたバグが*リプレイ可能*とは限りません。これは、解析がどのような*範囲*で実行されるかに起因します。中にはアプリケーション全体を最初から実行して、脆弱性を引き起こすために*正確に*何が必要なのか推論できる解析もあります。一方で、アプリケーションの個々の部分のみを解析するシステムもあり、その場合は特定のモジュールでバグを発見できても、そのモジュールの実行をどのように*トリガー*すればよいかまでは推論できません。そのため、クラッシュを自動で*リプレイ*することもできません。

セマンティックな洞察。一部の解析手法には、プログラムについて意味的に有意義な方法で推論する能力が欠けているものがあります。例えば、動的解析ではアプリケーションによって実行されたコードを追跡することはできても、*なぜ*そのコードが実行されたのかや、入力の*どの部分*がアプリケーションに特定の動作をさせたのかを理解することはできません。一方で、特定のプログラム動作の原因となった入力バイトを特定できるようなシンボリック解析は、より高いセマンティックな理解を持っていると言えるでしょう。

再現性のある入力や意味的な洞察を提供するためには、解析手法は特定のトレードオフを行う必要があります。例えば、再現性が高い場合、それに伴ってカバレッジが低くなる傾向があります。これは直感的です。なぜなら、再現性のある入力を生成する解析手法は、解析したい任意のコードに到達する方法を理解している必要があり、そうでない解析手法に比べて分析できるコードの範囲が限定されてしまうからです。一方で、バグを検証するためにトリガーとなる入力を再現できない場合、バグの再現性を重視しない解析は多くの*誤検知*（実際の脆弱性を示さない欠陥の検出）に悩まされます。再現可能な入力が存在しない場合、これらの誤検知はヒューリスティックによってフィルタリングする必要があり、その結果、見逃し（偽陰性）を生む可能性があります。

同様に、解析対象のプログラムに対して意味的な洞察を得るためには、解析では大量のデータを保存し、処理する必要がある。例えば、意味的な洞察を持つ動的解析では、プログラムの特定の分岐が実行されるために満たされるべき条件を保存することがある。一方、静的解析では選択されたデータ領域によって意味的な洞察の程度が調整される。より単純なデータ領域（例えば、実際の値の代わりに*範囲*のみを追跡する場合）は、より少ない意味的洞察しか表現しない。

再現性と高い意味的理解の両方を目指す分析は、スケーラビリティの問題に直面します。エントリーポイントからアプリケーションが取りうるすべての動作にわたって意味情報を保持するには、概念的にはあらゆる条件下でプログラムを実行するのと同等の処理能力が必要となります。このような分析はスケールしません。そのため、実用性を持たせるには情報を捨て、*完全性*（つまり、すべての潜在的な脆弱性が必ず発見されるという保証）を犠牲にしなければなりません。

これらの基本的な課題に加えて、実装上の課題も存在します。その中で最大のものが*環境モデル*です。高度なセマンティック解析を行うには、アプリケーションがその環境とどのように相互作用するかをモデル化しなければなりません。現代のオペレーティングシステムにおいては、こうした相互作用は非常に複雑です。たとえば、現代のLinuxのバージョンには300を超えるシステムコールが含まれており、解析システムが完全であるためには、それらすべての効果をモデル化しなければなりません。

Example. バイナリ解析におけるさまざまな課題を示すために、リスティング1に複数の脆弱性を持つプログラムの具体的な例を示します。わかりやすさと紙面の都合上、この例は単純化されており、読者に本論文で後述するアイデアを紹介することのみを目的としています。

memcpyへの3回の呼び出しを観察してください。10行目と30行目のものはバッファオーバーフローを引き起こしますが、16行目のものはそうではありません。しかし、追跡する情報量によっては、静的解析手法がmemcpyへの3つすべての呼び出しを潜在的なバグとして報告する場合があります。これは、バッファオーバーフローが発生しないことを判断するための情報が得られないためです。さらに、静的解析による報告にはこれらのバグの場所は含まれていますが、それらを引き起こす入力は提示されません。

動的手法であるファジングなどは、発見されたバグを引き起こす実際の入力を生成できるという利点があります。一方で、単純なファジング手法では通常、浅いバグしか発見できず、正確に作成された入力を必要とするコードを通過することができません。リスティング1では、動的手法は10行目のバグを見つけるのが難しいでしょう。なぜなら、その条件を満たすために特定の入力が必要だからです。しかし、30行目のオーバーフローはランダムなテストによって誘発できるため、ファジング手法によってそのバグを引き起こす入力が見つかるはずです。

バグを10行目で見つけるためには、抽象データモデルを導入して多くの可能な入力を同時に考察する方法がある。その一つの手法がDynamic Symbolic Execution (DSE) である。しかし、動的シンボリック手法は強力である一方で、「パス爆発問題」に悩まされる。これは、分岐ごとにパスの数が指数関数的に増加し、すぐに扱いきれなくなるという課題である。シンボリック実行によって10行目のバグは検出され、制約ソルバーを使ってそれに対応する入力が生成される。また、16行目のmemcpyがオーバーフローしないことも証明できるはずである。しかしながら、おそらく30行目のバグを見つけることはできないだろう。なぜなら、バグを引き起こさない膨大な数のパスが存在するためである。

```
1 int main(void) {
2 char buf[32];
4 char *data = read_string();
5 unsigned int magic = read_number();
7 // difficult check for fuzzing
8 if (magic == 0x31337987) {
9 // buffer overflow
10 memcpy(buf, data, 100);
11 }
13 if (magic < 100 && magic % 15 == 2 &&
14 magic % 11 == 6) {
15 // Only solution is 17; safe
16 memcpy(buf, data, magic);
17 }
19 // Symbolic execution will suffer from
20 // path explosion
21 int count = 0;
22 for (int i = 0; i < 100; i++) {
23 if (data[i] == 'Z') {
24 count++;
25 }
26 }
28 if (count >= 8 && count <= 16) {
29 // buffer overflow
30 memcpy(buf, data, count*20);
31 }
33 return 0;
34 }
```
リスト1: 異なる手法が異なるバグを報告する例。

# *B. The DARPA Cyber Grand Challenge*

2013年10月、DARPAはDARPA Cyber Grand Challenge [23] を発表しました。他分野（ロボティクスや自律走行車など）でのDARPA Grand Challengeと同様に、CGCでは世界中のチームが互いに競い合いますが、すべての参加者は自律型プログラムでなければなりません。Cyber Grand Challenge における参加者の目標は明快です。システムが自律的に提供されたソフトウェアの脆弱性を発見し、悪用し、修正しなければなりません。賞金総額は数百万ドルにのぼり、2015年6月に開催されたCGC予選イベントを完了した上位7チームにはそれぞれ750,000ドルが授与されました。また、2016年8月開催のCGC決勝イベントの上位3チームには、それぞれ2,000,000ドル、1,000,000ドル、750,000ドルが与えられます。

Cyber Grand Challenge の主催者たちは、自動バイナリ解析システム向けの競技を設計するにあたり、多くの配慮を重ねてきました。例えば、*環境モデル* の問題に対処するため、CGC専用の新しいOSを開発しました。それが DECREE OS です。DECREE は非常にシンプルなオペレーティングシステムで、システムコールはたった7つだけです。transmit、receive、waitfd はファイルディスクリプタ越しにデータを送信・受信・待機するため、random はランダムデータを生成するためのものです。

Certainly! Please provide the Markdown paragraph you would like me to translate.

6

There is no paragraph to translate in your input "12." If you provide a Markdown paragraph, I can translate it for you.

18

There is no paragraph to translate in your message; you've only entered "27". If you meant to provide a specific Markdown paragraph, please supply the text you want translated.

Please provide the Markdown paragraph you would like me to translate.

メモリ管理のために割り当てと解放を行い、終了するためにterminateを使用します。

単純な環境モデルにもかかわらず、CGCのためにDARPAが提供したバイナリは非常に多様な複雑さを持っています。サイズは4キロバイトから10メガバイトまでさまざまであり、実装されている機能も単純なエコーサーバーからウェブサーバー、画像処理ライブラリまで、多岐にわたります。DARPAは、これまで競技で使われたバイナリをすべてオープンソース化しており、概念実証のエクスプロイトや脆弱性に関する解説記事も公開しています [24]。

単純な環境モデルにより、大規模なバイナリアナリシス手法の正確な実装と評価が可能になるため、本論文の比較評価にはDARPA CGCのサンプルをデータセットとして使用しています。

#### *C. Comparative Analysis of CGC Binaries*

オフェンシブバイナリアナリシスは、対象となるアプリケーションについて推論するために、さまざまな基盤技術を用います。たとえば、異なる*領域*でデータを解析したり、テスト対象のアプリケーションと異なるレベルで相互作用したりすることがあります。次の2つのセクションでは、最新の技術動向を概観し、論文の残りで詳細に評価するいくつかの解析手法を選びます。ここでは、バイナリソフトウェアの脆弱性を特定し、それを突くことを目的とした解析（たとえば、シンボリック実行を使ったメモリ安全性違反の特定）に着目し、それらの基礎にあるより一般的なバイナリアナリシス技術（この場合はシンボリック実行そのもの）には踏み込みません。

#### III. BACKGROUND: STATIC VULNERABILITY DISCOVERY

静的手法は、プログラムを実行することなくその内容を解析します。通常、プログラムは*抽象領域*上で解釈されます。ビット列であるメモリ位置には、他の抽象的な実体が格納されます（よく知られている例では単なる整数ですが、後述するように、より抽象的な構造を含む場合もあります）。さらに、プログラムの構成要素としてメモリのレイアウトや、実行される経路さえも抽象化されることがあります。

ここでは、静的解析を2つのパラダイムに分けます。一方はプログラムの特性をグラフ（例えば、*control-flow graph*）としてモデル化するものであり、もう一方はデータ自体をモデル化するものです。

静的脆弱性識別手法には、セクションII-Aで議論されたトレードオフに関連する2つの主な欠点があります。第一に、結果が「リプレイ可能」ではないという点です。静的解析による検出は手動で検証する必要があり、検出された脆弱性をどのように引き起こすかという情報が得られません。第二に、これらの解析はより単純なデータ領域で動作する傾向があり、「意味的な洞察」が低下します。要するに、過大評価をしてしまうということです。つまり、ある種のプログラム特性（例えば脆弱性）が「存在しない」ことについては強い根拠を持って論じることができますが、脆弱性が「存在する」と述べる場合には誤検出（偽陽性）の割合が高くなってしまいます。

# *A. Recovering Control Flow*

*control-flow graph*（CFG）の復元は、ノードが命令の基本ブロックであり、エッジがそれらの間の制御フローの転送の可能性を示すもので、ほとんどすべての静的な脆弱性発見手法の前提条件となります。

制御フローの復元は、文献[21], [33], [34], [50], [58], [59]で広く議論されています。CFG（制御フローグラフ）の復元は、基本ブロック（例えば Ba）を逆アセンブルして解析し、その可能な*出口*（すなわち、後続の基本ブロック B<sup>b</sup>やBcなど）を特定し、それらがまだCFGに追加されていない場合は追加し、B<sup>a</sup>からB<sup>b</sup>やBcへの接続を作成し、B<sup>b</sup>とB<sup>c</sup>についても再帰的に同様の解析を繰り返すという、再帰的なアルゴリズムとして実装されています。このような手順を新たな出口が見つからなくなるまで繰り返します。CFGの復元では、根本的な課題が1つあります。それは間接ジャンプです。間接ジャンプとは、バイナリがレジスタやメモリアドレスに格納された値によって指定されるターゲットへ制御フローを移す場合のことです。*直接*ジャンプの場合、ターゲットは命令自体にエンコードされているため簡単に解決できますが、間接ジャンプの場合、そのターゲットはさまざまな要因によって変化する可能性があります。具体的には、間接ジャンプはいくつかのカテゴリに分類されます。

- 計算によるもの。計算によるジャンプのターゲットは、コードで指定された計算をアプリケーションが実行することによって決定されます。この計算は、他のレジスタやメモリ内の値に依存する場合もあります。この例として一般的なのがジャンプテーブルです。アプリケーションはレジスタやメモリ内の値を使ってメモリ上に格納されたジャンプテーブルへのインデックスを決定し、そのインデックスからターゲットアドレスを読み取り、そこへジャンプします。
- コンテキスト依存。間接ジャンプはアプリケーションのコンテキストに依存する場合があります。一般的な例としては、標準Cライブラリにある qsort() があります。この関数は比較のために *コールバック* を受け取ります。その結果、qsort() 内部の基本ブロックのジャンプ先のいくつかは、呼び出し元によって提供されるコールバック関数に依存します。
- オブジェクト感受性。コンテキスト感受性の特別なケースとして、オブジェクト感受性があります。オブジェクト指向言語では、オブジェクトの多態性のために仮想関数が必要になり、これはしばしば関数ポインタの*仮想テーブル*として実装されます。実行時にこれを参照してジャンプ先が決定されます。したがって、ジャンプ先は関数に渡されるオブジェクトの型に依存します。

さまざまなタイプの間接ジャンプに対処するために、異なる手法が設計されてきました。これらのいくつかの手法の実装については、セクションVIIで説明します。最終的に、CFGリカバリーの目標は、できるだけ多くの間接ジャンプのターゲットを*解決*し、CFGを作成することです。ある間接ジャンプは*集合*の値に解決されることがあります（*すなわち*、条件次第でジャンプテーブルのすべてのアドレスが使用される場合など）、そしてこの集合はオブジェクト感度やコンテキスト感度によって変化する可能性があります。ジャンプターゲットの解決度合いに応じて、CFGリカバリ解析には2つの特性があります。

健全性（Soundness）。CFG復元技術が*健全*であるとは、全ての潜在的な制御フローの遷移が生成されたグラフ内で表現されている場合を指します。すなわち、間接ジャンプが実際に到達可能なアドレスの*部分集合*にしか解決されない場合、グラフの健全性は低下します。もし基本ブロックの潜在的な到達先が見逃されると、そのブロックがCFG復元アルゴリズムによって認識されない可能性があり、さらにそのブロックによる全ての直接ジャンプや間接ジャンプも見逃されることになります。これは累積的な影響を及ぼし、間接ジャンプの解決に失敗すると、グラフの完全性が大幅に損なわれる場合があります。健全性は、バイナリ内の間接ジャンプターゲット特定における*真陽性*率と考えることができます。

Completeness（完全性）。完全なCFGリカバリーは、すべてのエッジが実際に起こり得る制御フローの移動を表すCFGを構築する。CFG解析が*completeness*（完全性）を重視して誤る場合、実際には存在し得ないエッジが含まれる可能性が高い。completeness（完全性）は、間接ジャンプターゲット識別における*false positive*（偽陽性）率の逆と考えることができる。

空のグラフを生成するCFGリカバリー解析は*完全*であると見なされ、すべての命令が他のすべての命令を指すグラフを生成する解析は*健全*であると考えられます。<sup>2</sup> 理想的なのはこの中間ですが、スケーラブルなアルゴリズムでこれを実現するのは困難です。したがって、異なる解析ごとに両者の間で異なる妥協が必要となります。

制御フローグラフのさらなる難しさは、*コードカバレッジ*、すなわち制御フローグラフによってどれだけのコードが発見されたかを正確に測定することにあります。これはしばしば、どのジャンプからも到達不可能な*デッドコード*（死んだコード）が存在することで複雑になります。

# *B. Vulnerability Detection with Flow Modeling*

プログラムのある脆弱性は、プログラムの特性を示すグラフの分析を通じて発見できる場合があります。

グラフベースの脆弱性発見。プログラムプロパティグラフ（*例：* コントロールフローグラフ、データフローグラフ、制御依存グラフ）は、ソフトウェア内の脆弱性を特定するために利用できる。これらの手法は当初ソースコードに適用されていたが [60], [61]、その後バイナリにも拡張されている [45]。これらの手法は、バグのモデルを構築し、コントロールフローやデータ依存グラフ内のノード集合として表現し、そのモデルがアプリケーション内で現れる箇所を特定することに依存している。しかし、このような手法は主に既知の脆弱なコードのコピーを探すことを目的としており、既存の脆弱性に関する知識を活用できるという利点がある。これらの手法とは異なり、本論文の焦点は全く新しい脆弱性の発見にある。

# *C. Vulnerability Detection with Data Modeling*

静的解析は、アプリケーションが操作するデータの抽象化に対しても推論を行うことができます。

Value-Set Analysis. 一般的な静的解析手法の一つに、*Value-Set Analysis*（VSA）[6]があります。大まかに言うと、VSAはプログラムの任意の時点における状態（*すなわち*、メモリやレジスタ内の値）の過大ではない近似を特定しようと試みます。

2Xu らは CFG の健全性と完全性を逆の意味で定義しており、空のグラフが健全で、完全なグラフが完全であるとしています [59]。本論文では、セクション III-A で述べた定義に従います。

このプログラムは、間接ジャンプの可能なターゲットや、メモリ書き込み操作の可能なターゲットを理解するために利用できます。これらの近似は精度が不足しているという欠点がありますが、*健全性*は保たれています。つまり、過剰に近似することはあっても、過少に近似することはありません。

メモリの読み書きに関する近似的なアクセスパターンを解析することで、バイナリ内部の変数やバッファの位置を特定することができます。これが完了すると、復元された変数やバッファの位置をさらに解析し、*重複している*バッファを見つけることが可能になります。例えば、こうした重複バッファはバッファオーバーフロー脆弱性によって引き起こされることがあり、各検出は潜在的な脆弱性を示しています。

# IV.

# BACKGROUND: DYNAMIC VULNERABILITY DISCOVERY

動的アプローチとは、特定の入力が与えられた際に、実際の環境やエミュレートされた環境でプログラムがどのように動作するかを解析する手法です。本セクションでは、基礎となる一般的なバイナリアナリシス手法ではなく、脆弱性の特定に用いられる動的手法に特化して解説します。

動的手法は、大きく2つのカテゴリに分けられます：コンクリート実行とシンボリック実行です。これらの手法は非常に「再現性」の高い入力を生成しますが、「意味的洞察」の点ではそれぞれ異なります。

# *A. Dynamic Concrete Execution*

動的コンクリート実行とは、プログラムを最小限のインストルメンテーションが施された環境で実行するという概念です。プログラムは通常通り動作し、通常操作する*ドメイン*のデータ（つまり、0と1）上で処理を行います。これらの解析は典型的に、単一の実行経路のレベルで推論します（つまり、「この特定の入力が与えられたとき、プログラムはどの経路を辿ったか」）。そのため、動的コンクリート実行には*テストケース*をユーザーが用意する必要があります。これは、大規模または未知のデータセット（私たちのケースのように）ではそのようなテストケースを容易に用意できないという問題となります。

*1) Fuzzing:* 脆弱性発見における動的コンクリート実行の最も関連する応用例がファジングです。ファジングとは、アプリケーションに異常な入力を与え、クラッシュを引き起こそうとする動的手法です。当初は、そのような入力はハードコーディングされたルールによって生成され、実行時の詳細な監視はほとんど行われていませんでした[38]。特定の入力によってアプリケーションがクラッシュした場合、その入力がバグを引き起こしたと見なされました。そうでない場合、入力はさらにランダムに変異されます。残念ながら、ファザーは*テストケース*の要件に悩まされます。変異させるために注意深く作成されたテストケースがなければ、ファザーはプログラムの最も表面的な機能しか試すことができません。

Coverage-based fuzzing. コードカバレッジベースのファジングの登場により、注意深く作成されたテストケースの必要性は部分的に緩和された。[39] コードカバレッジベースのファザーは、ターゲットアプリケーションで実行されるコードの量を最大化する入力を生成しようとする。その根拠は、より多くのコードが実行されれば、脆弱なコードが実行される可能性も高くなる、というものである。American Fuzzy Lop (AFL) [1] は、多くの新しい脆弱性の発見に貢献してきた最新のファザーであり、コードカバレッジの指標だけを唯一の指針として利用している。AFLが脆弱性発見に成果を上げたことで、近年ファジングへの関心が高まっている。

カバレッジベースのファジングは、ターゲットアプリケーションに対するセマンティックな洞察に欠けています。つまり、特定のコードがまだ実行されていないことを検出することはできますが、そのコードを実行させるために入力のどの部分を変異させればよいかを理解することはできません。

Taint-based fuzzing。ファジングを改善するもう一つのアプローチは、*taint-based* ファザ（汚染ベースファザー）の開発です [9], [62]。このようなファザーは、アプリケーションが入力をどのように処理するかを解析し、将来の実行で入力のどの部分を変更すべきかを理解します。これらのファザーの中には、taint tracking と静的手法（例えば data dependency recovery [30], [42]）を組み合わせるものもあります。また、プロトコル解析の手法を導入してファジングの網羅率を向上させているものもあります [22]。

テイントベースのファザーは、入力のどの部分を変異させればプログラム内の特定の経路へと実行を導けるかは理解できますが、*どのように*その入力を変異させるべきかについては依然として分かっていません。

*2) Dynamic Symbolic Execution:* シンボリック技法は静的解析と動的解析のギャップを埋め、ファジングが持つ限定的なセマンティックの理解という課題に対する解決策を提供します。Dynamic symbolic execution はシンボリック実行の一種で、プログラムをエミュレート環境で実行するという意味で動的な手法です。しかし、この実行は*シンボリック変数*という*抽象*的な領域で行われます。これらのシステムはアプリケーションをエミュレートする際、プログラムの実行を通じてレジスタやメモリの状態、そしてそれらの変数に対する*制約*を追跡します。条件分岐に到達するたびに、実行は分岐し、*両方*のパスをたどり、分岐が取られたパスには分岐条件を、その逆のパスには分岐条件の逆を制約として保存します [49]。

ファジングとは異なり、動的シンボリック実行はターゲットアプリケーションに対して非常に高い意味的な洞察を持っています。この手法では、実行中の経路のひとつが解析で注目している条件を満たした場合、蓄積されたパス制約を利用して、特定の望ましいプログラム状態を*どのようにして*引き起こすかを推論し、アプリケーションへの適切な入力を後から生成することができます。これにより、ソフトウェアのバグを特定するうえで非常に強力なツールとなっており、その結果、動的シンボリック実行は非常に活発な研究分野となっています。

古典的な動的シンボリック実行。動的シンボリック実行は、ソフトウェアの脆弱性を直接発見するために利用できる。もともとはソースコードのテストに適用されていたが [12]、[13]、Mayhem [16] や S2E [19] によってバイナリコードにも拡張された。これらのエンジンは、アプリケーションを解析する際、パス探索を行い、脆弱な状態（たとえば、命令ポインタが攻撃者の入力によって上書きされる場合など）が特定されるまで調査を続ける。

しかし、Section II-Aで議論されたトレードオフがここで問題となります。現在提案されているすべてのシンボリック実行手法は、*パス爆発*の問題により、スケーラビリティが非常に制限されています。つまり、各分岐で新しいパスが作られるため、プログラム内のパスの数は各パスの分岐命令数とともに指数関数的に増加します。*有望なパスを優先する* [11], [37] や、適切な場合にパスを*統合する* [5], [35], [47] ことによってパス爆発を乗り切ろうとする試みもなされてきました。しかし、一般的にこの課題は純粋な動的シンボリック実行解析エンジンではまだ克服されておらず（本論文の後半で示す通り）、そのようなシステムによって発見される大半のバグは*浅い*ものとなっています。

シンボリック支援ファジング。パス爆発問題への対策として提案されている方法の一つは、処理の多くをより高速な手法、つまりファジングにオフロードすることです。このアプローチは、ファジングの長所、すなわちその速度を活用し、主な弱点、すなわちアプリケーションに対する意味的な理解の欠如を補おうとするものです。そのため、研究者たちはファジングとシンボリック実行を組み合わせています。これらの*シンボリックガイド型ファザー*は、ファジングコンポーネントによって特定された入力を、動的シンボリック実行エンジンで処理し修正します。動的シンボリック実行は、解析対象プログラムへのより深い理解を用いて、入力を適切に変異させ、従来探索されていなかったコードをトリガーする追加のテストケースを生成し、ファジングコンポーネントが（コードカバレッジの点で）さらなる進展を遂げられるようにします。

制約が緩いシンボリック実行。動的シンボリック実行の実用性を高めるもう一つの方法は、アプリケーションの*一部*のみを実行することです。この手法は、Under-constrained Symbolic Execution [26], [46] として知られており、*潜在的な*バグを特定するのに有効ですが、2つの欠点があります。第一に、アプリケーションの部分的な実行に対して適切なコンテキストを保証することができず、その結果として多くの誤検知が発生します。第二に、静的な脆弱性発見手法と同様に、制約が緩いシンボリック実行では、スケーラビリティのために発見されたバグのリプレイ性を犠牲にしています。

#### V. BACKGROUND: EXPLOITATION

脆弱性発見の分析は、実際には *クラッシュを引き起こす入力* を発見します。これらのクラッシュ入力を選別する、つまりどのクラッシュが実際のセキュリティ問題に該当するかを理解する作業は、多くの手法の範囲外となっています。しかし、発見された脆弱性の再現や分析に関する研究も一部存在します。このセクションでは、特定されたクラッシュを再現し、そのクラッシュのセキュリティ上の影響を確認するためのエクスプロイトを自動生成し、さらに現代的な緩和技術が存在する環境でもエクスプロイトを堅牢にする手順について説明します。

#### *A. Crash Reproduction*

ほとんどの脆弱性発見解析は、実際の環境よりも現実的でない条件下でテスト対象アプリケーションを実行します。例えば、多くのファザーは実行時のランダム性を*固定*します。つまり、実行可能ファイルのPIDや現在時刻など、ランダム性のある情報をハードコーディングします。これは主に2つの理由から行われます。第一に、ほとんどの最新のファズィング手法では、同じ入力を2回アプリケーションに与えれば、両方とも同じ結果になるという暗黙の前提があります。第二に、動的シンボリック実行など他の手法におけるランダム性のモデリングは、十分に研究が進んでいない分野です。

非ランダム化のため、脆弱性発見技術によって報告されたクラッシュは、解析環境外では簡単に再現できない場合があります。たとえば、アプリケーションがランダムなトークンを生成し、そのトークンをユーザーが入力しないと危険なコード領域に入れずクラッシュしないような場合を考えてみてください。非ランダム化された解析環境では、生成されるトークンは毎回同じ値になり、解析で特定されたクラッシュを引き起こす入力は常に同じ経路をたどってクラッシュが発生します。しかし、解析環境*外部*ではトークンが毎回異なるため、以前はクラッシュを引き起こしていた入力が、今度は*クラッシュしない*経路をたどる可能性があります。

自明にリプレイできないクラッシュを引き起こす入力は、一般的に2つのカテゴリに分類されます。

- 欠損データ。脆弱性発見手法は、アプリケーションから最初に応答値を受け取らなくても、正しい値を「推測」してしまうことがあります。今回の例で使われているトークンは、デランダマイズされた環境では常に一定の値となっており、ファザーのような解析エンジンが、そのトークンを事前にプログラムから取得しなくても偶然推測してしまう場合があります。その結果生じたクラッシュ入力を解析環境の外で再現しようとすると、トークン値が一致せず、クラッシュが再現できなくなってしまいます。
- 関係性の欠如。ファジングのようなセマンティックな洞察が乏しい手法では、プログラムから取得されたデータと、その後プログラムに提供されるデータとの*関係性*を復元することができません。例えば、クラッシュを引き起こす入力がアプリケーションによってユーザーにトークンを返す原因となり、後でそのトークンを使用してクラッシュを引き起こすことができたとしても、ファザーの出力には、アプリケーションがユーザーに提供するトークン値と、ユーザーがアプリケーションに提供しなければならないトークン値との関係性が欠けているのです。

データが欠落している場合、入力は解析環境の外では単純に再現できず、新たなクラッシュを引き起こす入力が発見されることもあります。データ漏洩の特定を専門とする解析手法も存在します[42]が、angrにはまだそのような解析を実装していません。

後者の場合、ランダム性を排除したクラッシュ入力は、アプリケーションとやり取りする方法を定義する*入力仕様*に変換する必要がある。これは、アプリケーションから受信したデータと、その後アプリケーションに提供されるデータとの関係という観点で記述される。そのような方法の一つにReplayer [43]があり、これは実際の環境下でプログラムの経路を再現する方法を理解するため、プログラム経路の前提条件を計算する。

#### *B. Exploit Generation*

上記のいずれかの手法を利用する生産的な脆弱性発掘エンジンを用いることで、テスト対象のアプリケーションに対して多くのクラッシュが発生する可能性があります。しかし、これらすべてのクラッシュが悪用可能であるとは限りません。悪用不可能な入力例としては、NULLポインタ参照があります。現代のオペレーティングシステムではアドレス0へのメモリマッピングが許可されていないため、以前は悪用可能だったこのような状況は悪用不可能なクラッシュに変わりました。クラッシュが悪用可能かどうかを理解することは、バグの*トリアージ*（つまり、どのバグを優先的に調査し修正するかの判断）に役立ちます。

クラッシュが悪用可能かどうかをテストする最も明白な方法は、実際にそれを悪用しようとすることです。この目的のために、クラッシュを引き起こす入力を取得し、それを自動的にアプリケーションのエクスプロイトへと変換しようとするいくつかのシステムが提案されています [4], [31], [51]。

## *C. Exploit Hardening*

近年では、実行不可スタック領域やAddress Space Layout Randomization (ASLR) のようなバイナリハードニング技術によって、従来のエクスプロイト、特に初代の自動エクスプロイトエンジンによって生成されたものの効果が大幅に減少しています。そのため、たとえ悪用可能な脆弱性が存在していても、最近の防御機構によって対策されてしまうことがあります。

現在の自動エクスプロイト技術は、最新の緩和技術が広く採用される前に設計されたものであり、現代のソフトウェア保護によって、それらが生成するエクスプロイトは機能しなくなっています。これを回避するために、既存の技術を使って生成されたエクスプロイトを、こうした防御策に対抗できるよう自動的に*強化*する手法が考案されています。これらの手法は、従来のシェルコードベースのエクスプロイトを、Return-Oriented Programming [52] を利用する同等のエクスプロイトに変換することで機能します。そのため、自動的にReturn-Oriented Programを構築する手法が必要となり、いくつかの手法が開発されています [18], [48]。

## VI. ANALYSIS ENGINE

私たちがセクションIII、IV、Vで述べた分析は、過去数年にわたりさまざまな時期に提案され、異なる技術で実装され、さまざまな方法論で異なるデータセット上で評価されてきました。これは問題であり、異なるアプローチの相対的な効果や、それぞれがどのような種類のアプリケーションに適用可能かを理解するのが難しくなる原因となっています。

この問題を解決するために、私たちは柔軟で高機能な次世代バイナリ解析システムであるangrを開発し、前のセクションで紹介したいくつかの解析を実装しました。このセクションでは、解析システムについて、その設計目標、そしてこの設計が現実的なバイナリ解析に与えた影響について説明します。

#### *A. Design Goals*

angrの設計目標は次のとおりです。

- クロスアーキテクチャ対応。組み込みデバイスの普及により、ARMやMIPSプロセッサを搭載した機器が増えており、現代のソフトウェアは様々なハードウェアアーキテクチャ向けに作られています。これは、過去10年の状況とは異なり、当時はx86のサポートだけでほとんどの解析エンジンに十分でしたが、現代のバイナリアナリシスエンジンはクロスアーキテクチャな解析ができなければなりません。さらに、32ビットプロセッサはもはや標準ではなく、現代の解析エンジンは64ビットバイナリの解析をサポートする必要があります。
- クロスプラットフォーム対応。同様にクロスアーキテクチャ対応と同じく、最新の解析システムは異なるオペレーティングシステム上のソフトウェアを解析できなければなりません。これは、各オペレーティングシステムに固有の概念を扱うことを意味します。

システムは抽象化され、さまざまな実行可能フォーマットの*ロード*をサポートする必要があります。

- 異なる解析パラダイムへの対応。有用な解析エンジンは、前述のセクションで説明した幅広い解析に対応できなければなりません。そのためには、エンジン自体が抽象化されており、さまざまなメモリモデルやデータドメインを提供する必要があります。
- Usability. angrの目的は、セキュリティコミュニティにとって、再現・改良・新規作成が可能なバイナリ解析技術のための有用なツールを提供することです。そのため、angrの習得のしやすさと使いやすさを重視しました。angrはほぼ完全にPythonで実装されており、IPythonインタラクティブシェル[44]からも簡単に使える、簡潔でシンプルなAPIを備えています。Pythonは他の言語に比べて実行時のパフォーマンスが劣ることもありますが、ほとんどのバイナリ解析技法は*アルゴリズム*自体が遅いことが問題となるため、言語によるパフォーマンスの影響はほとんど感じられません。言語のオーバーヘッドが重要な場合には、angrはPythonのJITエンジンであるPyPy上で実行することで大幅な高速化が可能です。

私たちの目標は、angrを使って、典型的なバイナリアナリシス技術を、およそ1週間で私たちのプラットフォーム上に再現できるようにすることでした。実際には、Veritesting [5] を8日間で再現でき、ガイド付きシンボリック実行を1か月で、AEG [4] を週末で、Q [48] を約3週間で、そしてunderconstrained symbolic execution [46] を2日間で再現することができました。ダイナミックシンボリック実行とバリューセット解析については、システム自体を2年間かけて構築しながら実装したため、実装にかかった労力を正確に見積もるのは難しいです。

これらの設計目標を達成するために、私たちは分析エンジンを慎重に構築する必要がありました。その際、さまざまな分析のためのモジュール化されたビルディングブロックを作成し、それらの間に厳密な分離を保つことで、angrの上位部分（たとえば状態表現）が下位部分（たとえばデータモデル）について仮定する内容を最小限に抑えるよう注意しました。これにより、分析をその場で組み合わせたり切り替えたりすることが容易になります。また、他の研究者がangrの個々のモジュールを再利用しやすくなることも期待しています。次のいくつかのセクションでは、angrの各サブモジュールの技術的設計について説明します。

#### *B. Submodule: Intermediate Representation*

複数のアーキテクチャをサポートするために、アーキテクチャ固有のネイティブバイナリコードを中間表現（IR）に変換し、その上で解析を実装しています。独自に「IRリフター」を開発するのは非常に時間のかかる作業であるため、それを行う代わりに、ValgrindプロジェクトのIRリフターであるlibVEXを活用しました。libVEXは、プログラム解析のために特別に設計されたVEXというIRを生成します。VEX IRをPythonから扱うために、もともとFirmalice [53] のために作成したPyVEXを使用しました。VEXを活用することで、ARM、MIPS、PPC、x86（後者の64ビット版はamd64）プロセッサの32ビット及び64ビットバージョンに対する解析サポートを提供できます。Valgrindのコントリビューターによって継続的に改良が行われており、例えば現在はSPARCアーキテクチャへの対応作業が進行中です。

後ほど説明するように、angrが常にVEXを中間表現として使用しなければならないという根本的な制約はありません。実装としては、別の中間表現をサポートすることも、簡単なエンジニアリング作業で済みます。

# *C. Submodule: Binary Loading*

アプリケーションバイナリを解析システムにロードする作業は、CLEというモジュールによって行われます。CLEは「CLE Loads Everything」という再帰的頭字語です。CLEはさまざまなバイナリフォーマットを抽象化し、指定されたバイナリおよびそれが依存するすべてのライブラリのロード、動的シンボルの解決、リロケーションの実行、プログラム状態の適切な初期化などを処理します。CLEを通じて、angrはほとんどのPOSIX準拠システム（LinuxやFreeBSDなど）、Windows、そしてDARPA Cyber Grand Challenge用に作成されたDECREE OSのバイナリをサポートしています。

CLE は、バイナリオブジェクト（アプリケーションバイナリ、POSIX .so、Windows .dll など）、それらのオブジェクト内のセグメントやセクション、さらにそのセクション内の位置を表すシンボルを表現する複数の基底クラスを提供することで、バイナリローダーのための拡張可能なインターフェースを実現しています。CLE はファイルフォーマットのパースライブラリ（Linux バイナリ用には elftools、Windows バイナリ用には pefile）を用いてオブジェクト自体を解析し、その後、必要な再配置を行い、「*ロードされた*」アプリケーションのメモリイメージを公開します。

# *D. Submodule: Program State Representation/Modification*

SimuVEXモジュールは、*プログラム状態*（つまり、レジスタやメモリの値、開いているファイル、*など*のスナップショット）を表現する役割を担っています。SimuVEXではこの状態をSimStateと呼び、*ステートプラグイン*の集合として実装されています。これらのプラグインは、ステートが生成される際にユーザーや解析によって指定される*ステートオプション*によって制御されます。現在、次のステートプラグインが存在します。

- レジスタ。SimuVEXは、プログラムの任意の時点におけるレジスタの値を、対応するプログラムステートのステートプラグインとして追跡します。
- シンボリックメモリ。シンボリック実行を可能にするために、SimuVEXは状態プラグインとしてシンボリックメモリモデルを提供しています。これは、Mayhem [16] で提案されたインデックス付きメモリモデルを実装しています。
- 抽象メモリ。抽象メモリ状態プラグインは、静的解析によってメモリをモデル化するために使用されます。連続したインデックス付きメモリモデルを実装するシンボリックメモリとは異なり、抽象メモリはほとんどの静的解析で使用される *リージョン* ベースのメモリモデルを提供します。
- POSIX. POSIX準拠の環境用バイナリの解析時、SimuVEXはこのステートプラグイン内で*システム状態*を追跡します。例えば、シンボリック状態で開かれているファイルなどがこれに含まれます。各ファイルはメモリ領域およびシンボリックな位置インデックスとして表現されます。
- ログ。SimuVEXは、このプラグイン内で状態に対して行われたすべての操作（例えばメモリ書き込みやファイル読み取りなど）のログを記録します。
- 検査。SimuVEXは強力なデバッグインターフェースを提供しており、汚染や正確な式の内容など、複雑な条件でブレークポイントを設定することができます。

シンボリック条件。このインターフェースは、SimuVEXの動作を*変更*するためにも使用できます。たとえば、メモリリードをインストゥルメントして、メモリマップドI/Oデバイスをエミュレートすることができます。

- ソルバー。ソルバーは、さまざまなデータドメインへのインターフェースを公開するプラグインであり、データモデルプロバイダー（下記で説明するClaripy）を介して動作します。たとえば、このプラグインがシンボリックモードに設定されている場合、レジスタ、メモリ、ファイル内のデータをシンボリックに解釈し、アプリケーションの解析中にパス制約を追跡します。
- アーキテクチャ。アーキテクチャプラグインは、分析に役立つアーキテクチャ固有の情報（例えば、スタックポインタの名前やアーキテクチャのワードサイズなど）を提供します。このプラグイン内の情報は、angrの一部として配布されているarchinfoモジュールから取得されています。

これらのステートプラグインは、さまざまな分析をサポートするために、さまざまな方法で組み合わせることができる構成要素を提供します。

さらに、SimuVEXは解析の基本単位を実装しています。これは、アプリケーションコードのブロックがプログラム状態に与える意味的な変化を表現するものです（SimuVEXの用語では、このようなコードのブロックをSimRunと呼びます）。つまり、SimuVEXはVEXで表現されたコードのブロックを通じて「入力」状態を処理し、「出力」状態（または、条件分岐ジャンプのように複数の出力状態が発生する場合はその集合）を生成する機能を提供します。この部分もSimuVEXはモジュール化されています。基本ブロックのVEX変換に加えて、現在SimuVEXはユーザーが手書きのPython関数をSimRunとして提供することを可能にしており、Pythonコードによるブロックのインストゥルメントに強力な手段をもたらしています。実際、環境モデルの実装もこの方法で行われています。システムコールはプログラム状態を変更するPython関数として実装されています。

#### *E. Submodule: Data Model*

SimStateのレジスタやメモリに格納されている*values*は、Claripyという別のモジュールによって提供される抽象化によって表現されています。

Claripyは、すべての値を*式*の内部表現に抽象化し、その値が使用されるすべての操作を追跡します。つまり、式xと式5を加算すると、その結果は式x + 5となり、xと5を引数として保持し続けます。これらの式は「式木」として表現され、値がリーフノード、演算が非リーフノードとなります。

任意の時点で、式は Claripy の *backend* によって提供されるデータドメインに変換することができます。具体的には、Claripy は具体的ドメイン（整数や浮動小数点数）、記号的ドメイン（Z3 SMT solver [25] によって提供される記号的整数や記号的浮動小数点数）、および Value Set Analysis のための値集合抽象ドメイン [6] をサポートする backend を提供しています。Claripy は他の backend への拡張も容易です。特に、他の SMT solver の実装は興味深いものであり、異なる solver が異なる種類の制約の解決において優れていることが示されています [8]。

ユーザーが操作する処理、たとえばバックエンドが提供する構成要素（Z3バックエンドによって提供される記号式 x+1 など）をPythonのプリミティブ（たとえば制約解決の結果として得られるx+1の可能な整数解など）へ解釈する処理は、*フロントエンド*によって提供されます。フロントエンドは、バックエンドにさまざまな複雑さを持つ追加機能を付与します。Claripyは現在、いくつかのフロントエンドを提供しています:

- FullFrontend。 このフロントエンドは、ユーザーに対してシンボリックな解法を提供し、制約を追跡し、Z3 バックエンドを用いてそれらを解決し、結果をキャッシュします。
- CompositeFrontend。KLEEやMayhemが提案しているように、制約を独立したセットに分割することで、ソルバーへの負荷を軽減できます。CompositeFrontendは、この機能への透過的なインターフェースを提供します。
- LightFrontend。このフロントエンドは制約の追跡をサポートしておらず、VSAバックエンドを使ってVSAドメイン内の式を単純に解釈します。
- ReplacementFrontend。ReplacementFrontendはLightFrontendを拡張し、VSA値に対する*制約*のサポートを追加します。制約（例えば x+1 < 10）が導入されると、ReplacementFrontendはそれを解析し、関与している変数の範囲（例えば 0 <= x <= 8）を特定します。その後、ReplacementFrontendに変数xの可能な値が問い合わせられた場合、以前に決定した範囲とその変数の値を交差させ、VSAだけでは得られないより正確な結果を提供します。
- HybridFrontend。HybridFrontendは、FullFrontendとReplacementFrontendを組み合わせることで、記号制約解決に対する高速な近似サポートを提供します。Mayhem [16] はそのような機能に言及していましたが、私たちの知る限り、angrはこの機能を研究コミュニティに公開して提供した初めてのツールです。

このモジュール式の設計により、Claripyはさまざまなデータドメインが提供する機能を強力に組み合わせ、それをangrの他の部分に提供することができます。

#### *F. Submodule: Full-Program Analysis*

angrのアナリスト向け部分は、動的シンボリック実行やコントロールフローグラフの復元といった完全な解析機能を提供します。これらの解析の「エントリーポイント」となるのがProjectであり、これはバイナリとそれに付随するライブラリを表現します。このオブジェクトから他のサブモジュールのすべての機能（たとえば、状態の作成、共有オブジェクトの調査、基本ブロックの中間表現の取得、バイナリコードへのPython関数のフックなど）にアクセスできます。さらに、全プログラム解析のための主要なインターフェースとして、Path GroupsとAnalysesの2つがあります。

Path Groups。PathGroupは動的記号実行へのインターフェースであり、アプリケーションを実行する際に経路が分岐・終了していく様子を追跡します。このインターフェースの作成は、記号実行中の経路管理に対するフラストレーションから生まれました。angrの初期開発段階では、記号実行を用いた各種解析ごとに、その都度アドホックな経路管理を実装していました。分岐・統合される経路の階層を追跡したり、探索で優先すべき興味深い経路を分析したり、見込みのない経路を識別して終了させる機能を、何度も繰り返し実装していたのです。これらの経路グループに対して行われる共通処理を統一し、PathGroupインターフェースを作成しました。

解析。angrは、Analysisクラスを用いてあらゆるフルプログラム解析の抽象化を提供します。このクラスは、制御フローグラフの復元のような静的解析や、第IX節で紹介されているような複雑な動的解析のライフサイクルを管理します。

angrがバイナリに関する何らかの*事実*（例えば「アドレスXの基本ブロックがアドレスYの基本ブロックへジャンプすることができる」など）を特定した場合、それを対応するProjectの*ナレッジベース*に保存します。この共有ナレッジベースにより、解析は協力してアプリケーションに関する情報を発見することが可能となります。

## *G. Open-Source Release*

私たちは、新しいバイナリ解析手法を実装できるプラットフォームを開発することを目標に、angrの開発を始めました。現実的なバイナリの解析に伴う予期せぬ課題に直面する中で、このような解析エンジンがセキュリティ分野のコミュニティにとって非常に有用であることに気付きました。私たちはangrをオープンソース化し、バイナリ解析の今後の基盤となり、研究者が同じ課題に何度も取り組む負担から解放されることを期待しています。angrは6万5千行強のコードで実装されており、IPythonシェルから直接利用できるほか、Pythonモジュールとしても使用でき、標準のPythonパッケージマネージャであるpipを使って簡単にインストールできます。

angrのオープンソースリリースには、分析エンジンモジュール（セクションVI-AからVI-Fで説明されています）が含まれており、その上にセクションXVで論じたアプリケーションを実装しています。後者のうち、私たちはコントロールフローグラフのリカバリ、静的解析フレームワーク、動的シンボリック実行エンジン、およびアンダーコンストレインドシンボリック実行の実装をオープンソース化しています。他のアプリケーションについても将来的にリリースする予定ですが、現時点ではプロトタイプレベルのコードとDARPA Cyber Grand Challengeに積極的に適用されている状態が混在しています。

angrはコミュニティから非常に大きな熱意を持って受け入れられています。オープンソースとして公開してから最初の3ヶ月間で、システムを構成するさまざまなモジュール全体でGitHub上に約500件の「スター」（ソフトウェアを高く評価している人の指標）を集めました。同じ期間中に、angrはpip経由で合計約6,000回インストールされ、Gitリポジトリの「クローン」は週平均20回行われていました。angrはすでに他の教育機関のある授業プロジェクトでも使用されており、学生にバイナリ解析を紹介するために活用されています。さらに、他にも複数の教育機関が研究用プロトタイプの構築基盤として利用していることや、いくつかの企業が商用バイナリ解析システムへの利用可能性を評価していることも把握しています。

#### VII. IMPLEMENTATION: CFG RECOVERY

angrがCFGを生成する際のプロセスについて説明します。また、最終的な結果の網羅性と健全性を向上させるために開発された特定の技術についても取り上げます。

特定のプログラムが与えられた場合、angrはプログラムのエントリポイントから開始し、いくつかの必要な最適化を行いながら反復的にCFGリカバリを実施します。angrは、*強制実行*、*後方スライシング*、および*シンボリック実行*を組み合わせて活用し、可能な限り各間接ジャンプの全てのジャンプ先を復元します。さらに、ターゲットアプリケーションに関する大量のデータを生成・保存し、後のデータ依存性追跡などの他の解析で活用できるようにしています。

このアルゴリズムには主に三つの欠点があります。動作が遅いこと、「デッドコード」を自動的に処理できないこと、そして未復元の間接ジャンプを通じてのみ到達可能なコードを見逃す可能性があることです。この問題に対処するために、実行せずにバイナリのクイックディスアセンブリを行い、その後ヒューリスティック手法で関数、関数内の制御フロー、関数間の直接的な制御フロー遷移を特定する二次的なアルゴリズムを作成しました。しかしながら、この二次アルゴリズムは精度が大きく劣ります。関数間の到達可能性に関する情報を持たず、コンテキストにも対応できず、複雑な間接ジャンプの復元もできません。

このセクションの残りでは、私たちの高度なリカバリアルゴリズムである CFGAccurate について説明します。さらに、高速アルゴリズムである CFGFast についてはセクション VII-F で議論します。

## *A. Assumptions*

angrのCFGAccurateは、アルゴリズムの実行時間を最適化するためにバイナリに関していくつかの仮定を行います。

- 1) プログラム内のすべてのコードは、異なる関数に分割して配置することができます。
- 2) すべての関数は、明示的な呼び出し命令（またはそれに相当するもの）によって呼び出されるか、あるいは制御フローにおいてテールジャンプ（再帰関数のスタック使用量を減らすためによく使われる最適化で、関数の最後での呼び出しを*ジャンプ*に変更し、新しく呼び出された関数が呼び出し元のリターンアドレスをそのまま再利用するもの）の直前に配置されます。
- 3) 各関数のスタッククリーンアップの挙動は、どこから呼び出されたかにかかわらず予測可能です。これにより、CFGAccurate は呼び出し元の関数を解析する際、すでに解析済みの関数を安全にスキップしつつ、スタックの整合性を保つことができます。

これらの前提条件は、angrが解析することを想定しているバイナリの種類に制約を与えます。前提条件1、2、3は、解析対象のバイナリが難読化されておらず、「通常通り」動作することを要求しています。難読化されたバイナリや異常なバイナリを解析する際には、これらの前提条件を外すこと*も可能*ですが、その場合CFGリカバリの実行時間が長くなることになります。

私たちのCFGリカバリコードは、関連する文献[21]、[34]、[50]、[58]、[59]で提案された手法に基づいて構築されています。しかし、これらの手法は、実際のバイナリには厳しすぎる、あるいは非現実的な仮定を置いています。特に、私たちのCFGリカバリが基づく先行研究とは異なり、私たちは以下のいずれの仮定も*していません*。

1) すべての関数は、その呼び出し元の次の命令に戻ります [59]。

- 2) 間接分岐のジャンプ先は常に制御フローパスによって決定され、プログラムの状態やコンテキストによって決まるわけではありません [59]。たとえば、既存の文献では、間接ジャンプはすべて*計算されたもの*であり、以前のコンテキストから関数ポインタとして渡されることはないと仮定しているものもあります。
- 3) 間接ジャンプのジャンプ先となる式は、一般的なイディオムのセットに一致しなければなりません [21], [58]。従来の研究とは異なり、ポインタに適用できる操作の種類については一切仮定しません。
- 4) 関数に入る前のスタックポインタと、関数から戻った後のスタックポインタは同じである。
- 5) 2つの関数が重複することはありません（言い換えれば、基本ブロックを共有できません[34]。) CFGAccurateは、コードを共有する関数にも対応しています。
- 6) シンボルテーブルや再配置情報などの追加情報が利用可能である [50]。

バイナリから制御フローグラフを復元するための実際のアルゴリズムについては、次のいくつかのセクションで説明します。

# *B. Iterative CFG Generation*

残念ながら、単一の手法だけでは、CFGAccurateの「完全かつ健全なCFGの復元」という目標を達成できません。そのため、CFGAccurateは複数の手法を組み合わせてCFGを構築し、速度と網羅性の両立を図っています。具体的には、forced execution、lightweight backward slicing、symbolic execution、value set analysisの4つの手法が使われます。これらの手法により反復的に復元されるCFGであるCは、アプリケーションのエントリーポイントにある基本ブロックを初期値として設定されます。

CFGの復元の過程で、CFGAccurateはジャンプ先がまだ解決されていない間接ジャンプのリストL<sup>j</sup>を管理します。解析がこのようなジャンプを特定すると、それがL<sup>j</sup>に追加されます。各イテレーティブな手法が終了するたびに、CFGAccurateはリスト内の次の手法を実行します。この次の手法はL<sup>j</sup>内のジャンプを解決することもあれば、新たな未解決ジャンプをL<sup>j</sup>に追加したり、CFG Cに基本ブロックやエッジを新たに追加することもあります。すべての手法を実行してもL<sup>j</sup>やCに変化がない場合、つまり利用可能な解析によってこれ以上間接ジャンプを解決できないことを意味するため、CFGAccurateは処理を終了します。

# *C. Forced Execution*

angrのCFGAccurateは、CFG回復の最初の段階でDynamic Forced Executionというコンセプトを活用します [59]。Forced Executionは、すべての分岐点で条件分岐の両方向が必ず実行されることを保証します。

CFGAccurateは、基本ブロックの作業リストBwと、解析済みブロックのリストBaを保持します。解析を開始するとき、BwにはCに存在しBaに含まれていないすべての基本ブロックを初期化します。作業リストから基本ブロックを解析するたびに、その基本ブロックと、そこからの*直接*ジャンプはCに追加されます。しかし、間接ジャンプはこの方法で処理できません。強制実行下では、間接ジャンプのターゲットが実際のプログラム実行時とは異なる場合があり、強制実行では想定外の順序でコードが実行されることがあるからです。そのため、各間接ジャンプは後で解析するためにリストL<sup>j</sup>に保存されます。

間接ジャンプを解決できないため、この解析は高速なCFGリカバリ解析として機能し、検出された基本ブロックや未解決の間接ジャンプを他の解析に迅速に提供します。

# *D. Symbolic Execution*

動的強制実行の主な問題は間接ジャンプの存在です。なぜなら、間接ジャンプのターゲットが正しく解決されているかどうかを確認する方法がないからです。一方で、間接ジャンプが全く解決不能な場合もあります（つまり、強制実行の結果、ジャンプ先が初期化されていないメモリから読み取られる状態になった場合です）。この場合、回収されたCFG内で制御フロー遷移が断たれてしまいます。また別のケースとして、間接ジャンプが部分的にのみ解決可能な場合もあります（つまり、解析によってすべてのジャンプターゲットの一部しか取得できない場合です）。

各ジャンプ J ∈ L<sup>j</sup> について、CFGAccurate は CFG を逆方向にたどり、最初の *マージポイント*（つまり、間接ジャンプに向かう途中で複数の経路が合流する点）を見つけるまで、もしくはブロック数の閾値に達するまで（経験的に、妥当な閾値は8であることが分かっています）探索を行います。そこから、間接ジャンプまで前方のシンボリック実行を行い、制約ソルバーを使って間接ジャンプのターゲットとなる可能性のある値を取得します。

CFGAccurateは、ジャンプの可能なターゲットの集合がある閾値より小さい場合、ジャンプの解決に成功したとみなします。この閾値には256という値を使用していますが、実際にはジャンプが正常に解決されない場合、この値は*制約されていない*ことがわかっています（つまり、可能なターゲットの集合はアドレスのビット数によってのみ制限されます）。

ジャンプが正常に解決されると、J は L<sup>j</sup> から削除され、ジャンプターゲットの各可能な値ごとに、エッジとノードが CFG に追加されます。

# *E. Backward Slicing*

angrの強制実行およびシンボリック実行解析は、多くの未解決ジャンプを*コンテキスト*の欠如により解決できません。これらの解析はコンテキスト非依存で実行されます。関数がポインタを引数として受け取り、そのポインタが間接ジャンプのターゲットとして使われている場合、解析ではこれを解決することができません。

より高い完全性を実現するために、私たちのCFG生成ではコンテキスト感応型のコンポーネントが必要です。これを実現するために、*backward slicing*（後方スライシング）を利用します。CFGAccurateは未解決のジャンプを起点として後方スライスを計算します。このスライスは、直前の*call context*の開始地点まで拡張されます。つまり、解析中の間接ジャンプが関数F<sup>a</sup>内にあり、それがF<sup>b</sup>およびF<sup>c</sup>の両方から呼び出されている場合、スライスはF<sup>a</sup>内のジャンプから遡って広がり、F<sup>b</sup>の開始基本ブロックとF<sup>c</sup>の開始基本ブロックという2つの開始ノードを含むことになります。

CFGAccurateは、次にこのスライスをangrのシンボリック実行エンジンを用いて実行し、制約エンジンを使ってシンボリックジャンプの可能なターゲットを特定します。このとき、ジャンプターゲットの解集合のサイズが256という同じ閾値が適用されます。ジャンプターゲットの解決に成功した場合、そのジャンプはL<sup>j</sup>から削除され、制御フロー遷移を表すエッジとターゲットの基本ブロックが回収されたCFGに追加されます。

## *F. CFGFast*

fast CFG生成アルゴリズムの目的は、バイナリ内の関数の位置と内容を少なくとも特定できる、高いコードカバレッジを持つグラフを生成することです。このグラフには多くの*制御フロー*が欠けているため、完全なものではありません。しかし、そのようなグラフでも、バイナリの手動および自動解析の両方に役立つ場合があります。

CFGFastは以下の手順を実行します。

- 関数の識別。ハードコーディングされた関数プロローグのシグネチャ（ByteWeight [7] のような手法で生成可能）を用いて、アプリケーション内部の関数を識別します。アプリケーションが *シンボル* を含み、関数の位置が特定できる場合には、それらもグラフに関数開始位置として追加されます。さらに、プログラムのエントリーポイントを表す基本ブロックもグラフに追加されます。
- 再帰的逆アセンブル。再帰的逆アセンブルは、特定された関数内の直接ジャンプを復元するために用いられます。
- 間接ジャンプの解決。軽量なエイリアス解析やデータフロートラッキングに加え、あらかじめ定義された戦略を組み合わせて、関数内での制御フロー転送を解決します。現在、CFGFast にはジャンプテーブルの特定や間接呼び出しターゲットの解決に関する戦略が含まれています。

目標は、関数同士の到達可能性を理解することにはこだわらず、高いカバレッジを持つCFGを素早く再構築することです。

## *G. Using the CFG Recovery*

angrは、CFGリカバリアルゴリズムをCFGFastとCFGAccurateという2つの解析として公開しています。これらの解析は、CFGデータをangrのナレッジベースに出力します（セクションVI-Fで説明されています）。このデータは、その後の手動解析や後の自動解析で利用することができます。

## VIII. IMPLEMENTATION: VALUE SET ANALYSIS

CFGが生成されると、より高度な解析を実行することができます。その中の一つがValue-Set Analysis [6]です。Value-Set Analysis（VSA）は、バイナリプログラムに対して数値解析とポインタ解析を組み合わせた静的解析手法です。これは、Value-Set Abstract domainと呼ばれる抽象領域を用いて、プログラム中の各ポイントにおいてレジスタや抽象的なメモリ位置が取り得る値を近似します。

VSAは、関数内のすべてのプログラムポイントにおいて*不動点*に到達するまでプログラムを解析します。この不動点は、関数内の任意の時点であらゆるレジスタや抽象的なメモリ位置が持ち得る値の、厳密な過大近似を表しています。たとえば、計算されたアドレスAへのメモリ書き込みについて考えると、計算された不動点におけるAの値を参照することで、書き込みが行われる可能性のあるすべてのターゲットの完全なリストが得られます。

Balakrishnan ら [6] によって提案された元々の VSA の設計は、実際のバイナリ解析において十分な性能を発揮しませんでした。そのため、こうしたバイナリに対して VSA を有効に機能させるためには、解析の精度を高めるためのいくつかの改良を行う必要がありました。

- ストライド区間の離散集合を作成します。VSAの基本データ型であるストライド区間は、本質的には数値集合の近似表現です。これは、通常の具体的な値の集合を近似するのに非常に適しています。しかし、これらの値がプログラム内でジャンプターゲットとして使用される場合、ストライド区間の過剰近似の性質により、本来ジャンプターゲットであるべきでないアドレスへの制御フロー遷移が発生し、復元されたCFGにおいて正確性が損なわれてしまいます。この問題を効果的に解決するため、私たちは「ストライド区間集合」と呼ばれる新しいデータ型を開発しました。これは、いくつかのストライド区間をまとめて結合することなく集合として表現するものです。ストライド区間集合は、含まれる要素数がKを超えるときのみ、1つのストライド区間にまとめて結合されます。Kは調整可能な閾値です。Section II-Aで述べた私たちのモデルでは、この閾値が意味的洞察とスケーラビリティの間のトレードオフを制御しています。Kの値を大きくすると高精度を維持できますが、その分解析の複雑さが増すというコストが発生します。
- パス述語に代数ソルバーを適用する。分岐条件を追跡することで、条件付きの分岐先への遷移やマージ処理の際に、状態内の変数に制約を課すことができ、より精密な解析結果を得ることができます。条件を追跡する手法として、Affine-Relation Analysisが提案されています [40]。しかし、これは実装が複雑であり（制約式で扱える算術演算がごく限られる場合が多い）、実際には計算コストも高いという問題があります。私たちの解決策は、ストライド区間領域上で動作する軽量な代数ソルバーを実装することであり、これはいくつかのアフィン関係を扱うことができる剰余算術に基づいています。新しいパス述語が現れたとき（すなわち、条件分岐に従うとき）、それを簡略化・解決し、パス述語に関与する変数の数値範囲を得ることを試みます。そして新たに生成された数値範囲と、各対応する変数のもともとの値との間で共通部分を求めます。これによって、分岐条件が新たに現れるたびに値集合解析の結果を継続的に洗練させることができ、最終的な不動点の精度を高めることができます。
- 符号付き・符号なしに依存しないドメインの採用。元々提案された通り、VSAは符号付きストライド区間ドメイン上で動作しますが、これはすべての値が符号付きであることを前提としています。つまり、nビットのストライド区間で下限をl、上限をhとすると、常にl ∈ [−2<sup>n</sup>−<sup>1</sup>, 2<sup>n</sup>−<sup>1</sup> − 1] ∧ h ∈ [−2<sup>n</sup>−<sup>1</sup>, 2<sup>n</sup>−<sup>1</sup> − 1] ∧ l ≤ h となります。しかしこの方法では、符号なし算術演算の結果が大きく過大評価されてしまいます。実際、ジャンプアドレスは符号なしであるため、その計算は一般的に符号なしの値（例えば符号なし比較の場合）に依存します。この問題を解決するために、分析には符号付き・符号なしを区別しないドメインを採用します。*Wrapped Interval Analysis* [41] はこのような方法の一例です。

LLVMコードを解析するための区間ドメインであり、符号付き数値と符号なし数値の両方を同時に扱います。私たちは、この理論をVSAドメインに適用し、符号性に依存しないストライド区間ドメインを構築しました。

私たちは、メモリ破損の検出のためにVSAを三つの段階で使用します。まず、VSAの実行中にプログラム内のすべての読み書きアクセスパターンを収集します。これらのアクセスパターンに基づき、スタック領域とヒープ領域の両方に存在する変数のリカバリーを行います。私たちの実装はTIE [36] における変数リカバリーと似ています。次に、スタック領域とヒープ領域のすべてをスキャンし、異常なバッファ、すなわち a) 重複するバッファと、b) 範囲外バッファを検出します。そして、すべての異常なバッファを単純に潜在的なメモリ破損としてレポートします。

#### *A. Using VSA*

angrが提供するフルプログラムVSA解析への主なインターフェースは、*Value Flow Graph*です。VFGは、各プログラム位置でのVSAのフィックスポイントを表す*program state*を含む強化されたCFGです。VFG解析に渡されるパラメータによって、これは単一の関数、関数呼び出しのツリー、もしくはプログラム全体を含むことができます。

VFGに含まれるプログラム状態は、SimuVEXによって提供される抽象的なレイアウト（具体的にはSimAbstractMemoryメモリモデル）でメモリを表現しています。メモリ内の値は、Claripyによって提供される値セットで表現されます。私たちはこれらのプログラム状態に含まれるデータに対して、メモリアクセスが取り得る値の範囲を解析することでバッファの重複解析を実施しました。

#### IX. IMPLEMENTATION: DYNAMIC SYMBOLIC EXECUTION

我々の解析プラットフォームの動的記号実行モジュールは、主にMayhem [16]で記述されている手法に基づいています。我々の実装は、同じメモリモデルおよびパスの優先順位付け技術に従っています。このモジュールはangrの主要な機能の一つであり、Veritestingや低制約記号実行などの他の解析は、これを基礎として利用しています。

私たちは、Claripyのインターフェースを通じてZ3を利用し、SimuVEXが提供する象徴的メモリモデル（具体的にはSimSymbolicMemory）に値を設定しています。プログラム内の個々の実行経路は、angrによって提供されるPathオブジェクトによって管理されており、これらは経路上で行われたアクション、経路の述語、およびその他さまざまな経路固有の情報を追跡します。これらの経路のグループは、angrのPathGroup機能によって管理されており、動的な象徴実行中に経路を分割、統合、フィルタリングするためのインターフェースを提供します。

angrにはVeritesting [5] の組み込みサポートがあり、Veritesting解析として実装されており、PathGroupオブジェクトにオプションを渡すことで透過的にサポートを利用できます。この高度な状態マージ技術は、パスを静的かつ選択的にマージすることで、状態数が指数関数的に増加する問題を緩和します。

# X. IMPLEMENTATION:

## UNDER-CONSTRAINED SYMBOLIC EXECUTION

私たちは、UC-KLEE [46] で提案されたアンダーコンストレインドシンボリックエクスキューション（UCSE）を実装し、UC-angr と名付けました。UCSE は、各関数ごとに個別に実行を行う動的シンボリックエクスキューション手法です。解析は特定の関数に *どのように* 到達するかを考慮できないため、UCSE が検出したものは再現性がありません。実際の実行時に呼び出される際の *コンテキスト*（引数やグローバル変数）がない状態で各関数が生成されるため、解析の精度は低く、誤検出（フォールスポジティブ）が発生しやすくなります。

UCSEは、状態内で文脈が不足しているタグを*underconstrained*（制約不足）としてマークします。このような制約不足のデータがポインタとして使用されると、新しい制約不足の領域が作成され、そのポインタは新しい領域を指すようになります。この「オンデマンド」なメモリ割り当てにより、複雑なデータ構造を管理するコードの解析が可能になります。セキュリティ違反（たとえば、スタック上の保存されたリターンアドレスへの書き込み）が特定された場合、関係する値が*under-constrained*であるかがチェックされます。特定の条件下（たとえば、関与するすべてのデータが制約不足である場合）には、その違反は誤検知として除外されます。

私たちは、UCSEで説明されている技法に2つの変更を加えました。

- グローバルメモリのアンダーコンストレイン。元のUC-KLEEの実装では、グローバルメモリへのアクセスをアンダーコンストレインとして扱っていませんでした。しかし、このようなメモリもプログラムコンテキストの一部であり、UCSEでは予測することが不可能です。なぜなら、特定の関数を解析する際、グローバルデータはすでに上書きされている可能性があるからです。そこで、すべてのグローバルデータをアンダーコンストレインとしてマークし、これによって偽陽性率を下げることができます。
- パス制限機能。元のUC-KLEEの実装には、パスの爆発を防ぐためにいくつかの制限が組み込まれていました。たとえば、制約の少ないポインタのデリファレンスの深さを制限し、制約の少ないリンクリストの探索が決して終了しないようにしていました。私たちはさらに追加の制限機能を導入しました。関数がパス爆発の原因であると判断された場合、その関数の解析を中止します。これを検出するため、制限値をハードコーディングしており（実験では経験的に決定した64パスを使用）、1つの関数がこの数のパスに分岐した場合、その関数を即座にリターンするよう置き換え、呼び出し元から解析を巻き戻します。これによりパス爆発を避けて解析を現実的なものに保てますが、その分解析の精度はさらに低下します。
- 偽陽性のフィルタリング。私たちはUCangrの実装にいくつかの追加的な偽陽性フィルタを導入しました。具体的には、搾取可能な状態を検出した際、その状態が制約の不足によって誤って搾取可能と判断されていないかを確認します。まず、追加の制約Eを用いて制約解決を行います。このEは、その状態が搾取可能「でない」ことを表しています（例えば、セキュリティ違反がリターンアドレスの上書きだった場合、そのリターンアドレスが上書きでき「ない」ように状態を制約します）。次に、各未制約データの値を、この搾取不可能な状態から得られた可能な解に制約します。これらの制約をUと呼びます。最後に、Eの制約を取り除き、Uの制約だけを残して確認します。

状態が依然として悪用可能である場合、これはその関数自体に何らかの本質的な欠陥が存在する可能性が高いことを意味します。この欠陥は必ずしもコンテキストからの*データ*が不足していることに起因しているとは限りません。ただし、この欠陥は依然として、不足している*制約*による誤検知や、十分に制約されていないデータに対するコンテキストの限界によって生じている可能性もあることに注意してください。

UC-angr は、制約の緩いデータアクセスを追跡し、必要な再配置を実行する SimState プラグインとして実装されています。このプラグインが初期化されると、動的シンボリック実行と同じ PathGroup パラダイムを使って、制約の緩いシンボリック実行を行うことができます。

## XI. IMPLEMENTATION: SYMBOLIC-ASSISTED FUZZING

ここではシンボリック支援型ファジング実装の概要を説明しますが、Drillerと呼ばれるこの手法の全容については、別の論文 [54] で詳しく述べられています。

私たちのシンボリック補助型ファジングの実装は、AFLファザーを基盤とし、angrをシンボリックトレーサーとして使用しています。AFLのパフォーマンスを監視することで、AFLが作成した入力をいつシンボリックトレースするかを判断できます。この判断のために、ファザーが新しい状態遷移を発見する速度に基づいて行動します。AFLが、入力の変異を一巡させた後に新しい状態遷移を発見できなかったと報告した場合、ファザーが進展に苦労していると考え、AFLが*ユニーク*と判断したすべての経路（つまり、他の経路では見られないソースアドレスとデスティネーションアドレスのタプルによって識別されるジャンプを持つ経路）に対してangrを実行し、AFLが入力を見つけることができなかった遷移を探索します。

Drillerのシンボリックコンポーネントはangrのシンボリック実行エンジンを使用して実装されており、AFLから提供された具体的な入力に基づいてパスをシンボリックにたどります。これにより、シンボリック実行に内在するパス爆発の問題を回避できます。なぜなら、各具体的な入力は（追跡された）単一のパスに対応し、これらの入力はAFLによって有望なものだけが追跡されるよう十分に絞り込まれているためです。各具体的な入力はPathGroup内の個々のパスに対応します。PathGroupの各ステップでは、すべての分岐をチェックし、最新のジャンプ命令がAFLによって未知のパスにつながるかどうかを確認します。そのようなジャンプが見つかった場合、SMTソルバーにクエリを送り、実行を新たなジャンプ先へ導く入力を生成します。この入力は再びAFLに渡され、次回以降のファジングステップで変異されます。このフィードバックループによって、高コストなシンボリック実行の時間と、低コストなファジングの時間のバランスを取ることができ、またファジングがプログラムの動作に関して持つセマンティックな理解の乏しさも補うことができます。

# XII. IMPLEMENTATION: CRASH REPRODUCTION

私たちは、Replayer [43] によって提案されたアプローチを実装し、入力値（つまり、攻撃者が送信する値）と出力値（つまり、攻撃者がアプリケーションから漏洩させる値）の間の失われた関係を復元しました。

私たちのReplayerの実装は、独自のシンボリック実行エンジンの上に構築されています。クラッシュを引き起こす入力を再現する問題は、プログラムを初期状態sからクラッシュ状態qに導く入力仕様i<sup>s</sup>を探索することと定義できます。本アルゴリズムは、プログラムP、初期状態s<sup>a</sup>（すなわち実行ファイルのエントリーポイントでの状態）、クラッシュ状態q<sup>a</sup>、そして初期状態s<sup>a</sup>からクラッシュ状態q<sup>a</sup>へとインストゥルメント化（ランダム性除去）された環境で到達させる入力i<sup>a</sup>を入力として受け取ります。ただし、i<sup>a</sup>は非インストゥルメント化環境では正しく再現できません。私たちの実装では、i<sup>a</sup>を用いながらs<sup>a</sup>からq<sup>a</sup>までの経路をシンボリックに実行し、その過程で生成されたすべての制約を記録します。これらの制約、実行経路、プログラムP、および新しい初期状態s<sup>b</sup>が与えられたとき、プログラムPを*制約のない*シンボリック入力で、記録しておいた実行経路に従って新たなクラッシュ状態q<sup>b</sup>に到達するまでシンボリック実行できます。到達した時点で、入力と出力にかかる制約を解析し、それらの関連を復元することができます。この関連データが入力仕様i<sup>s</sup>の生成に利用され、クラッシュ入力のリプレイが可能になります。

Replayerによって提案された実装には、クラッシュ再現への応用において2つの主な制限があります。まず、セクションV-Aで述べているように、特定のクラッシュでは、そのクラッシュを正しく再現するために必要なすべてのデータが取得できない場合があります。Replayerはこれらのケースに対応できず、新たなクラッシュ入力を見つける必要があります。

第二に、Replayerはクラッシュを引き起こした入力を処理する際に、アプリケーションがデランダマイズ環境で実行した正確なパスのみを使用して、入力仕様を生成します。もしバイナリの実行トレースがランダムデータの正確な値によって変化する場合、Replayerは正しい入力を計算できません。例えば、ランダムクッキーがデコーディング関数を通じて特定の実行パスを引き起こし、パス述語を導入した場合、その正確なパスで実行をリプレイすると、クッキーの値が最初のものとは異なる値に制約されることがあります。これが発生すると、リプレイされたクッキーは正しくなくなり、リプレイの試みは失敗します。後で述べるように、AEGも同様の制約に直面しています。これは、この分野の研究がこれら両方のタスクに進展をもたらす可能性があることを示唆しています。

# XIII. IMPLEMENTATION: EXPLOIT GENERATION

AXGEN [51]、AEG [4]、Mayhem [16] で説明されているものと類似したアルゴリズムを実装することによって、自動エクスプロイト生成における最新技術の有効性を評価することができました。私たちの実装では、脆弱性に対するエクスプロイトを作成し、攻撃者が保存された命令ポインタを上書きすることによってプログラムの実行制御を奪うことが可能になります（例えば、関数ポインタを上書きしたり、スタック上のバッファオーバーフローを悪用することなどです）。

脆弱な状態。AEG/Mayhemとは異なり、またAXGENに類似して、私たちはangrを用いてプログラムがクラッシュした入力に対してコンコリック実行を行い、エクスプロイトを生成します。コンコリック実行を進める際には、クラッシュした入力を実際にプログラムに適用して得られた動的トレースと同じ経路をたどるように強制します。コンコリック実行はプログラムがクラッシュした時点で停止し、シンボリック状態を調査することでクラッシュの原因を特定し、エクスプロイト可能性を評価します。特定のレジスタにおけるシンボリックビット数を数えることによって、クラッシュをフレームポインタ上書き、命令ポインタ上書き、任意書き込みなど、いくつかのカテゴリに分類することができます。

Instruction Pointer Overwrite Technique. 最も単純で悪用可能なバグは、クラッシュ時に命令ポインタにシンボリックなビットが現れる場合です。命令ポインタにシンボリックなビットが含まれていることを検出した際には、命令ポインタを制御可能な命令列（例えばシェルコード）や、スタックをシンボリックなバッファにピボットするROPガジェットに制約することができます。これにより、そこでROPチェーン（私たちのエクスプロイト強化手順で生成されたもの）を実行できます。angr自体は、AEGやAXGENで議論された実装上の多くの詳細（例えば、テイントトラッキングやパス条件の構築など）を処理してくれるため、私たちはシンボリックなメモリバッファを見つけ、これらのアプローチが提案したように、レジスタ値に制約をかけてエクスプロイトを生成することに集中できます。

CGC バイナリの悪用。Cyber Grand Challenge は、7つのシステムコールのみを含むカスタムOS上でゲームを開催しています。プログラムの実行やファイルのオープンが可能なシステムコールが存在しないため、Cyber Grand Challenge 内でのエクスプロイトは、レジスタの制御やメモリの読み書き能力を示すことに限られます。DARPAの基準によると、CGC には2種類のエクスプロイトが存在します。

- タイプ1エクスプロイトは、攻撃者が汎用レジスタと命令ポインタレジスタを制御していることを示します。
- Type 2 のエクスプロイトは、攻撃者がプロセスメモリ空間から制御された読み出しを実行できることを示しています。

126個のバイナリにAEGを適用した結果、実際にエクスプロイトに成功したのはわずか4個のバイナリだけでした。このうち2つのバイナリに対してのみ、「Type 2」エクスプロイトを生成することができました。これら2つの「Type 2」エクスプロイトは、どちらもROPによるハードニングができず、シェルコードへのジャンプを使う方法に頼らざるを得ませんでした。さらに、AEGが生成できたハードニング済みのROP「Type 1」エクスプロイトは2つだけでした。これらの結果から、自動エクスプロイト生成の分野にはまだ多くの課題が残されており、現状の手法は現代的な脆弱性には十分適用できないことが示されていると考えています。

Challenges Faced.  
ここでは、CROMU00019 [24] を用いて、我々のツールが Cyber Grand Challenge のバイナリを悪用しようとした際に直面したいくつかの課題を示します。本節では、このチャレンジの README に記載されている2番目の脆弱性（特に、攻撃者が供給した文字列をデコードする際に発生するスタック上のバッファオーバーフロー）の悪用に焦点を当てます。

私たちがエクスプロイト生成の際に直面した主な問題は、オーバーフローするデータの各バイトが単一の値に制約されてしまうパス述語の存在でした。これは、これらのバイトの値がシンボリック入力に基づいて選ばれているにもかかわらず発生します。CROMU00019は、そのdecode関数でこの問題を示しています。ペイロードの各バイトは、decodeに含まれるswitch文の分岐をたどり、脆弱な状態を表すパスに厳しい制約を課します。このswitch文の各分岐はシンボリックデータに基づき選択されますが、戻されるデータは具体的であり、これらの各分岐がプログラム内の別々のパスを示しています。従来のAEGアプローチでは、シンボリックデータに適切な制約を課して制御フローの乗っ取りを行うことができると仮定していますが、この動作ではdecode関数内で希望するバイトが出力バッファに入る*唯一*のパスを見つける必要があります。

この問題の解決策は、脆弱な状態を持つ多くのパスの中から、望ましい制御フローのハイジャックを実行する単一のパスを探すことです。しかし、現在のエクスプロイト生成技術にはその能力がなく、このようなケースが、CGC Qualifierイベントで提示された多くのスタックバッファオーバーフローの脆弱性を、最新の自動エクスプロイト生成技術では悪用できなくしている要因となっています。

# XIV. IMPLEMENTATION: EXPLOIT HARDENING

最新の緩和技術に対するエクスプロイトの強化のために、Q [48] のアイデアに基づいたROPチェーンコンパイラを実装しました。これにより、メモリへのデータ書き込みやライブラリ内の任意の関数呼び出しなど、最終的な目的を達成するためのROPペイロードを自動生成することが可能です。このセクションでは、Q そのものと比較して私たちが加えた違いや改善点に焦点を当てます。

私たちのアプローチは、次のステップで構成されています。

- ガジェットの発見。アプリケーション内のすべての実行可能コードを、バイトオフセットごとにスキャンし、ROPガジェットを特定し、その効果に応じて分類します。たとえば、mov [ebx], eax; pop ebx; ret という命令列は、メモリ書き込みとレジスタのロードとして分類されます。分類を行うために、私たちの解析ではangrのPathオブジェクトが提供するアクション履歴や、Claripyが提供するシンボリックな関係を活用しています。
- ガジェットの配置。ROPチェーンコンパイラは、その後、*高レベル*な操作を実行するために使用できるガジェットの*配置*を決定します。例えば、データをスタックにプッシュするガジェットは、データをポップするガジェットと組み合わせることで、あるレジスタから別のレジスタへデータを移動する配置を作ることができます。
- ペイロード生成。ROPコンパイラが必要なガジェットの組み合わせを特定した後、これらのガジェットを*チェーン*として組み合わせ、高度な動作（例えば攻撃者が指定した引数付きのシステムコールを実行するなど）を行います。これは、angrのプログラム状態にガジェットの組み合わせを書き込み、その出力を指定された引数に制約し、SMTソルバーに対してそれらの入力の解を問い合わせることで行われます。

私たちの実装は、Qとは細かな点で異なっています。まず、Qではスタックを一時的な記憶領域として利用していませんでした。その理由は明確ではありません。一つの説明としては、彼らの解析プラットフォームがスタック操作のモデリングをサポートしていなかった可能性があり、もう一つは、スタックが必ずしもスタックポインタによって指されている（したがって、その位置が分かっている）とは限らないと仮定したほうが、手法としてより一般的になるからかもしれません。私たちの統合システムでは、AEGの実装から生成したエクスプロイトのメタデータを用いることで、スタックポインタがスタックを指しているかどうかを特定することができました。

もう一つの改良点は、ガジェットの分類に関するものです。Qは特定のガジェットクラスを特定するために *value sampling* 手法を用いていましたが、サンプルのカバレッジが限られていたため、いくつかのガジェットチェーンを見逃してしまう結果になっていました。

| Technique                  | Based On                 | Described In |
|----------------------------|--------------------------|--------------|
| ダイナミックシンボリック実行    | Various [12], [16], [20] | IV-A2, IX    |
| Veritesting                | Veritesting [5]          | IV-A2, IX    |
| アンダーコンストレインドDSE      | UCSE [46]                | IV-A2, X     |
| シンボリック支援ファジング       | Driller [54]             | IV-A1, XI    |
| 静的解析                    | VSA [6]                  | III-C, VIII  |
| クラッシュリプレイ              | Replayer [43]            | V-A, XII     |
| エクスプロイト生成              | AEG [4]                  | V-B, XIII    |
| エクスプロイトハードニング        | Q [48]                   | V-C, XIV     |
|                            |                          |              |

TABLE I

本論文で実施・評価された分析、それらの基礎となる文献、およびそれらについて本論文で議論されているセクション。

私たちの手法では、すべてのガジェットを記号的に解析し、解析の高速化のために慎重なキャッシュ技術を用いています。

## XV. COMPARATIVE EVALUATION

angrの設計を活用することで、私たちはこれまでに議論してきたバイナリ解析手法を同じコードベース上で再現し、それらの有効性を比較評価することができました。私たちの知る限り、これはこれまで行われていません。以前の比較は異なる実装で行われており、実装の違いによって結果に差が生じる可能性が残っていました。fuzzer本体（AFL）を除き、私たちの解析はすべて同じ解析エンジン上に実装されており、互いに90%以上のコードベースを共有しています。

私たちは評価を行うために、DARPAがCGC Qualification Eventのために公開したCGCバイナリのコーパスを利用します。Section II-Bで述べたように、これらのバイナリは複雑さに大きな違いがありますが、解析システムの実装作業を軽減するためにDARPAが設計したシンプルな環境モデルを利用しています。

私たちは、CFG リカバリ、動的および静的な脆弱性発見、クラッシュリプレイ、エクスプロイト、エクスプロイトハーデニングのために実装した手法を評価します。私たちが実装し評価した解析の概要、それぞれの解析が基づく文献、および本論文でそれらが説明されているセクションについては、Table I にまとめています。

# *A. CFG recovery*

CFGはangrの他の解析の前提条件として使用されるため、angrのCFGリカバリがどれほど効果的に動作するかを理解することは重要です。セクションVIIで詳しく述べたように、angrには2つのCFGリカバリアルゴリズムがあります。CFGAccurateは*強制実行*という基本的なアプローチに基づいており、間接ジャンプ解決のために*逆方向スライシング*と*シンボリックバックトラバーサル*という2つの手法を提供します。一方、CFGFastは主に再帰的な逆アセンブルとヒューリスティックを用いて、関数および関数間の制御フローを素早く特定します。

これらのリカバリ手法の効果を理解するために、私たちはCFGFastとCFGAccurateを、最先端の商用ツールであるIDA Pro 6.9によるCFGリカバリとCGCバイナリ上で比較しました。IDA ProがどのようにCFGをリカバリしているかの詳細はほとんど公開されていませんが、先行研究[59]での記述や私たちの観察に基づくと、IDA Proはバイナリを再帰的に逆アセンブルし、シンボルやその他のヒューリスティックを用いて場所を特定していると考えられます。

| CGC Qualifying Position  | Binaries Crashed |  |  |  |
|--------------------------|------------------|--|--|--|
| First                    | 77               |  |  |  |
| Second                   | 12               |  |  |  |
| Third                    | 57               |  |  |  |
| Fourth                   | 9                |  |  |  |
| Fifth                    | 23               |  |  |  |
| Sixth                    | 57               |  |  |  |
| Seventh                  | 44               |  |  |  |
| Eighth (did not qualify) | 39               |  |  |  |
| Ninth (did not qualify)  | 65               |  |  |  |

TABLE III

CGC予選イベントにおける上位9競技者のクラッシュしたバイナリの数。

バイナリ全体の関数について解析を行い、その後、軽量なデータフロー解析を利用して間接ジャンプのターゲットをさらに特定します。これは概念的には、CFGAccurate よりも CFGFast により近い方法です。正確な CFG の情報が利用できないため、IDA の CFG リカバリー結果と自分たちの CFG リカバリー結果の間で、復元されたベーシックブロック数と制御フロー遷移数の相対的な数によって結果を評価します。

まず私たちは、CFGFastが特定したブロックやエッジと、IDA Proによって生成されたグラフを比較することで、CFGの網羅性を評価します。Table IIはその結果を示しています。CFGFastはIDA Proよりもわずかに高いコードカバレッジを持ち、より多くのエッジを検出しています。これは、CFGFastで使用されている軽量なデータフロー解析やヒューリスティックが、IDAで使われているものよりも高度であるためだと考えています。いくつかのバイナリに対するリカバリ結果を手動で解析したところ、CFGFastはコードリカバリにおいてより積極的であることが分かりました。すなわち、IDA Proは特定のコード領域について到達不能であると判断し、コードとして逆アセンブルしようとしませんが、CFGFastはそのような場所もコードとして認識します。これについて考えられる説明としては、私たちの手法が*必要以上に*積極的であり、その結果としてそのような場所を誤って識別してしまう可能性があるということです。しかし、CGCバイナリを分析した際にはそのようなケースは確認されていません。

いくつかのバイナリアナリシスではエントリポイントからの*到達可能性情報*が必要となるため、IDA Proによって生成されたCFG（すなわち、エントリポイントから経路を特定できるブロックで構成されるCFG）の*到達可能*部分と、angrのCFGAccurate解析によって復元されたCFGとの比較も行いました。表IIに結果を示します。強制実行手法を後方スライシングで改善することで、angrはCFGの再構築能力を大幅に向上させています。しかし、CFGAccurateは*ad hoc*なヒューリスティクスを利用していないため、生成されるCFGのコードカバレッジはIDA Proほど高くありません。より高いカバレッジを実現するには、CFGFastで復元されたすべての関数をCFGAccurateの開始点として提供することができます。

# *B. Evaluation of Vulnerability Analysis Techniques*

VIII章からXI章にかけて、いくつかの脆弱性発見手法の実装について説明します。ここでは、これらの手法をCGCデータセットに適用した際の比較評価の結果を示します。評価は、評価用データセットを取得したDARPAコンペティションの制限時間と同じく、24時間のタイムアウトで実施しました。

これらの結果の要約を表IVに示します。さらに、件数に関するより良い文脈を提供するために、

|    |                            |                                                        |                              | Blocks                                                       |                                   |                                                   |                                   | Bytes                                                             |                                        | Time (s)                                                  |                                        |
|----|----------------------------|--------------------------------------------------------|------------------------------|--------------------------------------------------------------|-----------------------------------|---------------------------------------------------|-----------------------------------|-------------------------------------------------------------------|----------------------------------------|-----------------------------------------------------------|----------------------------------------|
| M  | A                          | M                                                      | A                            | M                                                            | A                                 | M                                                 | A                                 | M                                                                 | A                                      | M                                                         | A                                      |
|    |                            |                                                        |                              |                                                              |                                   |                                                   |                                   |                                                                   |                                        |                                                           | 1.80                                   |
|    |                            |                                                        |                              |                                                              |                                   |                                                   |                                   |                                                                   |                                        |                                                           | 5.01                                   |
|    |                            |                                                        |                              |                                                              |                                   |                                                   |                                   |                                                                   |                                        |                                                           |                                        |
|    |                            |                                                        |                              |                                                              |                                   |                                                   |                                   |                                                                   |                                        |                                                           | 1.80                                   |
|    |                            |                                                        |                              |                                                              |                                   |                                                   |                                   |                                                                   |                                        |                                                           | 36.96                                  |
|    |                            |                                                        |                              |                                                              |                                   |                                                   |                                   |                                                                   |                                        |                                                           | 34.10                                  |
| 30 | 32.80                      | 47.5                                                   | 53.89                        | 344.5                                                        | 653.56                            | 594                                               | 1178.98                           | 6109.5                                                            | 14641.85                               | 24.78                                                     | 79.46                                  |
|    | 48<br>61<br>37<br>31<br>32 | 関数<br>52.96<br>70.08<br>40.96<br>33.24<br>33.76 | 76.5<br>88<br>74<br>48<br>50 | 関数エッジ<br>99.62<br>118.74<br>90.76<br>55.22<br>56.28 | 829<br>843<br>496<br>349.5<br>368 | 3589.93<br>3609.45<br>1043.81<br>413.85<br>635.41 | 1188<br>1193<br>759<br>612<br>645 | ブロックエッジ<br>6487.68<br>6538.52<br>1693.01<br>751.96<br>1089.78 | 14037<br>14296<br>7874<br>6125<br>6323 | 104779.66<br>105007.49<br>21721.85<br>13963.5<br>10883.51 | 1.14<br>0.87<br>1.14<br>23.50<br>27.22 |

TABLE II

CFGFASTとCFGACCURATEによって復元されたCFGと、IDA PROによって復元されたCFGを比較評価しています。すべてのバイナリに対する各値の中央値（M）と平均値（A）を示しています。

| Technique                                | Replayable | Semantic Insight | Scalability | Crashes | False Positives |
|------------------------------------------|------------|------------------|-------------|---------|-----------------|
| Dynamic Symbolic Execution               | はい       | 高い             | 低い        | 16      | 0               |
| Veritesting                              | はい       | 高い             | 中程度      | 11      | 0               |
| Dynamic Symbolic Execution + Veritesting | はい       | 高い             | 中程度      | 23      | 0               |
| Fuzzing (AFL)                            | はい       | 低い             | 高い        | 68      | 0               |
| Symbolic-Assisted Fuzzing                | はい       | 高い             | 高い        | 77      | 0               |
| VSA                                      | いいえ     | 中程度           | 高い        | 27      | 130             |
| Under-constrained Symbolic Execution     | いいえ     | 高い             | 高い        | 25      | 346             |

TABLE IV

すべての脆弱性発見手法における評価結果。

我々の手法によって特定されたクラッシュ数に加えて、Table III には実際の CGC Qualification Event で競合他社によって特定されたクラッシュ数も掲載しています。チームの総合得点はクラッシュ数だけで決まるわけではないため、予選イベントでの順位と競合他社の位置づけには相関がありません。これらの競合他社のうち、1位のチーム [27] と7位のチーム [57] は、大会で使用した手法についてブログ記事を執筆しています。両チームとも、Driller と概念的に類似した、シンボリック処理を補助として用いるファジング手法を利用していました。なお、Driller の我々の実装が1位チームと同数の脆弱性を特定したのは偶然であり（おそらく手法の類似性によるものです）、特別な意味はありません。

動的シンボリック実行について、単独での評価と、Veritestingパス爆発緩和技術を組み合わせた場合の評価の両方を行うことにしました。これらの手法の実装の詳細については、Section IX で説明します。

予想通り、動的シンボリック実行は頻繁にパス爆発問題に悩まされました。標準的な手法では、CGCバイナリのうち16個で脆弱性が特定されました。パス爆発問題の部分的な緩和を目的としたVeritestingでは、11個しか特定されませんでした。これらを合わせると、脆弱性が特定されたアプリケーションは合計23件となります。

私たちは最初、より良い結果が得られたにもかかわらず、Veritesting アプローチが動的シンボリック実行単独よりも少ない脆弱性しか発見できなかったことに驚きました。これらの4つのバイナリについて調査したところ、Veritesting 固有の興味深いトレードオフを特定しました。Veritesting はパスの爆発的増加に対処するために効率的なパスマージを使用しており、これがパスの爆発がさらなる探索を不可能にする前に、バイナリのより深いパスを探索できる理由となっています。しかし、このようなパスマージにより複雑な式が導入されます（例：2つのマージされたパスでレジスタ eax の値が異なる場合、マージ後のパスの値は過去の2つの値をエンコードする複雑な式でなければなりません）し、制約ソルバーに大きな負荷がかかります。そのため、これらのマージが増えるほど制約ソルバーの解決時間が長くなる傾向があります。制約解決は NP 完全問題であるため、複雑さの増加により、脆弱性が現実的な時間内には到達不能になります。その結果、Veritesting は動的シンボリック実行ではパス爆発が発生する浅いバグを特定することができますが、長いパスの場合は制約ソルバーを圧倒してしまいます。

シンボリック支援によるファジング。支援付きファジングは、文献において非常に効果的であることが証明されています。セクションXIでは、Driller [54] と名付けられたシンボリック支援ファジング手法の実装について論じます。

このシンボリック支援型ファザーは、ファズィングのコンポーネントとしてAFLを使用しています。AFLが生成した各入力は、動的シンボリック実行エンジンでトレースされ、入力を工夫して変異させることで到達可能なコード部分が特定されます。この慎重な変異はシンボリック制約ソルバーによって実行され、その入力はさらなる実行と変異のためにAFLに再導入されます。DSEエンジンでトレースされる個々の入力は分岐しない（すべての入力が具体的であるため）、トレース時にパス爆発は発生しません。また、AFLはコードカバレッジを増やさないすべての入力を除外することで、DSEエンジンに渡す入力の数を制限しています。

AFL単体でも、多くのCGCサービスの脆弱性を特定できることは注目すべき点です。実際、私たちのシンボリック支援ファザーで検出した77件の脆弱性のうち、68件はAFL単体で検出されました。残りの9件はシンボリック支援によって発見されたものです。

DSEとファジングの違い。さまざまな動的記号実行手法による結果の違いは、驚くべきものです。一般的には、DSEが記号的支援を受けたファジングと同程度の脆弱性を特定できると考えられるかもしれませんが

![](_page_17_Figure_0.jpeg)

図1. ファジングによって発見されたクラッシュ経路の長さと動的シンボリック実行によって発見されたクラッシュ経路の長さの比較

ファジング、そしてファジングだけではありません。実際には、ファジングはほぼ*3倍*もの脆弱性を特定しました。ある意味、これは最近のセキュリティ業界の動向を反映しています。具体的には、シンボリック解析エンジンは実用的でないと批判される一方で、ファザーがますます注目を集めています。しかし、この状況はここ数年の研究の方向性とは対照的であり、研究分野ではシンボリック実行が重視されているようです。

これらの手法によって発見されたクラッシュを引き起こす入力を分析した結果、興味深い発見がありました。それは、動的シンボリック実行エンジンによって見つけられるエクスプロイトは*短い*パスを表現する傾向があるということです。この結果はFigure 1に示されています。動的シンボリック実行（たとえVeritestingを用いても）が脆弱性の発見に*失敗*したいくつかのアプリケーションをスポットチェックしたところ、これは解析の複雑さがパスの長さに対して指数関数的に増加するためであると結論づけました。

具体的には、パスAが与えられた場合、次の条件分岐の終わりでAが分岐する確率がp<sup>a</sup>ある。そしてA<sup>1</sup>はジャンプ先のパスを、A<sup>2</sup>はジャンプしないパスを進むことになる。次の条件分岐でも、A<sup>1</sup>とA<sup>2</sup>がさらに分岐する可能性がある。このようにして、分析すべきパスの数は指数関数的に増加し、ある時点で分析しなければならないパスの数が非現実的なほど多くなる確率も、実行された基本ブロックの数に指数関数的に比例する。その結果、一般的な動的シンボリック実行手法は、多くの基本ブロックの実行を必要としない「浅い」クラッシュの発見には最適である。一方で、「深い」クラッシュはパス爆発によって隠され、到達困難になる傾向がある。

テクニックの相対的な有効性をさらに理解するために、生成されたテストケースの*コードカバレッジ*を計算しました。シンボリック実行（Veritestingを含む）がバイナリごとに平均330ブロック（中央値は260）をカバーしたのに対し、ファジングは689（中央値は402）、シンボリック支援ファジングは698（中央値は406）をカバーしました。これらの結果から、もう一つ興味深い結論が導き出されます。つまり、ファジングやシンボリック支援ファジングによって生成されたパスを*グラフ*に統合した場合、それはCFGAccurateによって復元されるものよりも多くのコードカバレッジを持つCFGを表すことになり（そして、グラフ内の各エッジが定義上到達可能であるため、完全性も完璧である）、正確なCFG復元アルゴリズムのさらなる改善が必要であることを示しています。

アンダーコンストレインドシンボリック実行。私たちは、angrを拡張してアンダーコンストレインドシンボリック実行をサポートし、このような手法が我々のデータセットに対してどれほど有効であるかをよりよく理解できるようにしました。これらの詳細はセクションXで説明します。

UC-angrは、CGCバイナリ内で371件の脆弱性を報告しました。

しかしながら、この手法は関数をその文脈なしで解析するため、静的解析と同様の問題を抱えています。つまり、結果には多数の誤検出が含まれ、さらに結果は再現可能ではありません（つまり、クラッシュを引き起こす入力を生成するのではなく、脆弱性の位置を指摘するだけです）。実際、UC-angrの結果には346件の誤検出が確認され、正しい検出は25件のみであり、偽陽性率は93%となりました。これはUC-KLEE [46] で報告されているものと同程度です。

静的バッファオーバーラップ検出。ファジングやシンボリック実行、その他の静的解析によって特定されたさまざまなタイプの脆弱性を比較できるようにするため、VSAに基づくメモリ破損検出解析を実装しました。その詳細については、セクションVIIIで説明します。

UC-angrと同様に、私たちのVSAの結果も再現可能ではなく、誤検知が発生します。VSAはCGCバイナリにおいて実際に27件の脆弱性を特定できましたが、同時に130件の誤検知が発生し、誤検知率は82.8%となりました。

再実現不能解析と再実現可能解析の違い。もう一つ驚くべき結果は、再実現不能な手法（VSAおよび制約緩和型シンボリック実行）の比較的低い性能です。これらの手法は、再実現可能性の要件から解放されているため、より広い範囲を解析できますが、文脈が不足しているため、このデータセットでは非常に多くの誤検知が発生することがわかりました。誤検知率を妥当な範囲に抑えるために、（セクションXで述べたような）積極的な誤検知フィルタリングを実装する必要がありましたが、それによって多くの真陽性も除外されてしまいました。

実際のバイナリに対する静的解析技術の向上は、研究の注目を必要としている分野のようであり、私たちはこれを今後の研究課題として検討しています。

# *C. Exploitation Evaluation.*

上記の手法によってクラッシュが特定された後、そのクラッシュを再現し、悪用を試みて重大性を理解します。

クラッシュリプレイ。Section V-A で述べたように、脆弱性発見解析によって特定されたクラッシュ入力は、環境データ（例えばランダムシードなど）が解析時に*非ランダム化*されているため、単純には再現できない場合があります。CGCバイナリごとにクラッシュを解析し、脆弱性特定手法で脆弱性を特定できなかったバイナリについては、DARPAが提供したリファレンスのクラッシュ入力を使用しました。これらのクラッシュ入力のうち、6つは単純には再現できませんでした。つまり、脆弱性特定エンジンから提供されたクラッシュ入力を単に再実行するだけではなく、バイナリとのやり取りを再解析して、これらのバイナリに存在するチャレンジ‐レスポンスの要素を復元する必要がありました。

興味深いことに、DARPAはCGC Qualifying EventのCGCバイナリの作者に対し、ランダムデータによってコントロールフローが影響を受けることを禁止する制限を課しています。これは、セクションXIIで議論したReplayerの制限、すなわちランダムデータの異なる値による異なるパス述語の導入が、CGCバイナリでの動作には当てはまらないことを意味します。angrがあるアプリケーションでハングしたものの、手動での分析により、これはアプローチ自体ではなく実装上の問題であることが判明し、期待通りReplayerは残りの5つの入力仕様を復元することができました。

6つのバイナリは大規模なデータセットとは言えませんが、この結果は、この分野における現在の手法が、ランダムデータによる制御フローの変動がない場合にはバイナリを適切に処理できることを示唆しています。より複雑な制御フローを持つ実際のバイナリに対して、これらの手法を評価し、必要に応じて拡張するためのさらなる研究が必要です。

自動エクスプロイト生成。クラッシュを特定し、それをReplayerで実行した後、ターゲットアプリケーションを確実にクラッシュさせる入力仕様が得られます。しかし、このような入力が必ずしも*エクスプロイト可能*であるとは限りません。例えば、CGCデータセットに多数存在するヌルポインタ参照によるクラッシュは、現代のシステムではエクスプロイト可能ではありません。エクスプロイト可能な入力とそうでない入力を区別するために、クラッシュからエクスプロイトの生成を試みます。

私たちは、AEGシステム[4]で提案された手法を用いて、すべてのCGCアプリケーションに対して自動的にエクスプロイトの生成を試みました。しかし、これらの手法を使って武器化できたクラッシュエクスプロイトは、わずか*4*つだったことに驚かされました。バイナリをさらに詳しく調べていくうちに、その理由が分かりました。まず、CGC予選イベントの目的は、バイナリに対して*クラッシュ*を見つけることであり、エクスプロイトを見つけることではありませんでした。そのため、これらのバイナリに含まれる脆弱性の多くは、実際にはエクスプロイト可能なものではありません（例：ヌルポインタ参照）。次に、CGCバイナリはさまざまな現実的な攻撃シナリオをモデル化しているため、AEGで提案された手法の多くは大部分に適用できないことが分かりました。

この分野の現状の最先端はかなり基本的なものであり、それがこれらの結果にも表れています。複雑な脆弱性を自動的に活用するためには、この分野でさらなる研究が必要です。

エクスプロイトハードニング。たとえ悪用可能な脆弱性が存在しても、現代的な保護機能によってその影響が軽減される場合があります。そのため、*エクスプロイトハードニング* が必要とされており、最近の研究でも調査されています。私たちはQ [48]によって提案された手法を再実装し、AEGによって生成されたエクスプロイトを強化しようとしました。

Qの実装は、AEGが生成した4つのエクスプロイトのうち2つを強化することができました。残りの2つのエクスプロイトを強化できなかった理由についての我々の分析では、Qアプローチがバイナリ内の情報を十分に活用していないことが明らかになりました。これら2つの例では、スタック上に攻撃者が制御できるデータが十分に存在せず、プログラムの他の部分にある攻撃者制御データを使用するためには*スタックピボット*が必要となります。Qアプローチにはこのような操作について推論する基盤がなく、その結果、これらのエクスプロイトを強化することができません。

#### XVI. CONCLUSIONS

本論文では、angrについて紹介しました。angrは、バイナリにおける脆弱性の自動的な特定と悪用のためのさまざまな手法を、統一されたフレームワークで実装したシステムです。私たちは、これらの解析手法や、それらをフレームワークに組み込む際に直面した課題を、体系的に示しました。これらのアプローチを単一のシステム内で実装することにより、これらの手法の評価用に作成したデータセット上で、それらの有効性を有意義に比較することができました。本評価の結果は、今後の研究の方向性を示す基盤となり、既存の手法を改善するためにも活用できます。

私たちはangrをオープンソース化しました。これにより、コミュニティがその上に構築し、バイナリ解析分野における未解決の課題に取り組むことに集中できるようになっています。

謝辞。本研究は、DARPAの契約番号N66001-13-2-4039およびONRの契約番号N00014-15-1-2948のもとで支援を受けています。アメリカ合衆国政府は、著作権表示にかかわらず、政府の目的のために本書の複製および配布を行うことが認められています。

#### REFERENCES

- [1] American Fuzzy Lop. http://lcamtuf.coredump.cx/afl/.
- [2] OWASP Top 10 Project. http://http://www.owasp.org.
- [3] XcodeGhostマルウェア。http://www.apple.com/cn/xcodeghost/ #english.
- [4] T. Avgerinos, S. K. Cha, B. L. Tze Hao, and D. Brumley. AEG: Automatic Exploit Generation. In *Proceedings of the 18th Annual Network and Distributed System Security Symposium (NDSS'11)*, 2011.
- [5] T. Avgerinos, A. Rebert, S. K. Cha, and D. Brumley. Veritestingによるシンボリック実行の強化。ページ 1083–1094, 2014年。
- [6] G. Balakrishnan, T. Reps, D. Melski, and T. Teitelbaum. WYSINWYX: What You See Is Not What You eXecute. *Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)*, 4171 LNCS:202–213, 2008.
- [7] T. Bao, J. Burket, M. Woo, R. Turner, and D. Brumley. BYTEWEIGHT: バイナリコード内の関数を認識する手法の学習。*Proceedings of the 23rd USENIX Security Symposium*、ページ845–860, 2014年。
- [8] C. Barrett, L. De Moura, and A. Stump. SMT-COMP: 満足度モジュロ理論コンペティションについて述べています。*Computer Aided Verification* に収録されており、ページは20–23です。Springerより2005年に出版されました。
- [9] S. Bekrar, C. Bekrar, R. Groz, and L. Mounier. スマートファジングのためのテイントベース手法。 *Software Testing, Verification and Validation (ICST), 2012 IEEE Fifth International Conference on*、ページ 818–825。 IEEE, 2012年。
- [10] Bloomberg Business. 病院の医療機器は命を救う一方で、あなたの個人情報をハッキングされる可能性もあります。http://www.bloomberg.com/features/2015-hospital-hack/.
- [11] P. Boonstoppel、C. Cadar、D. Engler。RWset: 制約ベースのテスト生成におけるパス爆発へのアプローチ。*Tools and Algorithms for the Construction and Analysis of Systems*、第4963巻LNCS、351–366ページ。Springer Berlin Heidelberg、2008年。
- [12] C. Cadar, D. Dunbar, and D. Engler. KLEE: 複雑なシステムプログラムに対する高カバレッジなテストの自動生成を支援なしで行うツールです。In *Proceedings of the 8th USENIX Symposium on Operating Systems Design and Implementation (OSDI'08)*, volume 8, pages 209–224, 2008.
- [13] C. Cadar, V. Ganesh, P. M. Pawlowski, D. L. Dill, and D. R. Engler. EXE: Automatically Generating Inputs of Death. In *Proceedings of the 13th ACM Conference on Computer and Communications Security*, pages 322–335, 2006.
- [14] G. Campana. Fuzzgrind: 自動ファズイングツールです。*Actes du 7eme symposium sur la sécurité des technologies de l'information et des communications (SSTIC)*、213–229ページ、2009年。
- [15] D. Caselden、A. Bazhanyuk、M. Payer、L. Szekeres、S. McCamant、および D. Song。「Transformation-aware Exploit Generation using a HI-CFG」。テクニカルレポート、DTIC Document、2013年。
- [16] S. K. Cha, T. Avgerinos, A. Rebert, and D. Brumley. Unleashing Mayhem on Binary Code. In *Proceedings of the IEEE Symposium on Security and Privacy*, pages 380–394, 2012.
- [17] S. K. Cha, M. Woo, and D. Brumley. Program-Adaptive Mutational Fuzzing. In *Proceedings of IEEE Symposium on Security and Privacy*, volume 2015-July, pages 725–741, 2015.
- [18] P. Chen, X. Xing, B. Mao, L. Xie, X. Shen, and X. Yin. x86上でのジャンプ指向プログラミングシェルコードの自動構築。*Proceedings of the 6th ACM Symposium on Information, Computer and Communications Security*、20–29ページ。ACM、2011年。
- [19] V. Chipounov、V. Georgescu、C. Zamfir、G. Candea。Selective Symbolic Execution。*Proceedings of the 5th Workshop on Hot Topics in System Dependability*、2009年。
- [20] V. Chipounov、V. Kuznetsov、G. Candeaによる論文。S2Eは、ソフトウェアシステムのインビボマルチパス解析のためのプラットフォームです。*Proceedings of the sixteenth International Conference on Architectural Support for Programming Languages and Operating Systems*に収録（2011年、265–278ページ）。
- [21] C. Cifuentes と M. Van Emmerik による「Recovery of Jump Table Case Statements from Binary Code」。*Proceedings of the Seventh International Workshop on Program Comprehension* の 192–199 ページに掲載。IEEE、1999 年。
- [22] P. M. Comparetti、G. Wondracek、C. Kruegel、E. Kirdaによる「Prospex: Protocol Specification Extraction」。*Proceedings of the 2009 IEEE Symposium on Security and Privacy*に収録、110–125ページ。IEEE、2009年。
- [23] DAPRA. DARPA Cyber Grand Challenge. http: //www.cybergrandchallenge.com/.
- [24] DARPA. CyberGrandChallenge のサンプル git リポジトリです。https://github.com/CyberGrandChallenge/samples.
- [25] L. De Moura と N. Bjørner による “Z3: An Efficient SMT Solver” は、*Proceedings of the Theory and Practice of Software, 14th International Conference on Tools and Algorithms for the Construction and Analysis of Systems*、TACAS'08/ETAPS'08 の337–340ページ、2008年、Berlin、Heidelberg、Springer-Verlag に掲載されています。
- [26] D. Engler と D. Dunbar. Under-constrained Execution: 自動コード破壊を簡単かつスケーラブルに実現する方法について。*Proceedings of the 2007 international symposium on Software testing and analysis*、ページ 1–4、2007 年。
- [27] ForAllSecure. Mayhem CRSの解放。http: //blog.forallsecure.com/2016/02/09/unleashing-mayhem/.
- [28] P. Godefroid, N. Klarlund, and K. Sen. DART: Directed Automated Random Testing. *Proceedings of the 2005 ACM SIGPLAN Conference on Programming Language Design and Implementation* の第40巻、213–223ページ、2005年。
- [29] P. Godefroid、M. Y. Levin、D. Molnar。SAGE: Whitebox Fuzzing for Security Testing。*ACM Queue*, 10(1):20, 2012年。
- [30] I. Haller、A. Slowinska、M. Neugschwandtner、H. Bosによる論文。*Proceedings of the 22nd USENIX Security Symposium*において、ページ49–64、2013年に発表されました。Dowserはバッファオーバーフローの脆弱性を発見するためのガイド付きファザーです。
- [31] S.-K. Huang, M.-H. Huang, P.-Y. Huang, C.-W. Lai, H.-L. Lu, and W.-M. Leong. CRAX: ソフトウェアクラッシュ解析による自動エクスプロイト生成のための攻撃のモデリングを記号的継続として行う手法。In *Software Security and Reliability (SERE), 2012 IEEE Sixth International Conference on*, pages 78–87. IEEE, 2012.
- [32] Indefinite Studies. リバースエンジニアにとっての停止問題。http://indefinitestudies.org/2010/12/19/the-halting-problem-for-reverseengineers/.
- [33] J. Kinder と H. Veith。「Jakstab: A Static Analysis Platform for Binaries」*Proceedings of the 20th international conference on Computer Aided Verification*、423–427ページ、ベルリン、2008年。Springer-Verlag。
- [34] C. Kruegel, W. Robertson, F. Valeur, and G. Vigna. 難読化されたバイナリの静的逆アセンブル。*Proceedings of the 13th USENIX Security Symposium*、第13巻、18–18ページ、2004年。
- [35] V. Kuznetsov、J. Kinder、S. Bucur、G. Candeaによる「Efficient State Merging in Symbolic Execution」。『2012年ACM SIGPLAN Programming Language Design and Implementation（PLDI'12）会議論文集』、ページ193、2012年。
- [36] J. Lee、T. Avgerinos、D. Brumleyによる論文「TIE: Principled Reverse Engineering of Types in Binary Programs」は、*Proceedings of the 18th Network and Distributed System Security Symposium (NDSS'11)*にて2011年に発表された。
- [37] Y. Li, Z. Su, L. Wang, and X. Li. Steering Symbolic Execution to Less Traveled Paths. In *Proceedings of the 2013 ACM SIGPLAN international conference on Object Oriented Programming Systems Languages & Applications*, pages 19–32, 2013.
- [38] B. P. Miller, L. Fredriksen, and B. So. UNIXユーティリティの信頼性に関する実証的研究。*Communications of the ACM*, 33(12):32–44, 1990年.
- [39] C. Miller. コードカバレッジによるファジングの事例解説. https: //fuzzinginfo.files.wordpress.com/2012/05/cmiller toorcon2007.pdf.
- [40] M. Muller-Olm と H. Seidl による「線形代数による精密な手続き間解析」。*Proceedings of the 31st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages*、第39巻、330–341ページ、2004年。
- [41] J. A. Navas, P. Schachte, H. Søndergaard, and P. J. Stuckey. Signedness-Agnostic Program Analysis: Precise Integer Bounds for Low-Level Code. In *Lecture Notes in Computer Science (including*

*subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)*、第7705巻LNCS、115–130ページ、2012年。

- [42] M. Neugschwandtner、P. Milani Comparetti、I. Haller、および H. Bos。「The BORG: Nanoprobing Binaries for Buffer Overreads」。*Proceedings of the 5th ACM Conference on Data and Application Security and Privacy*、87–97ページ。ACM、2015年。
- [43] J. Newsome、D. Brumley、J. Franklin、D. Song。「Replayer: Automatic Protocol Replay by Binary Analysis」。*Proceedings of the ACM Conference on Computer and Communications Security*、pp. 311–321、2006年。
- [44] F. Perez と B. E. Granger. IPython: 対話型科学計算のためのシステム。*Computing in Science and Engineering*, 9(3):21–29, 2007年5月。http://ipython.org.
- [45] J. Pewny、B. Garmany、R. Gawlik、C. Rossow、およびT. Holzによる「Crossarchitecture bug search in binary executables」。*Proceedings of the 2015 IEEE Symposium on Security and Privacy*、2015年7月号、709–724ページ、2015年。
- [46] D. a. Ramos と D. Engler による「Under-Constrained Symbolic Execution: Correctness Checking for Real Code」。*Proceedings of the 24th USENIX Security Symposium* に掲載、2015年、49–64ページ。
- [47] P. Saxena, P. Poosankam, S. McCamant, and D. Song. Loop-Extended Symbolic Execution on Binary Programs. In *Proceedings of the 18th International Symposium on Software Testing and Analysis*, page 225, 2009.
- [48] E. Schwartz、T. Avgerinos、D. Brumley。Q: エクスプロイトのハードニングを簡単にする方法。*Proceedings of the 20th USENIX Security Symposium*、第8巻、25ページ、2011年。
- [49] E. J. Schwartz, T. Avgerinos, and D. Brumley. All You Ever Wanted to Know About Dynamic Taint Analysis and Forward Symbolic Execution (but Might Have Been Afraid to Ask). In *Proceedings of the 2010 IEEE Symposium on Security and Privacy*, SP '10, pages 317–331, Washington, DC, USA, 2010. IEEE Computer Society.
- [50] B. Schwarz、S. Debray、G. Andrews による「Disassembly of Executable Code Revisited」。*Proceedings of Ninth working conference on Reverse engineering, 2002* に収録、ページ 45–54。IEEE、2002年。
- [51] D. K. Sean Heelan. *Automatic Generation of Control Flow Hijacking Exploits for Software Vulnerabilities*. 博士論文、University of Oxford computing laboratory、2009年9月。
- [52] H. Shacham. The Geometry of Innocent Flesh on the Bone: Returninto-libc without Function Calls (on the x86). In *Proceedings of the 14th ACM Conference on Computer and Communications Security*, volume 22, pages 552–561, 2007.
- [53] Y. Shoshitaishvili, R. Wang, C. Hauser, C. Kruegel, and G. Vigna. Firmalice - バイナリファームウェアにおける認証バイパス脆弱性の自動検出。*Proceedings of Network and Distributed System Security Symposium* の中で、2015年2月、ページ8–11。Internet Society。
- [54] N. Stephens、J. Grosen、C. Salls、A. Dutcher、R. Wang、J. Corbetta、Y. Shoshitaishvili、C. Kruegel、およびG. Vigna。「Driller: Augmenting Fuzzing Through Selective Symbolic Execution」。*Proceedings of the Network and Distributed System Security Symposium*, 2016年。
- [55] L. Szekeres、M. Payer、T. Wei、D. SongによるSoK: Eternal War in Memory。*Proceedings of the IEEE Symposium on Security and Privacy*に掲載、ページ48–62、2013年。
- [56] K. Thompson. Reflections on Trusting Trust. *Communications of the ACM*, 27(8):761–763, Aug. 1984.
- [57] Trail of Bits Blog. How We Fared in the Cyber Grand Challenge. http://blog.trailofbits.com/2015/07/15/how-we-fared-in-the-cybergrand-challenge/.
- [58] J. Troger と C. Cifuentes による「Analysis of Virtual Method Invocation for Binary Translation」。*Proceedings of Ninth Working Conference on Reverse Engineering, 2002* に掲載（ページ65–74、IEEE、2002年）。
- [59] L. Xu、F. Sun、Z. Suによる「Constructing Precise Control Flow Graphs from Binaries」。*University of California, Davis, Tech. Rep*, 2009年。
- [60] F. Yamaguchi, N. Golde, D. Arp, and K. Rieck. コードプロパティグラフを用いた脆弱性のモデリングおよび発見について述べています。*Proceedings of the 2014 IEEE Symposium on Security and Privacy* に掲載されており、2014年、ページは590–604です。
- [61] F. Yamaguchi, A. Maier, H. Gascon, および K. Rieck. Taintスタイルの脆弱性に対する自動的な探索パターン推論について述べています。*Proceedings of the 2015 IEEE Symposium on Security and Privacy*（2015年7月号）の797～812ページに掲載されています。
- [62] M. Zalwski. Bunny the Fuzzer Documentation. http: //code.google.com/p/bunny-the-fuzzer/wiki/BunnyDoc.
