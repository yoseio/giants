# (State of) The Art of War: Offensive Techniques in Binary Analysis

Yan Shoshitaishvili、Ruoyu Wang、Christopher Salls、Nick Stephens、Mario Polino、Andrew Dutcher、John Grosen、Siji Feng、Christophe Hauser、Christopher Kruegel、Giovanni Vigna UC Santa Barbara

{yans,fish,salls,stephens,mario,dutcher,jmg,slipper,christophe,chris,vigna}@cs.ucsb.edu

*Abstract*—バイナリコードにおける脆弱性の発見と悪用は、困難な作業です。データ構造や制御構造に関する高レベルで意味的に豊かな情報が欠如しているため、プログラムの特性解析を大規模に行うのがより難しくなります。しかし、バイナリ解析の重要性は高まっています。多くの場合、バイナリ解析は実際に*実行される*コードについて、その特性を証明（または反証）する唯一の手法です。

本論文では、過去に提案された数々の解析手法を実装したバイナリ解析フレームワークを紹介します。これらの手法を体系的に実装することで、他の研究者がそれらを組み合わせたり、新しいアプローチを開発したりできるようにしています。さらに、これらの手法を統合的なフレームワーク上で実装することにより、各アプローチを直接比較し、それぞれの利点と欠点を特定することが可能です。本論文に含まれる評価は、バイナリ脆弱性解析手法の有効性を評価するためにDARPAによって最近作成されたデータセットを使用して行われています。

私たちのフレームワークはオープンソース化されており、セキュリティコミュニティで利用可能です。

# I. INTRODUCTION

インタプリタ言語やWorld Wide Webの普及にもかかわらず、バイナリ解析はコンピュータセキュリティにおいて依然として非常に重要な話題となっています。これにはいくつかの理由があります。まず、インタプリタ言語はバイナリプログラムによって解釈されるか、またはJust-In-Time (JIT) コンパイルによってバイナリコードに変換されます。次に、「コア」OSの構成要素やパフォーマンスが重要なアプリケーションは、依然として（通常はCやC++などの）バイナリコードにコンパイルされる言語で記述されています。さらに、Internet of Thingsの普及によって一般的に非常にリソースが限られたデバイスが増えています。これらのデバイスのファームウェアは、インタプリタやJust-In-Timeコンパイルに費やす余裕がなく、やはり（たいていCで）バイナリにコンパイルされる言語で書かれる傾向があります。

残念ながら、多くの低水準言語はセキュリティ保証がほとんどなく、そのため脆弱性が生じやすくなっています。例えば、バッファオーバーフローは、このような脆弱性を軽減する技術の開発が進められているにもかかわらず、依然として最も一般的なソフトウェアの欠陥の一つとして残っています。さらに悪いことに、「メモリ破損脆弱性」のより広いカテゴリのほとんども、安全でない言語の使用に起因しており、最も一般的な脆弱性のかなりの部分を占めています[2]。この問題は汎用コンピュータのソフトウェアに限ったことではなく、スマートロックやペースメーカー、自動車など、さまざまな機器でリモートから悪用されうる脆弱性が発見されています[10]。

もう一つ重要な点は、コンパイラやツールチェーンが必ずしもバグがないわけではないということです。プログラムのソースコードを解析して証明された特性が、同じプログラムをコンパイルした後には成り立たない場合があります [56]。これは実際に起こっており、最近では Xcode の悪意あるバージョンである Xcode Ghost [3] が、コンパイル時に悪意あるコードを挿入することで、40以上の人気 iOS アプリケーションに密かに感染し、数百万人のユーザーのデバイスを危険に晒しました。こうした脆弱性は深刻な現実世界での影響をもたらし、それらが悪用される前に発見することが極めて重要です。このため、セキュリティ研究コミュニティは、バイナリプログラムの脆弱性を特定するための解析技術の開発に多大な努力を注いできました [55]。このような ”攻撃的” （解析対象のアプリケーションへの“攻撃”を見つけるため）解析技術は、用いられるアプローチや標的とする脆弱性も多岐にわたりますが、2つの大きな課題を抱えています。

まず、多くのバイナリアナリシス手法の実装は、研究用のプロトタイプとして開発され、そのまま終わってしまうことがよくあります。このような場合、その貢献のために費やされた多くの努力が無駄になり、今後の研究者たちはこれらのアプローチに基づく作業を実装する際に、しばしば一からやり直さなければなりません。この初期コストが進歩を妨げてしまいます。過去の技術を再実装するのに費やす一週間は、新しい解決策の開発に充てられるはずだった一週間を失うことになるのです。

第二に、これらのシステムを再現するために必要な作業量や、それらが一般公開されていないことが多いという事情から、その結果を再現するのは現実的ではなくなります。そのため、個々のバイナリ解析手法が他の手法と比べてどれほど*適用可能*かが不明確になります。これに加えて、現代のオペレーティングシステムの本質的な複雑さや、アプリケーションがその環境とどのように相互作用するかを正確かつ一貫してモデル化する難しさが共通の比較基盤を築くのを非常に難しくしています。比較が行われている場合でも、異なる実装の詳細や異なる評価データセットを持つシステム同士が比較される傾向があります。

最初の課題を緩和するために、私たちは angr というバイナリ解析フレームワークを作成しました。これは、文献にある最先端のバイナリ解析技術の多くを統合したものです。この取り組みの目的は、分野を体系化し、現行の研究で提案されている効果的な技術を、アクセスしやすく、オープンで使いやすい形で実装することで、次世代のバイナリ解析技術の発展を促進し、それらを簡単に比較できるようにすることでした。angr は次の機能を提供します。

© 2016, Yan Shoshitaishvili. IEEE にライセンスされています。DOI 10.1109/SP.2016.17

![](_page_0_Picture_16.jpeg)

さまざまな種類の分析にとって基礎となる要素であり、静的手法と動的手法の両方を用いることで、提案された研究アプローチを容易に実装できるようになり、それぞれの効果を比較することが可能となります。さらに、これらの基礎要素は、分析手法を*組み合わせる*ことによって、それぞれの強みを活かすことを可能にします。

過去一年の間に、第二の問題に対する解決策も導入されました。これは、分析手法やツールを比較し、研究の再現性を意識したものです。具体的には、DARPAがCyber Grand Challengeを開催しました。この大会は、自動バイナリ解析、脆弱性発掘、エクスプロイト生成、ソフトウェア修正の現状を探るために設計されています。この競技の一環として、DARPAは自動解析システムに現実的な課題を提示することを目的としたアプリケーションのコーパスを作成し、さらにこれらの課題に対する*グラウンドトゥルース*（ラベル付けされた脆弱性やエクスプロイト）も用意しました。このバイナリのデータセットは、最近提案されたさまざまな解析手法の相対的な有効性を評価するのに最適なテストスイートとなっています。さらに、DARPA CGCの予選イベントでは、世界中のチームが自動バイナリ解析システムを用いてこれらのバイナリに対して攻撃・防御を行いました。これらの結果は公開されており、既存の攻撃的手法が競技者たちの最高レベルの技術とどう比較されるかを検証する機会となっています。

私たちの目標は、最新の攻撃手法の相対的な効果を理解することにあり、そのためにそれらの手法を自分たちのバイナリ解析システムに実装します。本論文では、次世代のバイナリ解析エンジンであるangrの実装について詳しく述べます。私たちは、これらの手法を用いて開発した複数の攻撃的解析（具体的には、現在の文献で述べられているアプローチを再現したもの）を提示し、脆弱性の発見、エクスプロイトのリプレイ、自動エクスプロイト生成、ROPシェルコードのコンパイル、エクスプロイトの耐性強化といった分野で結果を再現します。また、これらの手法を組み合わせて能力を拡張することで克服した課題や達成した改善点についても説明します。共通の解析エンジン上にこれらの手法を実装することにより、手法間の理論的な違いから生じる効果の差異を、基礎となる解析エンジンの実装の違いではなく、純粋に手法の違いとして検証できます。これによって、DARPAが提供するデータセット上で、これらのアプローチの比較評価を行うことができました。

要約すると、私たちは次のような貢献を行います。

- 1) 私たちは、多くの既存の攻撃的バイナリ解析手法を単一かつ一貫したフレームワーク内で再現し、現在の攻撃的バイナリ解析技術がどの程度効果的であるかを相対的に理解できるようにしています。
- 2) 私たちは、多様なバイナリアナリシス手法を組み合わせて大規模に適用する際に生じる困難（およびそれらへの解決策）を示します。
- 3) 私たちは、バイナリコード解析の将来の研究のために、私たちのフレームワークであるangrをオープンソース化します。

上位7チームはそれぞれ75万ドルの賞金を獲得しました。このような動機付けにより、各チームは利用可能な中で最良の分析を提出したと考えられます。

# II. AUTOMATED BINARY ANALYSIS

研究者たちは長年にわたり、自動バイナリアナリシス技術の実現に向けて努力してきました。しかし、この分野における近年の進展にもかかわらず、そのようなシステムを実際の環境で開発・運用することは依然として困難です。これは、手法によっては現実世界のソフトウェアに対する自動解析を行うために克服すべき重大な制約が存在するためです。このセクションでは、自動解析の課題に触れ、DARPA Cyber Grand Challenge コンテストが異なる解析アプローチを比較する上で有意義な方法を提供できる理由について論じます。

# *A. Trade-offs*

なぜバイナリ解析が困難であるかは理解しやすいでしょう。「クラッシュするか？」という問いは、「停止するか？」という問いに似ており、このような解析はいずれも停止問題にすぐに直面します [32]。プログラム解析、特に攻撃的なバイナリ解析は、実現可能性を保つために注意深くバランスを取った理論的なトレードオフに導かれる傾向があります。このようなトレードオフが必要となる主な領域は二つあります。

リプレイ可能性。バグにはさまざまな種類があります。システムで行われたトレードオフによっては、特定の解析によって発見されたバグが*リプレイ可能*でない場合もあります。これは、解析が動作する*範囲*に関係しています。ある解析手法はアプリケーション全体を最初から実行するため、脆弱性を引き起こすために*正確に*何をする必要があるかを推論できます。一方、他のシステムはアプリケーションの個々の部分だけを解析します。そのため、特定のモジュールにバグを発見することはあっても、どのようにそのモジュールの実行を*引き起こす*かまでは推論できず、結果としてクラッシュを自動的に*リプレイ*することもできません。

セマンティックな洞察。一部の解析手法には、プログラムについて意味的に有意義な方法で推論する能力が欠けています。たとえば、動的解析はアプリケーションによって実行されたコードを追跡することはできても、*なぜ*それが実行されたのかや、*どの部分の*入力がアプリケーションにその特定の動作をさせたのかを理解することはできません。一方で、特定のプログラム挙動の原因となった入力バイトを特定できるようなシンボリック解析は、より高い意味理解を持っていると言えます。

入力のリプレイ性やセマンティックな洞察を提供するためには、解析手法はいくつかのトレードオフを行う必要があります。たとえば、リプレイ性が高い場合、カバレッジは低くなります。これは直感的に理解できます。というのも、リプレイ可能な入力を生成する解析手法は、解析したいコードに到達する方法を理解していなければならず、リプレイ性を考慮しない解析手法ほど多くのコードを解析することができないためです。一方で、バグの再現を優先しない解析手法は、バグを検証するためのトリガー入力をリプレイできないため、*偽陽性*（実際には脆弱性ではない欠陥検出）が多くなりがちです。リプレイ可能な入力がない場合、これらの偽陽性はヒューリスティックによってフィルタリングされる必要があり、その結果として偽陰性も発生し得ます。

同様に、解析対象のプログラムについて意味的な洞察を得るためには、解析は大量のデータを保存し処理する必要があります。例えば、意味的な洞察を持つ動的解析は、プログラムの特定の分岐が実行されるために成り立つべき条件を保存する場合があります。一方で、静的解析では、選択されたデータ領域によって意味的な洞察の度合いが調整されます。より単純なデータ領域（例えば、実際の値ではなく*範囲*を追跡する場合など）は、意味的な洞察が少なくなります。

再現性と高いセマンティックな理解の両方を試みる解析は、スケーラビリティの問題に直面します。アプリケーション全体のセマンティック情報を、エントリーポイントからそれが取りうる全てのアクションに至るまで保持するには、あらゆる条件下でプログラムを実行するのと本質的に同等の処理能力が必要となります。このような解析はスケーラブルではなく、適用可能にするためには情報を捨て、*完全性*（すなわち、すべての潜在的な脆弱性が発見されるという保証）を犠牲にしなければなりません。

これらの根本的な課題とは別に、実装上の課題も存在します。その中で最大のものは*環境モデル*です。高度な意味的理解を伴う解析は、アプリケーションが環境とどのように相互作用するかをモデル化する必要があります。現代のオペレーティングシステムにおいて、このような相互作用は非常に複雑です。たとえば、Linuxの最新バージョンには三百以上のシステムコールが含まれており、解析システムが完全であるためには、それらすべての影響をモデル化しなければなりません。

Example. バイナリ解析のさまざまな課題を示すために、Listing 1 では複数の脆弱性を含むプログラムの具体的な例を示します。明確さと紙面の都合上、この例は簡略化されており、今後本文で議論するアイデアを読者に紹介することのみを目的としています。

3つのmemcpy呼び出しを見てみましょう。10行目と30行目のものはバッファオーバーフローを引き起こしますが、16行目のものはそうなりません。しかし、どれだけ多くの情報を追跡するかによっては、静的解析手法は3つすべてのmemcpy呼び出しを潜在的なバグとして報告するかもしれません。16行目の呼び出しも含まれるのは、バッファオーバーフローが発生しないと判断するための情報が解析には存在しないためです。さらに、静的解析からのレポートにはこれらのバグの場所は含まれますが、それを引き起こす入力は提示されません。

動的手法であるファジングの利点は、発見されたバグを引き起こす実際の入力を生成できることです。一方、単純なファジング手法は、たいてい浅いバグしか発見できず、精密に作られた入力を必要とするコードを通過することができません。リスト1では、動的手法は10行目のバグを見つけるのが困難です。これは、その条件を満たすための特定の入力が必要だからです。しかし、30行目のオーバーフローはランダムなテストによって引き起こされる可能性があるため、ファジング手法はこのバグを引き起こす入力を見つけることができるはずです。

10行目のバグを見つけるためには、抽象的なデータモデルを導入して、多くの入力を一度に考察する方法がある。その一つのアプローチがDynamic Symbolic Execution (DSE) である。しかし、動的シンボリック技法は強力だが、「パス爆発問題」に悩まされる。これは分岐ごとにパスの数が指数関数的に増加し、すぐに扱いきれなくなるという問題である。シンボリック実行では、10行目のバグを検出し、制約ソルバーを使ってその入力も生成できる。また、16行目のmemcpyがオーバーフローを起こさないことも証明できるはずだ。しかしながら、30行目のバグについては、おそらく実行時に見つけることはできない。なぜなら、バグを引き起こさないパスがあまりにも多いからである。

```
1 int main(void) {
2 char buf[32];
4 char *data = read_string();
5 unsigned int magic = read_number();
7 // difficult check for fuzzing
8 if (magic == 0x31337987) {
9 // buffer overflow
10 memcpy(buf, data, 100);
11 }
13 if (magic < 100 && magic % 15 == 2 &&
14 magic % 11 == 6) {
15 // Only solution is 17; safe
16 memcpy(buf, data, magic);
17 }
19 // Symbolic execution will suffer from
20 // path explosion
21 int count = 0;
22 for (int i = 0; i < 100; i++) {
23 if (data[i] == 'Z') {
24 count++;
25 }
26 }
28 if (count >= 8 && count <= 16) {
29 // buffer overflow
30 memcpy(buf, data, count*20);
31 }
33 return 0;
34 }
```
リスト1: 異なる手法によって異なるバグが報告される例。

# *B. The DARPA Cyber Grand Challenge*

2013年10月、DARPAはDARPA Cyber Grand Challenge [23] を発表しました。他分野（ロボティクスや自律走行車など）のDARPA Grand Challengeと同様に、CGCでは世界中から集まったチームが、すべて自律的なプログラムとして競い合います。Cyber Grand Challengeにおける参加者の目標はシンプルです。提供されたソフトウェアの脆弱性を自動的に特定し、悪用し、修正するシステムを作り上げなければなりません。賞金総額は数百万ドルにも及びました。CGC予選イベント（2015年6月開催）を完了した上位7チームにはそれぞれ750,000ドルが授与され、CGC本選イベント（2016年8月開催）の上位3チームには、それぞれ2,000,000ドル、1,000,000ドル、750,000ドルが贈られます。

Cyber Grand Challenge の主催者たちは、自動バイナリアナリシスシステム向けの競技を設計するにあたって、多くの工夫を重ねています。たとえば、*environment model* の課題に対応するために、CGC 専用の新しい OS を作成しました。それが DECREE OS です。DECREE は非常にシンプルなオペレーティングシステムで、システムコールは7種類しかありません。transmit、receive、waitfd はファイルディスクリプタを通じてデータの送信・受信・待機を行うためのもので、random はランダムなデータを生成するためのものです。

I'm sorry, but there is no paragraph provided for me to translate. If you provide the Markdown paragraph, I will gladly translate it into natural Japanese as per your instructions.

Please provide the Markdown paragraph you would like me to translate.

I'm sorry, but there is no paragraph provided to translate. Please provide the Markdown paragraph you would like me to translate into Japanese.

I'm sorry, but there is no paragraph to translate—only the number "18" was provided. Please provide the Markdown paragraph you would like me to translate.

There is no paragraph to translate in your message, only the number "27." If you provide a paragraph, I can translate it for you.

I'm sorry, but there is no paragraph to translate in your message. If you provide the Markdown paragraph you'd like translated, I'll be happy to help!

メモリ管理のためにallocateとdeallocateを使用し、終了するにはterminateを使います。

単純な環境モデルにもかかわらず、CGCのためにDARPAが提供したバイナリは非常に多様な複雑さを持っています。それらは4キロバイトから10メガバイトのサイズにわたり、単純なエコーサーバからウェブサーバ、画像処理ライブラリまで、さまざまな機能を実装しています。DARPAは、これまでのコンペティションで使用されたすべてのバイナリを、概念実証用のエクスプロイトや脆弱性についての解説とともにオープンソース化しています [24]。

シンプルな環境モデルによって、大規模にバイナリアナリシス手法を正確に実装し評価することが可能になるため、本論文の比較評価にはDARPA CGCのサンプルをデータセットとして使用します。

#### *C. Comparative Analysis of CGC Binaries*

攻撃的なバイナリ解析では、処理対象となるアプリケーションを理解するために、さまざまな基礎的手法が用いられます。たとえば、異なる*ドメイン*でデータを分析したり、テスト対象のアプリケーションと異なるレベルでやり取りを行ったりする場合があります。次の2つのセクションでは、現状の最先端技術を概観し、本論文で詳細に評価するいくつかの解析手法を選定します。ここでは、バイナリソフトウェアの脆弱性を特定・悪用することを目的とした解析（たとえば、シンボリック実行を用いたメモリ安全性違反の特定）に特に焦点を当てています。その一方で、これらの手法の基礎となっているより一般的なバイナリ解析技術（この場合はシンボリック実行そのもの）は対象外とします。

#### III. BACKGROUND: STATIC VULNERABILITY DISCOVERY

静的手法は、プログラムを実行することなくその内容について推論します。通常、プログラムは *抽象ドメイン* 上で解釈されます。ビットの1や0が格納されているメモリ位置には、他の抽象的な実体が入っている場合もあります（よくある例では整数ですが、下で説明するように、さらに抽象的な構成要素を含むこともあります）。さらに、プログラムの構成要素として、メモリのレイアウトや実行経路自体も抽象化される場合があります。

ここでは、静的解析を2つのパラダイムに分けます。すなわち、プログラムの特性をグラフ（たとえば*control-flow graph*）としてモデル化するものと、データ自体をモデル化するものです。

静的脆弱性識別手法には、セクションII-Aで述べたトレードオフに関連する2つの主な欠点があります。第一に、結果が*再現可能*ではないことです。静的解析による検出は、発見された脆弱性を*どのように*誘発するかの情報が得られないため、手作業で検証する必要があります。第二に、これらの解析はより単純なデータ領域で動作する傾向があり、*意味的な洞察*が低下します。要するに、これらは過大評価しがちです。すなわち、特定のプログラム特性（たとえば脆弱性）が*存在しない*ことについては確信を持って論じることができる一方で、脆弱性の*存在*に関する主張では高い誤検知率に悩まされます。

# *A. Recovering Control Flow*

*control-flow graph*（CFG）の復元は、ノードが命令の基本ブロックであり、それらの間のエッジが可能な制御フローの遷移を表すものです。これは、ほぼすべての静的な脆弱性発見技術において前提となる作業です。

制御フロー回復については、文献 [21], [33], [34], [50], [58], [59] で広く議論されています。CFG回復は、再帰的なアルゴリズムとして実装されており、まず基本ブロック（例えばBa）を逆アセンブルして解析し、その可能な*出口*（つまり、後続の基本ブロックであるB<sup>b</sup>やBcなど）を特定してCFGに追加します（まだ追加されていない場合）。そして、B<sup>a</sup>からB<sup>b</sup>およびBcへの接続を構築し、B<sup>b</sup>やB<sup>c</sup>について再帰的に解析を繰り返し、新たな出口が見つからなくなるまで続けます。CFG回復には根本的な課題が一つあります。それは間接ジャンプです。間接ジャンプは、バイナリがレジスタやメモリ位置に格納された値をターゲットとして制御フローを移す場合に発生します。*直接*ジャンプとは異なり、直接ジャンプではターゲットが命令自体に符号化されているため簡単に解決できますが、間接ジャンプのターゲットは様々な要因によって変化する可能性があります。具体的には、間接ジャンプはいくつかのカテゴリに分類されます。

- 計算によるもの。計算によるジャンプのターゲットは、コードで指定された計算をアプリケーションが実行することによって決定されます。この計算は、他のレジスタやメモリ内の値にさらに依存する場合があります。よくある例としてはジャンプテーブルがあります。アプリケーションはレジスタやメモリ内の値を使用してメモリ上に格納されたジャンプテーブルへのインデックスを決定し、そのインデックスからターゲットアドレスを読み取り、そこにジャンプします。
- コンテキスト依存。間接ジャンプはアプリケーションのコンテキストによって決まる場合があります。よくある例は、標準Cライブラリのqsort()です。この関数は値を比較するために*コールバック*を受け取ります。そのため、qsort()内部の基本ブロックのジャンプ先の一部は呼び出し元によって左右されます。なぜなら、呼び出し元がコールバック関数を提供するからです。
- オブジェクト感度。コンテキスト感度の特別なケースとして、オブジェクト感度があります。オブジェクト指向言語では、オブジェクトの多態性により仮想関数の使用が求められます。これはしばしば、関数ポインタの*仮想テーブル*として実装され、実行時にジャンプ先を決定するために参照されます。したがって、ジャンプ先は呼び出し元から関数に渡されるオブジェクトの型に依存します。

さまざまな種類の間接ジャンプに対応するために、異なる手法が設計されており、そのいくつかの実装についてはセクションVIIで議論します。最終的に、CFG復元の目的は、できるだけ多くのこれらの間接ジャンプのターゲットを*解決*し、CFGを作成することです。ある間接ジャンプは、ある条件下でジャンプテーブル内のすべてのアドレスなど、*値の集合*に解決される場合があり、この集合はオブジェクト感度やコンテキスト感度によって変化することがあります。ジャンプターゲットの解決度合いによって、CFG復元解析には2つの特性があります。

健全性。CFGリカバリ技術が*健全*であるとは、すべての潜在的な制御フロー遷移が生成されたグラフに表現されている場合を指します。つまり、間接ジャンプが実際に到達可能なアドレスの*部分集合*にしか解決されない場合、グラフの健全性は低下します。もし基本ブロックの潜在的なターゲットが見落とされると、CFGリカバリアルゴリズムによってそのブロックが発見されない可能性があり、そのブロックからの直接ジャンプや間接ジャンプもすべて見逃されてしまいます。これは累積的な影響を与えます。間接ジャンプの解決に失敗すると、グラフの完全性が大きく損なわれる可能性があります。健全性は、バイナリ内で間接ジャンプのターゲットを特定する際の*真陽性*率と考えることができます。

Completeness（完全性）。完全なCFGリカバリは、すべてのエッジが実際に可能な制御フローの遷移を表しているCFGを構築します。CFG解析が*completeness*（完全性）を重視しすぎると、実際には存在しえないエッジが含まれてしまう可能性があります。完全性は、間接ジャンプターゲット特定の*false positive*（偽陽性）率の逆と考えることができます。

空のグラフを生成するCFGリカバリ解析は*完全*であるとみなされ、すべての命令が他のすべての命令を指すグラフを生成する解析は*健全*であると考えられます。<sup>2</sup> 理想的にはこの中間が望ましいですが、スケーラブルなアルゴリズムでそれを実現するのは困難です。そのため、異なる解析手法ごとにこれら二つの間で異なる妥協点が必要になります。

制御フローグラフに関するさらなる困難の一つは、*コードカバレッジ*、すなわち制御フローグラフによってどれだけ多くのコードが把握されているかという指標を正確に測定することです。これはしばしば、いかなるジャンプからも到達できない*デッドコード*が存在することによって複雑になります。

# *B. Vulnerability Detection with Flow Modeling*

プログラムのいくつかの脆弱性は、プログラム特性のグラフを分析することで発見できます。

グラフベースの脆弱性発見。プログラムのプロパティグラフ（たとえば、コントロールフローグラフ、データフローグラフ、コントロールディペンデンスグラフなど）は、ソフトウェア内の脆弱性を特定するために利用できる。当初はソースコードに対して適用されていたが [60], [61]、関連する手法はその後バイナリにも拡張された [45]。これらの手法は、コントロールフローグラフやデータ依存性グラフにおけるノードの集合として表されるバグのモデルを構築し、そのモデルがアプリケーション内に現れる箇所を特定することに依存している。しかし、このような手法は脆弱なコードのコピーを検索することに特化しており、すでに存在している脆弱性についての先行知識を活用できる。一方で、本論文の焦点は、全く新しい脆弱性の発見にある。

# *C. Vulnerability Detection with Data Modeling*

静的解析は、アプリケーションが操作するデータの抽象化に基づいて推論を行うこともできます。

Value-Set Analysis. 静的解析手法の一つとして一般的なのが *Value-Set Analysis* (VSA) [6] です。大まかに言えば、VSAは任意の時点におけるプログラム状態（すなわち、メモリやレジスタ内の値）をきつく過大評価して特定しようとします。

2Xu らは、CFG の健全性と完全性を逆の方法で定義しており、空のグラフが健全であり、完全なグラフが完全であるとしています [59]。本論文では、セクション III-A の定義に従います。

このプログラムは、間接ジャンプの可能なターゲットやメモリ書き込み操作の可能なターゲットを理解するために利用できます。これらの近似は精度が十分でないという欠点がありますが、*健全性*があります。つまり、過大評価することはあっても、決して過小評価することはありません。

メモリの読み書きのアクセスパターンを近似的に解析することで、バイナリ内の変数やバッファの位置を特定することができます。一度これが行われると、復元された変数やバッファの位置をさらに解析して「重複している」バッファを見つけることができます。このような重複バッファは、例えばバッファオーバーフロー脆弱性によって引き起こされる可能性があり、各検出は潜在的な脆弱性となります。

# IV.

# BACKGROUND: DYNAMIC VULNERABILITY DISCOVERY

動的アプローチは、特定の入力が与えられた際に、実際またはエミュレートされた環境でプログラムの実行を調査する解析手法です。このセクションでは、基盤となる一般的なバイナリ解析技術ではなく、脆弱性を特定するために用いられる動的手法に特に焦点を当てます。

動的手法は大きく2つのカテゴリーに分けられます：具体的実行と、記号的実行です。これらの手法は非常に*再現性の高い*入力を生成しますが、*意味的な洞察*の面では違いがあります。

# *A. Dynamic Concrete Execution*

Dynamic concrete executionとは、最小限の計測が施された環境でプログラムを実行するという概念です。プログラムは通常通り動作し、通常扱っているものと同じ*ドメイン*のデータ（つまり1と0）上で処理を行います。これらの解析は通常、単一の経路レベル（すなわち「この特定の入力が与えられたとき、プログラムはどの経路をたどったか」）で推論を行います。そのため、dynamic concrete executionにはユーザーが*テストケース*を用意する必要があります。これは、データセットが大きい場合や未知の場合（今回のようなケース）には、そのようなテストケースを簡単には用意できないという問題につながります。

*1) Fuzzing:* 脆弱性発見における動的具体実行の最も関連性の高い応用はFuzzingです。Fuzzingは、アプリケーションに対して不正に形成された入力を与え、クラッシュを引き起こすことを試みる動的技法です。当初、このような入力はハードコーディングされた規則によって生成され、実行状況をあまり詳細に監視することなくアプリケーションに与えられていました [38]。特定の入力を与えた際にアプリケーションがクラッシュした場合、その入力がバグを引き起こしたと考えられます。そうでなければ、その入力はさらにランダムに変更されていきます。残念ながら、Fuzzerには*テストケース*の要件があります。入念に設計されたテストケースがなければ、Fuzzerはプログラムのごく表面的な機能以外を十分に試すことが難しくなります。

カバレッジベースのファジング。慎重に作成されたテストケースの必要性は、コードカバレッジベースのファジングの登場によって部分的に軽減されました。コードカバレッジベースのファザーは、ターゲットアプリケーション内で実行されるコード量を最大化するような入力を生成しようとします。これは、より多くのコードが実行されるほど、脆弱なコードが実行される可能性が高くなるという発想に基づいています。American Fuzzy Lop (AFL) は、数多くの最近の脆弱性を発見した最先端のファザーであり、コードカバレッジ指標のみをその指針としています。また、AFLによる脆弱性発見の成功が、近年ファジングへの関心を高めるきっかけとなりました。

カバレッジベースのファジングは、ターゲットアプリケーションに対するセマンティックな洞察が不足しているという問題があります。これはつまり、特定のコードがまだ実行されていないことは検出できても、そのコードを実行させるために入力のどの部分を変更すべきかを理解できない、ということです。

Taintベースのファジング。ファジングを改善する別のアプローチとして、*taintベース*のファザーの開発がある[9], [62]。これらのファザーは、アプリケーションが入力をどのように処理するかを分析し、将来の実行時に入力のどの部分を修正するかを理解する。これらのファザーの中には、taintトラッキングとデータ依存性復元などの静的手法を組み合わせるものもある[30], [42]。他の手法では、ファジングのカバレッジ向上のためにプロトコル解析の研究成果を取り入れている[22]。

汚染追跡型ファザーは、入力のどの部分を変異させればプログラム内の特定の経路を実行できるかは理解できますが、その入力を*どのように*変異させればよいかについては依然として分かりません。

*2) Dynamic Symbolic Execution:* シンボリック手法は、静的解析と動的解析のギャップを埋め、ファジングの持つ限定的なセマンティック理解の課題に対処するソリューションを提供します。Dynamic symbolic execution は、symbolic execution のサブセットであり、ある意味で動的な手法で、プログラムをエミュレートされた環境で実行します。ただし、この実行は*シンボリック変数*の*抽象*領域で行われます。こうしたシステムはアプリケーションをエミュレートする際、レジスタやメモリの状態、そしてそれらの変数に対する*制約*をプログラム実行中に追跡します。条件分岐に到達するたびに、実行が分岐して*両方*のパスをたどり、分岐が実際に行われたパスにはその分岐条件を、分岐しなかったパスにはその分岐条件の逆をパスの制約として保存します [49]。

ファジングとは異なり、動的シンボリック実行は対象アプリケーションに対して非常に高い意味的洞察を持っています。この手法では、蓄積されたパス制約を利用して、分析が関心を持つ条件が実行中のパスのいずれかで発生した場合に、アプリケーションに適切な入力を遡って生成することで、特定のプログラム状態を*どのように*引き起こすかについて推論できます。これにより、ソフトウェアのバグ特定に非常に強力なツールとなっており、その結果として動的シンボリック実行は非常に活発な研究分野となっています。

クラシックな動的シンボリック実行。動的シンボリック実行は、ソフトウェアの脆弱性を直接発見するために利用することができる。もともとはソースコードのテストに適用されていたが [12], [13]、Mayhem [16] や S2E [19] によってバイナリコードにも拡張された。これらのエンジンは、パス探索を実行し、攻撃者による入力で命令ポインタが書き換えられるなどの脆弱な状態が特定されるまでアプリケーションを解析する。

しかし、セクション II-A で述べたトレードオフがここで関係してきます。現在提案されているすべてのシンボリック実行手法は、*パス爆発* の問題により非常に限られたスケーラビリティしか持っていません。つまり、分岐ごとに新しいパスが生成されるため、プログラム中のパスの数は各パスの分岐命令の数に比例して指数関数的に増加します。*有望なパスの優先実行* [11], [37] や、状況に応じた*パスのマージ* [5], [35], [47] によってパス爆発を乗り越えようとする試みはなされています。しかし一般的に、この課題は純粋な動的シンボリック実行解析エンジンではいまだ克服されていません。そして（本論文の後半で示すように）、このようなシステムで発見されるバグの多くは*浅い*ものです。

パス爆発問題に対処するための提案のひとつとして、処理の多くをより高速な技術、例えばファジングにオフロードする方法がある。このアプローチではファジングの強み、つまりその高速性を活かしつつ、主な弱点であるアプリケーションのセマンティックな洞察不足を補おうとする。そのため、研究者たちはファジングとシンボリック実行を組み合わせてきた [14], [15], [17], [28], [29], [54]。このような*シンボリックガイド型ファザー*は、ファジングコンポーネントが特定した入力をダイナミックシンボリック実行エンジンによって処理し、修正を加える。動的シンボリック実行は、解析対象プログラムをより深く理解することで、入力を適切に変更し、これまで探索されていなかったコードを引き起こす追加のテストケースを提供し、ファジングコンポーネントが引き続き進捗（つまりコードカバレッジの面で）を達成できるようにする。

制約の少ないシンボリック実行。動的シンボリック実行の実用性を高めるもう一つの方法は、アプリケーションの*一部分*だけを実行することです。この手法は、Under-constrained Symbolic Execution [26], [46]として知られており、*潜在的な*バグを特定するのに効果的ですが、2つの欠点があります。第一に、アプリケーションの一部分を実行する際に適切なコンテキストを確保することができないため、結果に多くの偽陽性が含まれることになります。第二に、静的な脆弱性発見技術と同様に、拡張性を得る代わりに、発見したバグの再現性を犠牲にしています。

#### V. BACKGROUND: EXPLOITATION

脆弱性発見の分析は、実際には *クラッシュを引き起こす入力* を発見します。これらのクラッシュ入力をトリアージする、つまりどのクラッシュが実際のセキュリティ問題に該当するかを理解することは、ほとんどの手法の範囲外です。しかし、発見された脆弱性の再現や分析に関する研究も一部存在します。このセクションでは、特定されたクラッシュを再現し、自動的にエクスプロイトを生成してクラッシュのセキュリティ影響を検証し、さらに現代の緩和技術の下でもエクスプロイトが有効であるよう強化するプロセスについて説明します。

#### *A. Crash Reproduction*

ほとんどの脆弱性発見分析は、テスト対象のアプリケーションを現実とは異なる条件下で実行します。たとえば、多くのファザーは実行時のランダム性を*除去*します。つまり、実行ファイルのPIDや現在時刻などのランダム要素をハードコード化します。これは主に二つの理由から行われます。第一に、多くの最新のファズィング手法では、同じ入力を二つのアプリケーションインスタンスに与えた場合、両方とも同じ結果を返すという暗黙の前提があります。第二に、動的シンボリック実行のような他の技法におけるランダム性のモデル化は、十分に研究が進んでいない分野だからです。

非ランダム化のため、脆弱性発見手法によって報告されたクラッシュは、分析環境の外では簡単には再現できない場合があります。例えば、あるアプリケーションがランダムなトークンを生成し、そのトークンをユーザーが入力しなければ危険なコード領域に入れず、結果としてクラッシュが発生するという場合を考えてみましょう。非ランダム化された分析環境では、生成されるトークンは常に同じ値となり、分析で特定されたクラッシュを引き起こす入力も毎回同じ経路をたどり、クラッシュが発生します。しかし、分析環境の*外部*では、トークンは毎回異なる値となるため、以前クラッシュを引き起こした入力が*クラッシュしない*経路をたどる可能性があります。

自明にリプレイできないクラッシュ入力は、一般的に2つのカテゴリに分けられます。

- 欠損データ。脆弱性発見手法は、アプリケーションから実際に正しい応答値を受け取る前に、それを「推測」してしまうことがあります。例に挙げたトークンは、非ランダム化環境では常に一定の値となっており、fuzzerのような解析エンジンは、プログラムからトークンを取得する前に偶然その値を推測してしまう可能性があります。その結果、解析環境の外でクラッシュを引き起こす入力をリプレイしても、トークン値が一致せずクラッシュは発生しません。
- 関係性の欠如。ファジングのようなセマンティックな洞察が低い手法では、プログラムから取得されたデータとその後プログラムに提供されるデータとの*関係性*を復元することができません。例えば、クラッシュを引き起こす入力によってアプリケーションがユーザーにトークンを提供する場合、そのトークンが後でクラッシュを引き起こすために使用されることがありますが、ファザーの出力には、アプリケーションがユーザーに提供するトークンの値と、ユーザーがアプリケーションに提供しなければならないトークンの値との関係が欠けています。

データが欠損している場合、入力は分析環境の外では単純に再現できず、新たなクラッシュを引き起こす入力が見つかる可能性があります。データ漏洩の特定を専門とする分析手法も存在します [42] が、angrにはそのような分析はまだ実装していません。

後者の場合、ランダム性を排除したクラッシュ入力は、アプリケーションとの通信方法を、アプリケーションから受信したデータと後に提供するデータとの関係で定義する*入力仕様*に変換する必要があります。この方法の一例がReplayer [43]であり、プログラムパスの前提条件を計算することで、現実世界の条件下でどのようにプログラムパスを再現できるかを理解します。

#### *B. Exploit Generation*

上述のいずれかの手法を活用した効率的な脆弱性探索エンジンがあれば、テスト対象のアプリケーションで多くのクラッシュが発生する可能性があります。しかし、これらのクラッシュがすべて悪用可能とは限りません。悪用不可能な入力の例として、NULLポインタ参照があります。現代のオペレーティングシステムではアドレス0でのメモリマッピングが禁止されているため、かつては悪用可能だったこのような状況も現在では悪用不能なクラッシュに分類されるようになりました。クラッシュが悪用可能かどうかを理解することは、バグの*トリアージ*（つまり、どのバグを優先的に調査・修正するかを判断すること）に役立ちます。

クラッシュが悪用可能かどうかをテストする最も明白な方法は、実際にそれを悪用してみることです。この目的のために、クラッシュを引き起こす入力を自動的にアプリケーションのエクスプロイトへと変換しようとするいくつかのシステムが提案されています [4], [31], [51]。

## *C. Exploit Hardening*

近年では、非実行型スタック領域やアドレス空間配置のランダム化（ASLR）といったバイナリの強化技術により、従来型のエクスプロイト、たとえば第一世代の自動エクスプロイトエンジンによって生成されたものの有効性は大幅に低下しています。そのため、たとえ悪用可能な脆弱性が存在していても、現代的な防御策によって緩和される場合があります。

現在の自動エクスプロイト技術は、現代的な緩和技術が広く採用される前に設計されたものであり、現代のソフトウェア防御はこれらの技術によって生成されたエクスプロイトを機能しないものにしてしまいます。これを回避するため、現在の技術で生成されたエクスプロイトをこのような防御策に対して自動的に*強化*する手法が考案されています。これらの手法は、従来のシェルコードベースのエクスプロイトを、Return-Oriented Programming [52]を利用した同等のエクスプロイトに変換することで機能します。そのため、Return-Oriented Programを構築する自動化手法が必要とされ、いくつかの手法が開発されています [18], [48]。

## VI. ANALYSIS ENGINE

私たちがセクションIII、IV、およびVで説明した分析は、過去数年間の異なる時期に提案され、さまざまな技術を用いて実装され、異なる手法で評価された異種のデータセット上で検証されてきました。これは問題であり、異なる手法の相対的な有効性や、それらがさまざまな種類のアプリケーションにどのように適用できるかを理解するのを難しくしています。

この問題を解決するために、私たちは柔軟で高機能な次世代のバイナリ解析システムであるangrを開発し、前のセクションで提示した解析手法のいくつかを実装しました。本セクションでは、この解析システムについて、その設計目標およびこの設計が実際的なバイナリ解析にもたらした影響を説明します。

#### *A. Design Goals*

angrの設計目標は以下の通りです。

- クロスアーキテクチャ対応。組み込みデバイスの台頭により、しばしばARMやMIPSプロセッサ上で動作することが増えてきました。現代のソフトウェアはさまざまなハードウェアアーキテクチャ向けに作られています。これは、x86サポートのみでほとんどの解析エンジンが十分だった前の10年間とは異なります。現代のバイナリ解析エンジンは、クロスアーキテクチャ解析を実行できる必要があります。さらに、32ビットプロセッサはもはや標準ではなくなっています。現代の解析エンジンは64ビットバイナリの解析にも対応できなければなりません。
- クロスプラットフォームのサポート。クロスアーキテクチャのサポートと同様に、現代の解析システムは異なるオペレーティングシステム上のソフトウェアを解析できなければなりません。これは、個々のオペレーティングシステムに固有の概念が

システムは抽象化され、さまざまな実行可能フォーマットの*ロード*をサポートする必要があります。

- 様々な解析パラダイムへの対応。役立つ解析エンジンは、前述のセクションで説明した幅広い解析に対応できる必要があります。そのためには、エンジン自体が抽象化されており、異なるタイプのメモリモデルやデータドメインを提供できることが求められます。
- Usability. angrの目的は、セキュリティコミュニティにとって再現・改良・新規のバイナリ解析手法を行う際に有用なツールを提供することです。そのため、angrの習得のしやすさと使いやすさを重視しました。angrはほぼ完全にPythonで実装されており、簡潔でシンプルなAPIを持ち、IPythonのインタラクティブシェルから簡単に利用できます[44]。Pythonは他の言語と比べて実行速度が常に遅くなりますが、ほとんどのバイナリ解析手法はアルゴリズム自体の遅さがボトルネックとなるため、言語によるパフォーマンスの低下が問題になることはほとんどありません。言語のオーバーヘッドが重要になる場合には、angrはPythonのJITエンジンであるPyPy上で実行することで、大幅な高速化が可能です。

私たちの目標は、angrを使って、典型的なバイナリ解析技術を私たちのプラットフォーム上でおよそ1週間で再現できるようにすることでした。実際には、Veritesting [5]を8日間で再現でき、ガイド付きシンボリック実行を1か月、AEG [4]を週末の間に、Q [48]を約3週間、そして制約の少ないシンボリック実行 [46]を2日間でそれぞれ再現できました。動的シンボリック実行と値集合解析については、システム自体を構築している2年間で実装したため、実装にかかった労力を見積もるのは難しいです。

これらの設計目標を達成するために、私たちは分析エンジンを慎重に構築する必要がありました。さまざまな分析用のモジュール式の構成要素を作成し、それぞれの間に厳密な分離を保つことで、angrの上位部分（例えば状態表現）が下位部分（例えばデータモデル）について持つ前提を減らすよう注意しました。これにより、分析間をその場で組み合わせたり変換したりしやすくなっています。また、angrの個々のモジュールを他の研究者が再利用しやすくなることも期待しています。次のいくつかのセクションでは、angrの各サブモジュールの技術的な設計について説明します。

#### *B. Submodule: Intermediate Representation*

複数のアーキテクチャをサポートするために、私たちはアーキテクチャ固有のネイティブバイナリコードを中間表現（IR）に変換し、その上で解析を実装しています。独自に「IRリフター」を作成するのは非常に時間のかかるエンジニアリング作業であるため、私たちはValgrindプロジェクトのIRリフターであるlibVEXを活用しました。libVEXはプログラム解析用に特別に設計されたVEXというIRを生成します。私たちは、もともとFirmalice [53] のために作成したPyVEXを利用して、このVEX IRをPythonで扱えるようにしました。VEXを活用することで、32ビットおよび64ビットのARM、MIPS、PPC、x86（このうち64ビット版はamd64）プロセッサに対して解析をサポートすることができます。Valgrindのコントリビューターによる改良も常に進められており、例えば現在SPARCアーキテクチャへのポート作業が進行中です。

後ほど述べますが、angrが常にVEXを中間表現として使用しなければならないという根本的な制約はありません。実装としては、別の中間表現をサポートすることは単純なエンジニアリング作業で可能です。

# *C. Submodule: Binary Loading*

アプリケーションバイナリを解析システムにロードする作業は、CLEと呼ばれるモジュールによって処理されます。CLEは「CLE Loads Everything」という再帰的頭字語です。CLEはさまざまなバイナリ形式を抽象化し、指定されたバイナリおよびそれが依存するライブラリのロード、動的シンボルの解決、リロケーションの実施、およびプログラム状態の適切な初期化を行います。CLEを通じて、angrはほとんどのPOSIX準拠システム（Linux, FreeBSDなど）、Windows、そしてDARPA Cyber Grand Challenge向けに作られたDECREE OSのバイナリをサポートしています。

CLE は、バイナリローダーに拡張可能なインターフェースを提供します。これは、バイナリオブジェクト（たとえば、アプリケーションバイナリ、POSIX の .so、または Windows の .dll）、それらのオブジェクト内のセグメントやセクション、およびそれらのセクション内の位置を表すシンボルを表現する複数の基底クラスを提供することで実現されています。CLE は、ファイルフォーマット解析ライブラリ（具体的には、Linux バイナリ用の elftools や Windows バイナリ用の pefile）を使用してオブジェクト自体を解析し、その後必要な再配置を行い、*ロードされた*アプリケーションのメモリイメージを提供します。

# *D. Submodule: Program State Representation/Modification*

SimuVEXモジュールは、*プログラムの状態*（つまり、レジスタやメモリ内の値、開いているファイル、*その他*のスナップショット）を表現する役割を担っています。SimuVEXの用語でSimStateと呼ばれるこの状態は、*ステートプラグイン*の集合として実装されています。これらのプラグインは、状態が作成される際にユーザーや解析によって指定される*ステートオプション*によって制御されます。現在、以下のステートプラグインが存在します。

- レジスタ。SimuVEX は、プログラムの任意の時点におけるレジスタの値を、対応するプログラム状態のステートプラグインとして追跡します。
- シンボリックメモリ。シンボリック実行を可能にするために、SimuVEX は状態プラグインとしてシンボリックメモリモデルを提供します。これは、Mayhem [16] で提案されたインデックス付きメモリモデルを実装しています。
- 抽象メモリ。抽象メモリ状態プラグインは、静的解析によってメモリをモデル化するために使用されます。継続的なインデックス付きメモリモデルを実装するシンボリックメモリとは異なり、抽象メモリは多くの静的解析で使用される *リージョン* ベースのメモリモデルを提供します。
- POSIX. POSIX準拠の環境向けにバイナリを解析する際、SimuVEXはこのステートプラグインで*システム状態*を追跡します。たとえば、シンボリック状態で開かれているファイルなどが含まれます。各ファイルはメモリ領域とシンボリックな位置インデックスで表現されます。
- ログ：SimuVEX は、このプラグイン内で状態に対して行われたすべての操作（例えば、メモリ書き込みやファイル読み取りなど）を記録したログを管理します。
- インスペクション。SimuVEXは強力なデバッグインターフェースを提供しており、汚染状態や正確な式の構成など、複雑な条件に基づいてブレークポイントを設定することができます。

シンボリック条件。 このインターフェースは、SimuVEX の動作を*変更する*ためにも使用できます。 たとえば、メモリリードを計測してメモリマップトI/Oデバイスをエミュレートすることができます。

- Solver。Solverは、（後述するClaripyというデータモデルプロバイダーを通じて）さまざまなデータ領域へのインターフェースを公開するプラグインです。たとえば、このプラグインがシンボリックモードで構成されている場合、レジスタやメモリ、ファイル内のデータをシンボリックに解釈し、アプリケーションの解析中にパス制約を追跡します。
- アーキテクチャ。アーキテクチャプラグインは、解析に役立つアーキテクチャ固有の情報（例えば、スタックポインタの名前やアーキテクチャのワードサイズなど）を提供します。このプラグインの情報は、angrの一部として配布されているarchinfoモジュールから取得されています。

これらのステートプラグインは、さまざまな分析をサポートするために多様な方法で組み合わせることができるビルディングブロックを提供します。

さらに、SimuVEXは解析の基本単位を実装しています。これは、アプリケーションコードのブロックによってプログラムの状態に加えられる意味的変化を表現するものです（SimuVEXの用語では、このようなコードブロックはSimRunと呼ばれます）。つまり、SimuVEXは*入力*状態をVEXで表現されたコードのブロックに通し、*出力*状態（あるいは、条件分岐ジャンプのように複数の出力状態があり得る場合には出力状態の集合）を生成する機能を提供しています。この部分もSimuVEXのモジュール的な設計に則っています。基本ブロックのVEX変換に加えて、SimuVEXはSimRunとして手書きのPython関数をユーザーが提供することもでき、Pythonコードを使ってブロックを計測・改変する強力な方法を実現しています。実際、私たちの環境モデルはこの仕組みで実装されています。システムコールはプログラムの状態を変更するPython関数として実装されています。

#### *E. Submodule: Data Model*

SimStateのレジスタやメモリに格納されている*値*は、別のモジュールであるClaripyによって提供される抽象化によって表現されています。

Claripyは、すべての値を、使用されたすべての操作を追跡する*式*の内部表現へと抽象化します。つまり、式xに式5を加えると、xと5を引数として保持したまま、x + 5という式になります。これらの式は「式ツリー」として表現され、値はリーフノードとなり、操作はリーフでないノードとなります。

どの時点でも、式は Claripy の *backends* によって提供されるデータドメインに変換することができます。具体的には、Claripy はコンクリートドメイン（整数および浮動小数点数）、シンボリックドメイン（Z3 SMT ソルバー [25] が提供するシンボリックな整数およびシンボリックな浮動小数点数）、そして Value Set Analysis のための値集合抽象ドメイン [6] をサポートするバックエンドを用意しています。Claripy は他のバックエンドに拡張することも簡単です。特に、他の SMT ソルバーの実装は興味深いものとなるでしょう。なぜなら、異なるソルバーが異なるタイプの制約の解決において優れていることが示されているためです [8]。

ユーザー向けの操作、例えばバックエンドによって提供される構造体（例えば Z3 バックエンドによって提供される記号式 x+1）を Python のプリミティブ（制約解決の結果としての x + 1 に対する可能な整数解など）へと解釈する作業は、*フロントエンド*によって提供されます。フロントエンドは、バックエンドにさまざまな複雑さの追加機能を付加します。Claripy には現在、いくつかのフロントエンドが用意されています:

- FullFrontend。 このフロントエンドは、ユーザーに対してシンボリックソルビングを提供し、制約を追跡し、Z3バックエンドを用いてこれらを解決し、さらにその結果をキャッシュします。
- CompositeFrontend。KLEEやMayhemが提案しているように、制約を独立したセットに分割することで、ソルバーへの負荷を軽減することができます。CompositeFrontendは、この機能への透過的なインターフェースを提供します。
- LightFrontend。このフロントエンドは制約トラッキングをサポートしておらず、VSAバックエンドを使用してVSAドメイン内の式を単純に解釈します。
- ReplacementFrontend. ReplacementFrontend は LightFrontend を拡張し、VSA 値に対する *制約* のサポートを追加します。制約（例えば x+1 < 10）が導入されると、ReplacementFrontend はその制約を解析し、関与する変数の範囲（例えば 0 <= x <= 8）を特定します。その後、ReplacementFrontend に変数 x の可能な値を問い合わせると、事前に決定された範囲と変数の値が交差され、VSA 単体よりも正確な結果が得られます。
- HybridFrontend。HybridFrontendは、FullFrontendとReplacementFrontendを組み合わせることで、記号制約解決に対する高速なおおよそのサポートを提供します。Mayhem [16] はこのような機能の可能性を示唆していましたが、私たちの知る限り、angrは研究コミュニティに対してこの機能を最初に一般公開したツールです。

このモジュラー設計により、Claripy はさまざまなデータドメインによって提供される機能を強力な方法で組み合わせ、それを angr の他の部分に提供することができます。

#### *F. Submodule: Full-Program Analysis*

angrのアナリスト向け部分は、動的記号実行や制御フローグラフの復元など、完全な解析機能を提供します。これらの解析への「エントリーポイント」となるのがProjectであり、バイナリとそれに関連するライブラリを表します。このオブジェクトから、他のサブモジュールのすべての機能（たとえば、状態の作成、共有オブジェクトの調査、基本ブロックの中間表現の取得、バイナリコードへのPython関数のフックなど）にアクセスできます。さらに、全プログラム解析のための主なインターフェースが2つあり、Path GroupsとAnalysesです。

Path Groups。PathGroupは動的なシンボリック実行へのインターフェースであり、アプリケーション内でパスが実行され、分岐し、または終了する過程を追跡します。このインターフェースの作成は、シンボリック実行中のパス管理に対するフラストレーションから生まれました。angrの初期開発段階では、シンボリック実行を利用するたびに、各解析ごとにアドホックなパス管理を実装していました。私たちは、パスが分岐や統合する際の階層構造の追跡、探索時に優先すべき興味深いパスの分析、探索において有望でないパスを特定して終了させるといった、同じ機能を何度も再実装していることに気付きました。こうしたパスのグループに対して共通して行われる処理を統一し、PathGroupインターフェースを作成しました。

解析。angr は Analysis クラスを使って、あらゆる全体的なプログラム解析の抽象化を提供します。このクラスは、制御フローグラフの復元のような静的解析や、第IX節で示されているような複雑な動的解析のライフサイクルを管理します。

angrがバイナリに関する何らかの*事実*（例：「アドレスXの基本ブロックがアドレスYの基本ブロックにジャンプできる」）を特定した場合、それを対応するProjectの*知識ベース*に保存します。この共有された知識ベースによって、解析が協力してアプリケーションに関する情報を発見できるようになります。

## *G. Open-Source Release*

私たちは、新しいバイナリアナリシス手法を実装できるプラットフォームを開発することを目標にangrの開発を始めました。実際的なバイナリの解析に伴う予想外の課題に直面する中で、このような解析エンジンがセキュリティコミュニティにとって非常に有用であることに気付きました。これが、angrをオープンソース化した理由であり、バイナリアナリシスの将来の基盤となり、研究者たちが同じ課題に何度も取り組む負担から解放されることを願っています。angrは約65,000行のコードで実装されており、IPythonシェルから直接利用できるほか、Pythonモジュールとしても使用でき、標準のPythonパッケージマネージャpipから簡単にインストールできます。

angrのオープンソースリリースには、解析エンジンモジュール（VI-A節からVI-F節で説明）の他、その上に実装されたXV節で議論されたアプリケーションが含まれています。後者のうち、我々は制御フローグラフのリカバリ、静的解析フレームワーク、動的シンボリック実行エンジン、そして制約緩和シンボリック実行の実装をオープンソース化しています。他のアプリケーションについても今後リリースする予定ですが、現時点ではプロトタイプレベルのコードと、DARPA Cyber Grand Challengeに積極的に利用されている段階が混在しています。

angrはコミュニティから非常に高い熱意をもって受け入れられています。オープンソースとして公開してから最初の3か月で、システムを構成するさまざまなモジュールのGitHubリポジトリに合計約500件の「スター」（ソフトウェアを高く評価する人の数の指標）が集まりました。同じ期間中に、angrはpipを通じておよそ6,000回インストールされ、Gitリポジトリの「クローン」は週平均20回行われました。angrはすでに他の教育機関の授業プロジェクトで、学生にバイナリアナリシスを紹介するために使用された実績もあります。さらに、他にもいくつかの教育機関が研究用プロトタイプの基盤としてangrを利用していることや、複数の企業が商用バイナリアナリシスシステムでの実用性を評価していることも把握しています。

#### VII. IMPLEMENTATION: CFG RECOVERY

angrがCFGを生成する際に使用するプロセスについて説明します。また、最終的な結果の完全性および確実性を向上させるために開発された特定の手法についても紹介します。

特定のプログラムに対して、angrはプログラムのエントリーポイントから開始し、必要な最適化を施しながら反復的にCFGリカバリを行います。angrは、*強制実行*、*後方スライシング*、および*シンボリック実行*を組み合わせて利用し、可能な限り各間接ジャンプのすべてのジャンプ先を復元します。さらに、ターゲットアプリケーションに関する大量のデータを生成して保存し、後でデータ依存性の追跡など他の解析に利用できるようにします。

このアルゴリズムには主に三つの欠点があります。処理が遅いこと、「デッドコード」を自動的に処理できないこと、そして未探索の間接ジャンプを介してしか到達できないコードを見逃してしまう可能性があることです。この問題に対処するために、私たちは、バイナリをすばやく逆アセンブル（どの基本ブロックも実行せずに）し、その後ヒューリスティックを用いて関数、関数内の制御フロー、および関数間の直接的な制御フロー遷移を特定する二次的なアルゴリズムを作成しました。しかし、この二次アルゴリズムは精度が大幅に劣ります。関数間の到達可能性に関する情報を持たず、コンテキストセンシティブでもなく、複雑な間接ジャンプの復元もできないのです。

このセクションの残りでは、私たちの高度なリカバリアルゴリズムであるCFGAccurateについて説明します。その後、Section VII-Fで高速アルゴリズムCFGFastについて議論します。

## *A. Assumptions*

angrのCFGAccurateは、アルゴリズムの実行時間を最適化するためにバイナリについていくつかの仮定をしています。

- 1) プログラム内のすべてのコードは、異なる関数に分割することができます。
- 2) すべての関数は、明示的な call 命令（またはその同等物）によって呼び出されるか、あるいは制御フロー上でテールジャンプ（再帰関数のスタック使用量を減らすためによく使われる最適化で、関数の末尾での呼び出しが *ジャンプ* に変更され、新しく呼び出された関数が単に呼び出し元のリターンアドレスを再利用するもの）で先行されます。
- 3) 各関数のスタックのクリーンアップ動作は、どこから呼び出されたかに関係なく予測可能です。これにより、CFGAccurate は呼び出し元の関数を解析する際に、すでに解析済みの関数を安全にスキップし、スタックのバランスを保つことができます。

これらの前提は、angrが解析することを想定しているバイナリの種類に制約を与えます。前提1、2、3は、解析対象のバイナリが難読化されておらず、「通常」の挙動をすることを要求しています。難読化されたり異常な挙動をするバイナリを解析する場合、これらの前提を外すこと*も*可能ですが、その場合CFGリカバリーの実行時間が長くなることになります。

私たちのCFGリカバリコードは、関連文献 [21], [34], [50], [58], [59] で提案された手法に基づいて構築されています。しかし、これらの手法は、現実のバイナリに対しては過度に厳しく、あるいは現実的でない仮定をしています。特に、CFGリカバリの元となった研究とは異なり、私たちは以下のいずれの仮定もしていません。

1) すべての関数は、呼び出し元の次の命令に戻ります [59]。

- 2) 間接分岐のジャンプ先は常に制御フローパスによって決定され、プログラムの状態やコンテキストによって決まるわけではありません [59]。例えば、既存の文献の中には、間接ジャンプはすべて*計算された*ものであり、以前のコンテキストから関数ポインタとして渡されるものではないと仮定しているものもあります。
- 3) 間接ジャンプのジャンプターゲットに関する表現は、一般的なイディオムのセットに一致している必要があります [21], [58]。従来の研究とは異なり、ポインタに適用できる操作の種類については一切仮定しません。
- 4) 関数に入る前と戻った後で、スタックポインタは同じである。
- 5) 2つの関数が重複することはありません（言い換えれば、基本ブロックを共有することはできません[34]）。CFGAccurateは、コードを共有する関数にも対応しています。
- 6) シンボルテーブルや再配置情報などの追加情報も利用できる [50]。

バイナリから制御フローグラフを復元するための実際のアルゴリズムについては、次のいくつかのセクションで説明します。

# *B. Iterative CFG Generation*

残念ながら、どの単一の手法でもCFGAccurateの目標である完全かつ健全なCFGの復元を満たすことはできません。そのため、CFGAccurateは高速性と完全性を達成するために、複数の手法を組み合わせてCFGを構築します。具体的には、強制実行、軽量な後方スライシング、シンボリック実行、及び値集合解析の4つの手法が用いられます。これらの手法で反復的に復元されるCFG（C）は、アプリケーションのエントリーポイントにある基本ブロックで初期化されます。

CFGの復元作業の過程で、CFGAccurateはジャンプ先がまだ解決されていない間接ジャンプのリスト L<sup>j</sup> を管理します。解析がそのようなジャンプを特定すると、それがL<sup>j</sup> に追加されます。各反復的な手法が終了するたびに、CFGAccurateは次にリスト上の手法を起動します。この次の手法はL<sup>j</sup> 内のジャンプを解決する場合もあれば、新たな未解決ジャンプをL<sup>j</sup> に追加したり、CFG Cに基本ブロックやエッジを追加したりする場合もあります。L<sup>j</sup> またはCに何の変化も生じなくなったとき、すなわちどの解析手法でもこれ以上間接ジャンプを解決できないことを意味するため、CFGAccurateは処理を終了します。

# *C. Forced Execution*

angrのCFGAccurateは、CFGリカバリの最初の段階でDynamic Forced Executionという概念を活用しています[59]。Forced Executionにより、すべての分岐点で条件分岐の両方向が必ず実行されることが保証されます。

CFGAccurateは、基本ブロックの作業リストBwと、解析済みブロックのリストBaを管理します。解析が開始されると、Cに含まれていてBaには含まれていないすべての基本ブロックで作業リストが初期化されます。作業リストから基本ブロックを解析するたびに、その基本ブロックと、そこからの*直接*ジャンプはCに追加されます。しかし、間接ジャンプについてはこの方法では対応できません。強制実行下では、間接ジャンプのターゲットがプログラムの実際の実行時とは異なる場合があります。これは強制実行によって、予期しない順序でコードが実行されるためです。そのため、各間接ジャンプは後で解析できるよう、リストL<sup>j</sup>に保存されます。

間接ジャンプを解決できないため、この解析は高速なCFG復元解析として機能し、検出された基本ブロックと未解決の間接ジャンプを他の解析に迅速に提供します。

# *D. Symbolic Execution*

動的強制実行の主な問題点は、間接ジャンプの存在です。というのも、間接ジャンプのターゲットが正しく解決されているかを確実にする方法がないからです。一方で、間接ジャンプがまったく解決不能な場合（つまり、強制実行によってジャンプ先のアドレスが初期化されていないメモリから読み出される状態になった場合）、復元されたCFG内に壊れた制御フロー遷移が残ってしまいます。もう一方で、間接ジャンプが部分的にしか解決できない場合もあります（つまり、解析によって可能なジャンプ先の一部しか特定できない場合です）。

各ジャンプ J ∈ L<sup>j</sup> に対して、CFGAccurateはCFGを逆方向にたどり、最初の*マージポイント*（つまり、間接ジャンプに至るまでに複数のパスが合流する点）を見つけるか、またはブロック数の閾値に達するまで遡ります（経験的には、この閾値は8が適切であることがわかりました）。そこから、間接ジャンプまで前方向のシンボリック実行を行い、制約ソルバーを使って間接ジャンプのターゲットとなる可能性のある値を取得します。

CFGAccurate は、計算されたジャンプ先候補の集合がある閾値よりも小さい場合、ジャンプが正しく解決されたとみなします。私たちはこの閾値として 256 を使用していますが、実際にはジャンプが*正しく*解決されない場合、この値には*制限がありません*（つまり、ジャンプ先候補の集合はアドレスのビット数によってのみ制約されます）。

ジャンプが正常に解決されると、JはL<sup>j</sup>から削除され、ジャンプターゲットのそれぞれの可能な値に対してCFGにエッジとノードが追加されます。

# *E. Backward Slicing*

angrの強制実行分析やシンボリック実行分析は、多くの未解決ジャンプを解決できません。これは*コンテキスト*の欠如が原因です。これらの分析はコンテキスト非依存で行われます。そのため、関数がポインタを引数として受け取り、そのポインタが間接ジャンプのターゲットとして使用されている場合、分析ではそれを解決できません。

より高い完全性を達成するために、私たちのCFG生成にはコンテキストに依存した要素が必要です。これを実現するために、*逆方向スライス*を利用しています。CFGAccurateは、未解決のジャンプを起点として逆方向スライスを計算します。このスライスは、直前の*呼び出しコンテキスト*の始まりまで拡張されます。つまり、解析対象の間接ジャンプが関数F<sup>a</sup>内にあり、そのF<sup>a</sup>がF<sup>b</sup>およびFcの両方から呼び出されている場合、スライスはF<sup>a</sup>内のジャンプから逆方向に拡張され、2つの開始ノード（F<sup>b</sup>の先頭の基本ブロックとFcの先頭の基本ブロック）を含むことになります。

CFGAccurateは次に、このスライスをangrのシンボリック実行エンジンを使って実行し、制約エンジンを用いてシンボリックジャンプの可能なターゲットを特定します。このとき、ジャンプターゲットの解集合のサイズの閾値は256と同じです。ジャンプターゲットが正常に解決されると、そのジャンプはL<sup>j</sup>から削除され、制御フロー遷移を表すエッジおよびターゲットの基本ブロックが回収されたCFGに追加されます。

## *F. CFGFast*

fast CFG生成アルゴリズムの目的は、高いコードカバレッジを持ち、バイナリ内の関数の位置と内容を少なくとも特定できるグラフを生成することです。このグラフには多くの*制御フロー*が欠けているため、完全なものではありません。しかし、このようなグラフでも、バイナリの手動解析および自動解析の両方に役立つことがあります。

CFGFastは、以下の手順を実行します。

- 関数の識別。ハードコードされた関数プロローグシグネチャ（ByteWeight [7] などの手法で生成可能）を用いて、アプリケーション内の関数を識別します。アプリケーションに*シンボル*が含まれていて関数の位置が指定されている場合、それらもグラフに関数開始位置として追加されます。さらに、プログラムのエントリーポイントを表すベーシックブロックもグラフに追加されます。
- 再帰的逆アセンブル。再帰的逆アセンブルは、特定された関数内の直接ジャンプを復元するために使用されます。
- 間接ジャンプの解決。軽量なエイリアス解析やデータフロートラッキング、そして事前に定義された戦略を組み合わせて、関数内での制御フロー移動を解決します。現在、CFGFast にはジャンプテーブルの識別や間接呼び出し先の解決のための戦略が含まれています。

目標は、関数同士の到達可能性を理解することにはこだわらず、カバレッジの高いCFGを素早く復元することです。

## *G. Using the CFG Recovery*

angrは、CFGリカバリアルゴリズムを2つの解析として公開しています：CFGFastとCFGAccurateです。これらの解析は、CFGデータをangrのナレッジベースに出力します（Section VI-Fで説明されています）。このデータは、その後の手動解析や後続の自動解析で利用できます。

## VIII. IMPLEMENTATION: VALUE SET ANALYSIS

CFGが生成されると、より高度な解析を実行することができます。その一つがValue-Set Analysis [6]です。Value-Set Analysis (VSA)は、バイナリプログラムに対して数値解析とポインタ解析を組み合わせた静的解析手法です。これは、Value-Set Abstract domainと呼ばれる抽象領域を用いて、各プログラムポイントにおいてレジスタや抽象的な場所が持ち得る可能性のある値を近似します。

VSAは、関数内のすべてのプログラムポイントに対して*不動点*に到達するまでプログラムを解析します。この不動点は、関数の任意の時点でレジスタや抽象メモリロケーションが取り得るすべての値についての厳密な過大近似を表します。たとえば、計算されたアドレスAへのメモリ書き込みに関しては、計算された不動点におけるAの値を参照することで、考えられるすべての書き込み対象の完全なリストが得られます。

Balakrishnan ら [6] によって提案された元々の VSA 設計は、実際のバイナリを解析する際には十分な性能を発揮しません。こうしたバイナリで VSA を機能させるために、私たちは解析の精度を高めるためのいくつかの改良を施す必要がありました。

- ストライド区間の個別集合を作成する。VSAの基本データ型であるストライド区間は、本質的には数の集合を近似するものです。これは通常の具体的な値の集合を近似するのに非常に適しています。しかし、これらの値がプログラム内でジャンプ先として使用された場合、ストライド区間の過剰近似的な性質により、本来ジャンプ先であるべきでないアドレスへの制御フロー遷移が発生し、回収されたCFGにおいて不正確さが生じてしまいます。この問題を効果的に解決するために、「ストライド区間集合」と呼ばれる新しいデータ型を開発しました。これは、ストライド区間がひとつに結合されることなく、それぞれのストライド区間の集合を表現します。ストライド区間集合は、含まれる要素数がしきい値Kを超えた場合のみ、ひとつのストライド区間へと結合されます。Kは調整可能なしきい値です。Section II-A で述べた私たちのモデルでは、このしきい値によって、意味的な深さとスケーラビリティのトレードオフを制御できます。Kの値を高く設定すれば高精度を維持できますが、その分、解析の複雑さが増加します。
- 経路述語に代数ソルバーを適用すること。分岐条件を追跡することで、条件付き分岐を取った後やマージ処理の際に状態内の変数を制約し、より精密な解析結果を得ることができます。Affine-Relation Analysis は、これらの条件を追跡する技術として提案されています [40]。しかし、この方法は実装が複雑であり（通常、制約式でサポートされる算術演算がごく限られてしまう）、実際には計算コストも高くなります。そこで、私たちの解決策としては、ストライド付き区間領域で動作する軽量な代数ソルバーを実装します。これはモジュロ演算に基づいており、アフィン関係の一部を考慮します。新しい経路述語が現れたとき（条件分岐をたどる際）、これを簡略化し解くことで、経路述語に含まれる変数の範囲を求めようとします。そして、新たに生成された数値範囲と各対応する変数の元の値との間で積集合を取ります。これにより、新しい分岐条件に出会うたびに値集合解析の結果を継続的に洗練でき、最終的な不動点の精度が向上します。
- 符号なし・符号付きに依存しないドメインの採用。VSAは元々、符号付きステップ間隔ドメイン上で動作することが提案されており、すべての値が符号付きであると仮定している。つまり、nビットのステップ間隔において下限をl、上限をhとすると、常に l ∈ [−2<sup>n</sup>−<sup>1</sup>, 2<sup>n</sup>−<sup>1</sup> − 1] ∧ h ∈ [−2<sup>n</sup>−<sup>1</sup>, 2<sup>n</sup>−<sup>1</sup> − 1] ∧ l ≤ h となる。しかし、この仮定により、符号なし演算結果が大きく過剰に近似されてしまう。実際、ジャンプアドレスが符号なしであることから、ジャンプアドレスの計算は一般的に（符号なし比較の場合など）符号なし値に依存するため、この過剰近似がさらに悪化する。この問題への解決策として、本解析では符号に依存しないドメインを採用することが挙げられる。*Wrapped Interval Analysis* [41] はこのような

LLVMコードを解析するための区間ドメインであり、符号付き数値と符号なし数値の両方を同時に扱うことができます。私たちは、この理論に基づいて、符号性に依存しないストライド区間ドメインをVSAドメインに適用しました。

私たちは、メモリ破損の検出のためにVSAを3つの段階で使用しています。まず、VSAの実行中にプログラム内のすべての読み書きアクセスパターンを収集します。これらのアクセスパターンに基づいて、スタック領域とヒープ領域の変数に対する変数リカバリを行います。私たちの実装は、TIE [36] の変数リカバリと類似しています。次に、スタック領域およびヒープ領域全体をスキャンし、異常なバッファを検出します。これには、a) 重複するバッファ、および b) 境界外のバッファが含まれます。その後、すべての異常なバッファを潜在的なメモリ破損として単純に報告します。

#### *A. Using VSA*

angr が完全なプログラムの VSA 解析に提供する主なインターフェースは、*Value Flow Graph* です。VFG は、各プログラムの位置で VSA のフィックス・ポイントを表す*プログラム状態*を含む、強化された CFG です。VFG 解析に渡すパラメータによって、単一の関数、関数呼び出しのツリー、またはプログラム全体を対象にすることができます。

VFGに含まれるプログラム状態は、SimuVEXが提供する抽象的なレイアウト（具体的には、SimAbstractMemoryメモリモデル）でメモリを表現しており、メモリ内の値はClaripyが提供する値集合で表されています。私たちは、これらのプログラム状態に含まれるデータに対して、メモリアクセスがとり得る値の範囲を分析することでバッファオーバーラップ解析を行いました。

#### IX. IMPLEMENTATION: DYNAMIC SYMBOLIC EXECUTION

我々の分析プラットフォームの動的シンボリック実行モジュールは、主にMayhem [16]で説明されている技術に基づいています。私たちの実装は、同じメモリモデルおよび経路優先順位付け手法に従っています。このモジュールはangrの主要な機能の一つを構成しており、Veritestingや制約の緩いシンボリック実行などの他の解析もこれを基盤としています。

私たちは、Claripyのインターフェースを通じてZ3にアクセスし、SimuVEXが提供するシンボリックメモリモデル（具体的にはSimSymbolicMemory）を構築しています。プログラム内の個々の実行経路は、angrが提供するPathオブジェクトによって管理されており、これらは経路で行われたアクションや経路の述語、その他さまざまな経路固有の情報を追跡します。これらの経路のグループは、angrのPathGroup機能によって管理され、動的シンボリック実行中の経路の分岐、統合、フィルタリングを管理するためのインターフェースを提供します。

angr は Veritesting [5] をネイティブでサポートしており、Veritesting 分析として実装されていて、PathGroup オブジェクトにオプションを渡すことで、透過的にサポートを利用できます。この高度な状態マージ技術は、経路を静的に（かつ選択的に）マージすることで、指数関数的な状態爆発の問題を緩和するのに役立ちます。

# X. IMPLEMENTATION:

## UNDER-CONSTRAINED SYMBOLIC EXECUTION

私たちは、UC-KLEE [46] で提案された under-constrained symbolic execution (UCSE) を実装し、UC-angr と名付けました。UCSE は動的な symbolic execution 技法であり、各関数ごとに個別に実行を行います。解析は特定の関数へ*どのように*到達するかを考慮できないため、UCSE による検出結果は再現可能ではありません。また、各関数は実際の実行時に呼び出される際の *コンテキスト*（すなわち引数やグローバル変数）なしで生成されるため、解析の精度は高くなく、誤検知が発生しやすいという問題があります。

UCSEは、文脈が不足している状態のタグを*underconstrained*としてマークします。このような十分に制約されていないデータがポインタとして使用される場合、新しいunderconstrainedな領域が作成され、そのポインタは新たな領域を指すようになります。この「オンデマンド」のメモリ割り当てによって、複雑なデータ構造を管理するコードの解析が可能になります。セキュリティ違反（例えば、スタック上の保存されたリターンアドレスへの書き込み）が検出された際には、関与する値について*underconstrained*の状態であるかどうかが確認されます。特定の条件下（すべてのデータがunderconstrainedである場合など）では、その違反は誤検知としてフィルタリングされます。

私たちは、UCSEで説明されている手法に対して2つの変更を加えました。

- グローバルメモリの制約不足。元のUC-KLEE実装では、グローバルメモリへのアクセスを制約不足とはみなしていません。しかし、このようなメモリは、グローバルデータが既に上書きされている可能性があるため、UCSEではプログラムコンテキストの一部として予測することは不可能です。したがって、すべてのグローバルデータを制約不足としてマークし、これによって誤検知率を下げることができます。
- パス制限子。元々のUC-KLEE実装には、パス爆発を防ぐためのいくつかの内蔵制限がありました。例えば、制約の少ないポインタのデリファレンスの深さを制限することで、制約の少ないリンクリスト内を無限に探索し続けるのを避けていました。私たちはさらに追加の制限を加えました。関数がパス爆発の原因となっていることが判明した場合、その関数の解析を中止します。これは、ハードコードされた制限値（実験では64パスという経験的に決定した値）を超えて一つの関数が分岐すると、その関数を即座にreturnするように置き換え、解析をその関数の呼び出し元から巻き戻すことで検出します。これによりパス爆発を回避して解析を現実的なものに保てますが、解析の精度はさらに低下します。
- フォールスポジティブのフィルタリング。私たちはUCangrの実装にいくつかの追加的なフォールスポジティブフィルタを導入しました。具体的には、悪用可能な状態を検出した際に、その状態が制約の不足により誤って悪用可能になっていないことを確認しようとします。まず、追加の制約E（その状態が悪用可能で「ない」ことを表す制約）を用いて制約解決を行います（例えば、セキュリティ違反がリターンアドレスの上書きの場合、リターンアドレスが上書きされて「いない」ように状態を制約します）。次に、それぞれの過小制約値を、この悪用不可能な状態から得られた可能な解に制約します。これらの制約をUと呼びます。最後に、制約Eを取り除き、Uだけを残した状態で確認します。

その状態が依然として悪用可能である場合、これはその機能自体に何らかの本質的な欠陥がある可能性が高く、その欠陥は必ずしもコンテキストから抜けている*データ*に依存しているとは限りません。なお、この欠陥は、*制約*が不足していることによる誤検知であったり、十分に制約されていないデータについての限られたコンテキストによるものである可能性もあります。

UC-angr は、アンダーコンストレインされたデータアクセスを追跡し、必要なリロケーションを実行する SimState プラグインとして実装されています。このプラグインが初期化されると、動的シンボリック実行と同じ PathGroup パラダイムを用いて、アンダーコンストレインドシンボリック実行を行うことができます。

## XI. IMPLEMENTATION: SYMBOLIC-ASSISTED FUZZING

ここでは、シンボリック支援ファジング実装の概要を説明しますが、全体的なアプローチであるDrillerの詳細については、別の論文 [54] で述べられています。

私たちのシンボリック支援型ファジングの実装は、AFLファザーを基盤としており、シンボリックトレーサーとしてangrを利用しています。AFLの動作状況を監視することで、AFLが作成した入力をいつシンボリックトレーシングするかを判断できます。この判断を下す際、ファザーが新しい状態遷移を発見する速度に基づいています。AFLが入力の変異を一巡した後に新しい状態遷移を発見できなかったと報告した場合、ファザーの進行が停滞しているとみなし、AFLが*ユニーク*と判断したすべての経路（つまり、他の経路にはないジャンプ、ソースアドレスとデスティネーションアドレスの組み合わせによって識別されるもの）に対してangrを起動し、AFLが入力を発見できなかった遷移を探索します。

Drillerのシンボリックコンポーネントは、angrのシンボリック実行エンジンを利用して実装されており、AFLによって提供された具体的な入力に基づいてパスをシンボリックにトレースします。これにより、各具体的な入力が一つの（トレースされた）パスに対応し、これらの入力はAFLによって有望なものだけが選別されてトレースされるため、シンボリック実行に固有のパス爆発問題を回避することができます。各具体的入力はPathGroup内の個々のパスに対応します。PathGroupの各ステップでは、すべての分岐がチェックされ、最新のジャンプ命令がAFLにとって未知のパスへと導くかどうかが確認されます。このようなジャンプが発見された場合、SMTソルバーに問い合わせて、新たなジャンプへの実行を導く入力を生成します。この入力はAFLへフィードバックされ、AFLは今後のファジングステップでそれを変異させていきます。このフィードバックループにより、高価なシンボリック実行の時間と安価なファジングの時間のバランスが取れるようになり、ファジングが持つプログラム動作に関する低いセマンティックな洞察も補うことができます。

# XII. IMPLEMENTATION: CRASH REPRODUCTION

私たちは、Replayer [43] によって提案された手法を実装し、入力値（つまり、攻撃者が送信する値）と出力値（つまり、攻撃者がアプリケーションから漏洩させる値）との間の失われた関係を回復しました。

私たちのReplayerの実装は、独自のシンボリック実行エンジンの上に構築されています。クラッシュを引き起こす入力のリプレイ問題は、プログラムを初期状態sからクラッシュ状態qへと導く入力仕様i<sup>s</sup>を探索する問題として定義できます。本アルゴリズムは、入力としてプログラムP、初期状態s<sup>a</sup>（つまり、実行可能ファイルのエントリポイントでの状態）、クラッシュ状態qa、および、計測（非ランダム化）環境においてs<sup>a</sup>からq<sup>a</sup>へと遷移させる入力i<sup>a</sup>を受け取りますが、未計測環境では正しくリプレイできません。実装では、i<sup>a</sup>を用いてs<sup>a</sup>からqaへの経路をシンボリック実行します。このとき、Pの実行中に生成されるすべての制約を記録します。これらの制約、実行経路、プログラムP、新たな初期状態sbが与えられれば、*無制約*のシンボリック入力を用いてPをシンボリック実行し、前回記録した実行経路に従って新しいクラッシュ状態q<sup>b</sup>に到達します。この時点で、入力および出力に対する入力制約を解析し、それらの関係性を抽出することができます。この関係データを用いて入力仕様isを生成し、クラッシュを引き起こす入力のリプレイを実現します。

Replayerによって提案された実装には、クラッシュ再現への適用において2つの主な制限があります。第一に、セクションV-Aで述べるように、特定のクラッシュがクラッシュを適切に再現するために必要なすべてのデータを取得できない場合があります。Replayerはこれらのケースに対処できず、新たなクラッシュ入力を見つける必要があります。

第二に、Replayerはクラッシュを引き起こす入力を処理する際、アプリケーションがデランダマイズ環境で実際に実行したパスのみを用いて入力仕様を生成します。もしバイナリの実行トレースが、ランダムデータの正確な値に基づいて変化する場合、Replayerは正しい入力を算出できません。例えば、ランダムクッキーがパスの分岐条件となっていて、デコード関数の特定のパスを実行させるケースでは、その正確な実行パスでリプレイすると、初期値とは異なる値にクッキーを制約してしまう場合があります。このような場合、リプレイされたクッキーは正しくならず、リプレイの試みは失敗します。後述するように、AEGも同様の制限に直面しています。これは、この分野の研究が両タスクの進展に貢献できる可能性を示唆しています。

# XIII. IMPLEMENTATION: EXPLOIT GENERATION

AXGEN [51]、AEG [4]、Mayhem [16] で説明されているものと同様のアルゴリズムを実装することで、最新の自動エクスプロイト生成技術の有効性を評価することができました。私たちの実装では、脆弱性に対するエクスプロイトを作成し、攻撃者が保存された命令ポインタを上書きすることによって（*例えば*、関数ポインタの上書きや、スタック上のバッファオーバーフローを悪用することにより）プログラムの実行を制御できるようにしています。

脆弱な状態。AEG/Mayhemとは異なり、AXGENに似ていますが、私たちはangrを用いてクラッシュしたプログラム入力に対してコンコリック実行を行うことでエクスプロイトを生成します。コンコリック実行を前進させる際には、クラッシュ入力をプログラムに具体的に実行して得られた動的トレースと同じ経路をたどるよう強制します。プログラムがクラッシュした時点でコンコリック実行を停止し、シンボリック状態を調査してクラッシュの原因を特定し、攻撃可能性を測定します。特定のレジスタにおけるシンボリックビット数を数えることで、フレームポインタの上書き、インストラクションポインタの上書き、任意書き込みなど、いくつかのカテゴリにクラッシュを分類することができます。

Instruction Pointer Overwrite Technique. クラッシュ時に命令ポインタにシンボリックなビットが現れる場合、我々が遭遇する中で最も単純に悪用可能なバグです。命令ポインタにシンボリックなビットが含まれていると検出した場合、命令ポインタをシェルコードのような制御可能な命令列、またはROPチェインを実行可能なシンボリックなバッファにスタックをピボットさせるROPガジェットのいずれかを指すように制約を加えることができます（このROPチェインはエクスプロイトの堅牢化ステップで生成されます）。angrは、AEGやAXGENで議論された多くの実装の詳細、例えばテイントトラッキングやパス条件の構築などを自動で処理してくれるため、我々はシンボリックなメモリバッファを見つけ、レジスタ値に制約を課してエクスプロイトを生成するというこれらのアプローチで提案された手法に専念することができます。

CGCバイナリの悪用。Cyber Grand Challengeは、たった7つのシステムコールしか含まないカスタムOS上でゲームをホストしています。プログラムの実行やファイルのオープンができるシステムコールが存在しないため、Cyber Grand Challenge内でのエクスプロイトは、レジスタ制御の実証やメモリの読み書きができることに限定されています。DARPAの基準によれば、CGCには2種類のエクスプロイトが存在します:

- タイプ1エクスプロイトは、攻撃者が汎用レジスタと命令ポインタレジスタを制御できることを示しています。
- Type 2のエクスプロイトは、攻撃者がプロセスのメモリ空間から制御された読み取りを実行できることを示します。

126個のバイナリに対してAEGを適用した結果、実際にエクスプロイトに成功したのは、わずか4つのバイナリだけでした。このうち2つのバイナリに対してのみ「Type 2」エクスプロイトの生成に成功しました。しかし、これら両方の「Type 2」エクスプロイトではROPによるハードニングができず、シェルコードへのジャンプに頼らざるを得ませんでした。また、AEGが生成できたハードニング済みのROP「Type 1」エクスプロイトも2つだけでした。これらの結果から、自動エクスプロイト生成の分野にはさらなる研究の余地が多く残されており、現行の手法は現代的な脆弱性への適用には十分でないことが示されていると考えます。

Challenges Faced.  
ここでは、CROMU00019 [24] を用いて、私たちのツールが Cyber Grand Challenge のバイナリを悪用しようとした際に直面したいくつかの課題を示します。特に、このチャレンジの README で言及されている2番目の脆弱性（具体的には、攻撃者が供給した文字列をデコードする際にスタック上で発生するバッファオーバーフロー）の悪用に焦点を当てます。

私たちがエクスプロイト生成中に直面した主な問題は、オーバーフローしているデータの各バイトについて、それぞれが一つの値に限定されるようなパス述語が存在していたことでした。これらのバイトの値はシンボリック入力に基づいて選ばれているにもかかわらずです。CROMU00019は、そのdecode関数の中でこの問題を示しています。ペイロードの各バイトは、decodeに含まれるswitch文の分岐のいずれかを通り、脆弱な状態を表すパスに制限的な述語を課します。このswitch文の各分岐は、シンボリックデータに基づいて選択されますが、返されるデータは具体的な値であり、これらの各分岐はプログラム内の別々の経路を表しています。従来のAEGアプローチは、シンボリックデータに適切な制約を加えることで、コントロールフローの乗っ取りを実現できると想定していますが、この挙動の場合、decode関数を通じて希望するバイトを出力バッファに配置する*唯一の*経路を見つける必要があります。

この問題の解決策は、脆弱な条件が存在する多数のパスの中から、望ましい制御フローの乗っ取りを実行する単一のパスを探索することです。しかし、現在のエクスプロイト生成技術はこの能力を持っておらず、このようなケースがCGC Qualifierイベントで提示された多くのスタックバッファオーバーフロー脆弱性の悪用を、最新の自動エクスプロイト生成技術では困難にしています。

# XIV. IMPLEMENTATION: EXPLOIT HARDENING

現代の緩和技術に対するエクスプロイトの強化のために、Q [48] のアイデアに基づいたROPチェーンコンパイラを実装しました。これにより、メモリへのデータ書き込みや、ライブラリ内の任意の関数呼び出しなど、最終的な目的を達成するためのROPペイロードを自動的に生成できるようになりました。本セクションでは、Q自体と比較して私たちが行った違いや改良点に焦点を当てます。

私たちのアプローチは、次のステップで構成されています。

- ガジェットの発見。私たちはアプリケーション内のすべての実行可能コードを、すべてのバイトオフセットでスキャンし、ROPガジェットを特定し、その効果に基づいて分類します。たとえば、命令列: mov [ebx], eax; pop ebx; ret はメモリ書き込みとレジスタのロードとして分類されます。分類を行うために、私たちの解析は angr の Path オブジェクトによって提供されるアクション履歴と、Claripy によって提供されるシンボリックな関係を活用しています。
- ガジェットの配置。ROPチェーンコンパイラは次に、*高水準*の動作を実行するために使用できるガジェットの*配置*を決定します。例えば、データをスタックにプッシュするガジェットは、データをポップするガジェットと組み合わせることで、あるレジスタから別のレジスタへデータを移動する配置を作成できます。
- ペイロードの生成。ROPコンパイラが必要なガジェットの配列を特定した後、これらのガジェットを*チェーン*として組み合わせて、高度な処理（例えば、攻撃者が指定した引数を伴うシステムコールの実行など）を実現します。これは、angrのプログラム状態にガジェットの配列を書き込み、それらの出力を指定された引数に制約し、SMTソルバーに対してその入力の解を問い合わせることで行われます。

私たちの実装は、Qとはわずかに異なります。まず、Qではスタックを一時的な記憶領域として利用していませんでした。その理由は明確ではありませんが、一つの説明として、彼らの解析プラットフォームがスタック操作のモデリングをサポートしていなかった可能性があります。または、スタックポインタが必ずしもスタックを指しているとは限らない（したがって、場所が不明である）と仮定した方が、アプローチがより一般的になるからかもしれません。私たちの統合システムでは、スタックポインタがスタックを指しているかどうかを特定できました。なぜなら、私たちのAEG実装で生成したエクスプロイトから、このメタデータを得ていたからです。

もう一つの改良点は、ガジェットの分類に関するものです。Qは*価値サンプリング*手法を用いて特定のガジェットクラスを特定しましたが、この方法ではサンプルのカバレッジが限定的であったため、いくつかのガジェットチェーンを見逃してしまいました。

| Technique                  | Based On                 | Described In |
|----------------------------|--------------------------|--------------|
| Dynamic Symbolic Execution | 様々な方法 [12], [16], [20]   | IV-A2, IX    |
| Veritesting                | Veritesting [5]              | IV-A2, IX    |
| Under-constrained DSE      | UCSE [46]                    | IV-A2, X     |
| Symbolic-Assisted Fuzzing  | Driller [54]                 | IV-A1, XI    |
| Static Analyses            | VSA [6]                      | III-C, VIII  |
| Crash Replay               | Replayer [43]                | V-A, XII     |
| Exploit Generation         | AEG [4]                      | V-B, XIII    |
| Exploit Hardening          | Q [48]                       | V-C, XIV     |
|                            |                              |              |

TABLE I

本論文で実施および評価された分析、それらの分析の基礎となる文献、ならびにそれらについて論じている本論文の各セクション。

私たちの手法では、すべてのガジェットをシンボリックに解析し、高速な解析を維持するために慎重なキャッシュ技術を使用します。

## XV. COMPARATIVE EVALUATION

angrの設計を活用することで、同じコードベース上でこれまでに議論したバイナリ解析技術を再現し、それらの有効性を比較評価することができました。私たちの知る限り、これはこれまでに行われていません。従来の比較は異なる実装上で行われており、実装の違いによって結果に差が生じる可能性が残されていました。Fuzzer本体（AFL）を除き、私たちの解析はすべて同じ解析エンジン上で実装されており、互いに90%以上のコードベースを共有しています。

私たちは、評価を実施するために、DARPAがCGC Qualification Eventのために公開したCGCバイナリのコーパスを使用します。Section II-Bで述べたように、これらのバイナリは複雑さに大きな違いがありますが、分析システムの実装の手間を減らすためにDARPAによって設計されたシンプルな環境モデルを利用しています。

私たちは、CFGリカバリ、動的および静的な脆弱性発見、クラッシュリプレイ、エクスプロイト、およびエクスプロイトハードニングのために実装した手法を評価します。私たちが実装し評価した解析の概要と、それらが基づいている文献、および本論文内で記述しているセクションをまとめたものが、表Iに示されています。

# *A. CFG recovery*

CFGはangrの他の解析の前提として使用されるため、angrのCFGリカバリがどれほど優れているかを理解することは重要です。Section VIIで詳しく議論したように、angrには2つのCFGリカバリアルゴリズムがあります。CFGAccurateは*強制実行*という基本的な手法に依存しており、間接ジャンプ解決のために2つの方法（*バックワードスライシング*と*シンボリックバックトラバーサル*）を提供します。一方、CFGFastは主に再帰的な逆アセンブルとヒューリスティクスを用いて、関数や関数間の制御フローを迅速に特定します。

これらのリカバリ手法の有効性を理解するために、私たちはCFGFastおよびCFGAccurateを、最先端の商用ツールであるIDA Pro 6.9のCFGリカバリとCGCバイナリ上で比較しました。IDA ProがどのようにCFGをリカバリしているかについての詳細な情報はほとんど公開されていませんが、以前の研究[59]の記述や私たち自身の観察に基づき、IDA Proはバイナリを再帰的に逆アセンブルし、シンボルや他のヒューリスティックを用いて位置を特定していると考えています。

| CGC Qualifying Position  | Binaries Crashed |  |  |  |
|--------------------------|------------------|--|--|--|
| First                    | 77               |  |  |  |
| Second                   | 12               |  |  |  |
| Third                    | 57               |  |  |  |
| Fourth                   | 9                |  |  |  |
| Fifth                    | 23               |  |  |  |
| Sixth                    | 57               |  |  |  |
| Seventh                  | 44               |  |  |  |
| Eighth (did not qualify) | 39               |  |  |  |
| Ninth (did not qualify)  | 65               |  |  |  |

TABLE III

CGC予選イベントにおける上位9競技者のクラッシュしたバイナリ数。

バイナリ全体の関数を特定し、その後、軽量なデータフロー解析を用いて間接ジャンプのターゲットをさらに解決します。これは概念的にはCFGAccurateよりもCFGFastに近いものとなっています。正解となるCFG情報が存在しないため、IDAのCFG復元結果と我々のCFG復元結果の間で復元された基本ブロック数と制御フロー遷移数の相対的な比較によって評価を行います。

まず、CFG の完全性を評価するために、CFGFast が特定したブロックとエッジを IDA Pro によって生成されたグラフと比較します。表 II に結果を示します。CFGFast は IDA Pro よりもわずかに高いコードカバレッジを持ち、より多くのエッジを復元しています。これは、CFGFast で使用されている軽量なデータフロー解析とヒューリスティックが、IDA で使われているものよりも高度であるためだと考えられます。いくつかのバイナリで復元結果を手動で分析したところ、CFGFast はコード復元においてより積極的であることが分かりました。IDA Pro はある部分のコードが到達不可能だと判断し、コードとして逆アセンブルしない場合でも、CFGFast はそのような場所をコードとして識別します。これに対する一つの説明として、私たちの手法が*過度に*積極的であり、そのためにそのような場所を誤って識別している可能性が挙げられます。しかし、CGCバイナリの解析ではそのようなケースは特定されていません。

いくつかのバイナリ解析ではエントリポイントからの*到達可能性情報*が必要となるため、IDA Proによって生成されたCFGの*到達可能*部分（つまり、エントリポイントからパスが判明しているブロックからなるCFG）と、angrのCFGAccurate解析によって復元されたCFGとの比較も含めています。表IIに結果を示します。強制実行手法を後方スライシングで改善することにより、angrはCFGの復元能力を大幅に向上させています。しかし、CFGAccurateは*アドホック*なヒューリスティクスを利用していないため、得られるCFGのコードカバレッジはIDA Proのものほど高くありません。より高いカバレッジを得るためには、CFGFastですべて復元された関数をCFGAccurateの開始点として指定することができます。

# *B. Evaluation of Vulnerability Analysis Techniques*

Sections VIIIからXIでは、いくつかの脆弱性発見手法の実装について説明します。ここでは、これらの手法をCGCデータセットに適用した際の比較評価の結果を示します。これらの評価は、評価データセットを取得したDARPAコンペティションの期間に合わせて、24時間のタイムアウトで実施しました。

これらの結果の要約を表IVに示します。さらに、件数についてより良い文脈を提供するために、

|    |                            |                                                        |                              | Blocks                                                       |                                   |                                                   |                                   | Bytes                                                             |                                        | Time (s)                                                  |                                        |
|----|----------------------------|--------------------------------------------------------|------------------------------|--------------------------------------------------------------|-----------------------------------|---------------------------------------------------|-----------------------------------|-------------------------------------------------------------------|----------------------------------------|-----------------------------------------------------------|----------------------------------------|
| M  | A                          | M                                                      | A                            | M                                                            | A                                 | M                                                 | A                                 | M                                                                 | A                                      | M                                                         | A                                      |
|    |                            |                                                        |                              |                                                              |                                   |                                                   |                                   |                                                                   |                                        |                                                           | 1.80                                   |
|    |                            |                                                        |                              |                                                              |                                   |                                                   |                                   |                                                                   |                                        |                                                           | 5.01                                   |
|    |                            |                                                        |                              |                                                              |                                   |                                                   |                                   |                                                                   |                                        |                                                           |                                        |
|    |                            |                                                        |                              |                                                              |                                   |                                                   |                                   |                                                                   |                                        |                                                           | 1.80                                   |
|    |                            |                                                        |                              |                                                              |                                   |                                                   |                                   |                                                                   |                                        |                                                           | 36.96                                  |
|    |                            |                                                        |                              |                                                              |                                   |                                                   |                                   |                                                                   |                                        |                                                           | 34.10                                  |
| 30 | 32.80                      | 47.5                                                   | 53.89                        | 344.5                                                        | 653.56                            | 594                                               | 1178.98                           | 6109.5                                                            | 14641.85                               | 24.78                                                     | 79.46                                  |
|    | 48<br>61<br>37<br>31<br>32 | 関数<br>52.96<br>70.08<br>40.96<br>33.24<br>33.76 | 76.5<br>88<br>74<br>48<br>50 | 関数のエッジ<br>99.62<br>118.74<br>90.76<br>55.22<br>56.28 | 829<br>843<br>496<br>349.5<br>368 | 3589.93<br>3609.45<br>1043.81<br>413.85<br>635.41 | 1188<br>1193<br>759<br>612<br>645 | ブロックのエッジ<br>6487.68<br>6538.52<br>1693.01<br>751.96<br>1089.78 | 14037<br>14296<br>7874<br>6125<br>6323 | 104779.66<br>105007.49<br>21721.85<br>13963.5<br>10883.51 | 1.14<br>0.87<br>1.14<br>23.50<br>27.22 |

TABLE II

CFGFASTとCFGACCURATEが復元したCFGとIDA PROが復元したCFGを比較評価します。すべてのバイナリに対して、それぞれの値の中央値(M)および平均値(A)を示しています。

| Technique                                | Replayable | Semantic Insight | Scalability | Crashes | False Positives |
|------------------------------------------|------------|------------------|-------------|---------|-----------------|
| Dynamic Symbolic Execution               | はい       | 高い             | 低い        | 16      | 0               |
| Veritesting                              | はい       | 高い             | 中程度      | 11      | 0               |
| Dynamic Symbolic Execution + Veritesting | はい       | 高い             | 中程度      | 23      | 0               |
| Fuzzing (AFL)                            | はい       | 低い             | 高い        | 68      | 0               |
| Symbolic-Assisted Fuzzing                | はい       | 高い             | 高い        | 77      | 0               |
| VSA                                      | いいえ     | 中程度           | 高い        | 27      | 130             |
| Under-constrained Symbolic Execution     | いいえ     | 高い             | 高い        | 25      | 346             |

TABLE IV

すべての脆弱性発見手法における評価結果

私たちの手法によって特定されたクラッシュ数を示すために、Table IIIにはCGC予選イベントで競合他社が実際に特定したクラッシュ数も含めています。 チームの総合スコアは単なるクラッシュ数だけに基づいていたわけではないため、予選イベントでの順位と競合他社の位置は相関していません。これらの競合のうち、1位のチーム[27]と7位のチーム[57]は、それぞれ競技会での自分たちの手法についてブログ記事を書いています。いずれのチームも、Drillerと概念的に似ているシンボリック支援型ファジング技術を利用していました。なお、私たちが実装したDrillerは、たまたま1位のチームと同じ数の脆弱性を発見していますが、これは偶然であり（おそらく手法の類似性によるものです）、意図的なものではありません。

動的シンボリック実行について、単独での評価と、Veritesting パス爆発緩和手法を併用した場合の評価の両方を行うことにしました。これらの手法の実装の詳細については、Section IX で説明します。

予想通り、動的記号実行は頻繁にパスの爆発問題に悩まされました。標準的なアプローチでは、CGCバイナリのうち16件で脆弱性が特定されました。パスの爆発問題を部分的に緩和するために設計されたVeritestingでは、11件のみが特定され、脆弱性が特定されたアプリケーションは合計で23件となりました。

私たちは最初、より良い結果が得られたにもかかわらず、Veritestingアプローチが動的シンボリック実行単独の場合よりも少ない脆弱性しか発見できなかったことに驚きました。これら4つのバイナリを調査したところ、Veritestingに内在する興味深いトレードオフを確認しました。Veritestingは効率的なパスのマージを用いてパス爆発を抑制し、これによりパス爆発によって探索が不可能になる前にバイナリのより深い経路まで探索できるのです。しかし、このパスマージによって複雑な式が導入されます（たとえば、eaxレジスタの値が2つのマージされたパス間で異なる場合、マージ後のパスの値は両方の値をエンコードする複雑な式になります）。これにより、制約ソルバに過負荷がかかります。そのため、パスのマージが増えるほど制約ソルバの解決時間が長くなる傾向があります。制約の解決がNP完全問題であるため、複雑さの増加によって、脆弱性が合理的な時間内に到達不可能になることがあります。この結果、Veritestingは動的シンボリック実行ではパス爆発が発生してしまうような浅いバグを特定することはできる一方で、より長いパスでは制約ソルバが過負荷に陥ります。

シンボリック支援型ファジング。支援型ファジングは、文献において非常に効果的であることが証明されています。セクションXIでは、シンボリック支援型ファジング手法の実装例として、Driller [54] と呼ばれる手法について議論します。

このシンボリック支援型ファザーは、ファジングコンポーネントとしてAFLを使用しています。AFLが生成した各入力は、動的シンボリック実行エンジンでトレースされ、入力を慎重に変異させることで到達できるコードのセクションが特定されます。この慎重な変異はシンボリック制約ソルバーによって実施され、入力はさらなる実行と変異のためにAFLに再導入されます。DSEエンジンでトレースされる個々の入力は分岐しない（すべての入力が具体的だから）ため、トレース中にパス爆発は発生しません。また、AFLはコードカバレッジを増加させない入力をすべてフィルタリングすることで、DSEエンジンに渡す入力数を制限しています。

AFLだけでも、CGCサービスのかなり多くの脆弱性を特定できることに言及しておくべきです。実際、私たちのシンボリック支援型ファザーが検出した77個の脆弱性のうち、68個はAFL単独で検出されました。残りの9個はシンボリック支援によって発見されました。

DSEとファジングの比較。さまざまな動的記号実行手法の結果の違いは驚くべきものです。DSEが記号的に支援された手法とほぼ同数の脆弱性を特定すると考えるのは合理的かもしれませんが

![](_page_17_Figure_0.jpeg)

Fig. 1. ファジングと動的シンボリック実行によって発見されたクラッシュパスの長さの比較

ファズィングだけでなく、それ以上の手法が使われています。実際のところ、ファズィングは脆弱性を*ほぼ3倍*も多く特定しました。ある意味で、これは近年のセキュリティ業界の動向を反映しています。すなわち、シンボリック解析エンジンは実用的でないと批判される一方、ファザーはますます注目を集めています。しかし、この状況はここ数年の研究動向――シンボリック実行を重視する傾向――とは対照的に見えます。

これらの手法が発見したクラッシュを引き起こす入力を分析したところ、興味深い結果が得られました。つまり、動的シンボリック実行エンジンによって発見されたエクスプロイトは、*短い*パスを表す傾向があるということです。この結果はFigure 1で示されています。動的シンボリック実行（Veritestingを用いた場合でも）が脆弱性の発見に*失敗*した複数のアプリケーションをいくつかスポットチェックしたところ、これはパスの長さに指数関数的に比例して解析の複雑さが増大するためであると結論付けました。

具体的には、あるパスAが与えられたとき、次の条件分岐の終わりでAが分岐する確率がp<sup>a</sup>だけ存在し、A<sup>1</sup>はジャンプを取るパスを、A<sup>2</sup>はジャンプを取らないパスをそれぞれ進みます。次の条件分岐でも、A<sup>1</sup>とA<sup>2</sup>が同様に分岐する可能性があります。このようにして、分析すべきパスの数は指数関数的に増加し、任意の時点で分析しなければならないパスの数が非現実的な数になる可能性も、実行された基本ブロックの数に指数的に比例します。そのため、一般的な動的シンボリック実行手法は、多くの基本ブロックの実行を必要としない*浅い*クラッシュの発見には適しています。一方で、*深い*クラッシュはパスの爆発によって隠され、到達できなくなる傾向があります。

技術の相対的な効果をさらに理解するために、生成されたテストケースの*コードカバレッジ*を計算しました。その結果、シンボリック実行（Veritesting を含む）は、バイナリごとに平均 330 ブロック（中央値 260）をカバーしていたのに対し、ファジングは 689（中央値 402）、シンボリック支援ファジングは 698（中央値 406）でした。これらの結果から、さらに興味深い結論が導かれます。すなわち、ファジングやシンボリック支援ファジングによって生成されたパスを*グラフ*として組み合わせると、それは CFGAccurate で復元されたものよりも多くのコードカバレッジを持つ CFG を表すことになります（さらに、グラフ内の各エッジは定義上到達可能であるため、完全性も完璧である）、つまり正確なCFG復元アルゴリズムのさらなる改良が必要であることを示唆しています。

アンダーコンストレインド・シンボリック実行。私たちは、angrを拡張してアンダーコンストレインド・シンボリック実行をサポートし、このような手法が私たちのデータセットに対してどれほど有効かをよりよく理解できるようにしました。これらの詳細については、セクションXで説明しています。

UC-angrはCGCバイナリにおいて371件の脆弱性を報告しました。

しかし、この手法は関数を文脈なしで解析するため、静的解析と同様の問題を抱えています。つまり、結果に多くの偽陽性が含まれ、また結果は再現可能ではありません（つまり、クラッシュを引き起こすような入力を生成するのではなく、脆弱性の場所を指摘するだけです）。実際、UC-angrの結果には346件の偽陽性が含まれていることを確認し、真の陽性は25件となり、偽陽性率は93%でした。これはUC-KLEE [46] によって報告されているものと一致しています。

静的バッファ重複検出。ファジング、シンボリック実行、その他の静的解析によって識別された異なるタイプの脆弱性を比較できるようにするため、VSA ベースのメモリ破損検出解析を実装しました。その詳細については、セクション VIII で説明します。

UC-angrと同様に、私たちのVSAの結果もリプレイができず、また誤検知が発生します。全体として、VSAはCGCバイナリにおいて27件の実際の脆弱性を特定しましたが、130件の誤検知も発生し、誤検知率は82.8%となりました。

再実行不可型と再実行可能型の解析について。もう一つの驚くべき結果は、再実行不可な手法（VSAや制約の緩いシンボリック実行）のパフォーマンスが比較的低かったことです。これらの手法は再実行性の要件から解放されているため、より広範なカバレッジを達成できますが、分析時に文脈情報が不足していたため、このデータセットでは非常に多くの誤検出が生じました。誤検出率を合理的な範囲に保つために、（セクションXで述べた通り）積極的な誤検出フィルタリングを実装する必要があり、その結果、多くの正しい検出も同時に除外されてしまいました。

実際のバイナリに対する静的解析技術の向上は、研究の注目が必要な分野であるように思われ、今後の課題の方向性として検討しています。

# *C. Exploitation Evaluation.*

上記の方法でクラッシュが特定された後、その重大性を理解するために、私たちはリプレイおよびエクスプロイトを試みます。

クラッシュのリプレイ。セクションV-Aで議論したように、脆弱性発見解析によって特定されたクラッシュ入力は、環境データ（ランダムシードなど）が解析によって「非ランダム化」されているため、単純にはリプレイできない場合があります。私たちは各CGCバイナリについてクラッシュを分析し、私たちの脆弱性特定手法で脆弱性を特定できなかったバイナリについては、DARPAが提供した参照クラッシュ入力を使用しました。これらのクラッシュ入力のうち、6件は単純にリプレイすることができませんでした。つまり、脆弱性特定エンジンから提供されたクラッシュ入力を単に再実行するだけでなく、バイナリとのやり取りを再解析して、これらのバイナリに存在するチャレンジ―レスポンスコンポーネントを復元する必要がありました。

興味深いことに、DARPAはCGC Qualifying EventのCGCバイナリの作成者に対し、ランダムデータによって制御フローが影響を受けることを禁止する制限を課しています。つまり、Section XIIで述べたReplayerの制限である、ランダムデータの異なる値によって異なるパス述語が導入される問題は、CGCバイナリに対しては該当しません。angrがあるアプリケーションでハングアップしたものの、手動による解析の結果、これはアプローチそのものの問題ではなく、実装上の問題であることが判明しました。そして予想通り、Replayerは残りの5つについて入力仕様を回復することができました。

6つのバイナリは大規模なデータセットとは言えませんが、この結果は、この分野の現行技術がランダムなデータによって引き起こされる制御フローの差異がない場合には、バイナリを十分に処理できることを示唆しています。今後は、より複雑な制御フローを持つ実際のバイナリに対して、これらの技術を評価し、必要に応じて拡張するためのさらなる研究が求められます。

自動エクスプロイト生成。クラッシュを特定し、Replayerで実行した後、私たちはターゲットアプリケーションを確実にクラッシュさせる入力仕様を得ることができます。しかし、このような入力が*悪用可能*とは限りません。例えば、CGCデータセットに多数存在するヌルポインタ参照によるクラッシュは、現代のシステムでは悪用できません。悪用可能な入力とそうでない入力を区別するために、私たちはクラッシュからエクスプロイトの生成を試みます。

私たちは、AEGシステム[4]で提案された手法を用いて、すべてのCGCアプリケーションに対して自動的にエクスプロイトを生成しようと試みました。しかし、これらの手法を使って武器化できたクラッシュのエクスプロイトは、わずか*4*件しかなかったことに驚きました。バイナリをさらに詳しく調査したところ、その理由がわかりました。まず、CGC予選イベントの目的はバイナリの*クラッシュ*を見つけることであり、エクスプロイトを見つけることではありませんでした。そのため、これらのバイナリに存在する多くの脆弱性は実際にはエクスプロイト可能ではありません（たとえば、ヌルポインタの参照など）。次に、CGCバイナリは幅広い現実的なエクスプロイトシナリオをモデル化しているため、AEGで提案された手法の多くは、それらの大部分には適用できないこともわかりました。

この分野における現在の最先端技術はかなり基本的なものであり、それがこれらの結果にも表れています。複雑な脆弱性を自動的に活用するためには、この分野でさらなる研究が必要です。

エクスプロイト・ハードニング。たとえ悪用可能な脆弱性があったとしても、最新の保護機能によって被害を軽減できる可能性があります。その結果、*エクスプロイト・ハードニング* が求められており、最近の研究でも検討されています。私たちは Q [48] によって提案された手法を再実装し、AEG によって生成されたエクスプロイトの強化を試みました。

Q実装は、AEGが生成した4つのエクスプロイトのうち2つを防御することができました。残りの2つのエクスプロイトを防御できなかった理由について分析したところ、Q手法はバイナリ内の十分な情報を活用していないことが判明しました。これら2つの例では、スタック上に攻撃者が制御できるデータが十分に存在せず、プログラムの他の部分で攻撃者が制御するデータを使うために*スタックピボット*が必要になります。Q手法では、そのような操作について考慮する仕組みがないため、これらのエクスプロイトは防御できません。

#### XVI. CONCLUSIONS

本論文では、angrというシステムを紹介した。このシステムは、バイナリに存在する脆弱性の自動識別および悪用のための複数の手法を、統一された枠組みの中で実装している。我々は、これらの異なる解析手法と、それらをフレームワークに組み込む際に直面した課題について、体系的に述べた。これらのアプローチを一つのシステム内で実装することで、これらの手法の評価用に作成したデータセット上でその効果を有意に比較することができた。この評価の結果は、今後の研究の方向性を示したり、既存手法を改良するための基礎として活用できる。

私たちはangrをオープンソース化しました。これは、コミュニティがその上に構築を重ね、バイナリ解析分野での未解決の課題に取り組むことへ注力できるようにするためです。

Acknowledgements. 本研究は、契約番号 N66001-13-2-4039 の DARPA および契約番号 N00014-15-1-2948 の ONR の支援を受けて実施されています。米国政府は、ここに記載されている著作権表示にかかわらず、政府目的のためにリプリントを複製し配布する権限を有します。

#### REFERENCES

- [1] American Fuzzy Lop. http://lcamtuf.coredump.cx/afl/.
- [2] OWASP Top 10 プロジェクト。http://http://www.owasp.org.
- [3] XcodeGhostマルウェア。http://www.apple.com/cn/xcodeghost/ #english.
- [4] T. Avgerinos、S. K. Cha、B. L. Tze Hao、D. Brumley。AEG: Automatic Exploit Generation。*Proceedings of the 18th Annual Network and Distributed System Security Symposium (NDSS'11)*、2011年。
- [5] T. Avgerinos, A. Rebert, S. K. Cha, and D. Brumley. Veritestingによるシンボリック実行の強化。ページ 1083–1094、2014年。
- [6] G. Balakrishnan, T. Reps, D. Melski, and T. Teitelbaum. WYSINWYX: What You See Is Not What You eXecute. *Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)*, 4171 LNCS:202–213, 2008.
- [7] T. Bao, J. Burket, M. Woo, R. Turner, and D. Brumley. BYTEWEIGHT: バイナリコード中の関数認識のための学習手法。*Proceedings of the 23rd USENIX Security Symposium*、ページ845–860、2014年。
- [8] C. Barrett、L. De Moura、A. StumpによるSMT-COMP: Satisfiability modulo theories competition。*Computer Aided Verification*に収録、20–23ページ。Springer、2005年。
- [9] S. Bekrar、C. Bekrar、R. Groz、L. Mounier。スマートファジングのためのTaintベース手法。*Software Testing, Verification and Validation (ICST), 2012 IEEE Fifth International Conference on* にて、818–825ページ。IEEE、2012年。
- [10] Bloomberg Business. 病院の機器はあなたの命を救うこともあれば、あなたの個人情報をハッキングされる原因にもなり得ます。http://www.bloomberg.com/features/2015-hospital-hack/.
- [11] P. Boonstoppel, C. Cadar, and D. Engler. RWset: 制約ベースのテスト生成におけるパス爆発の問題への対処. *Tools and Algorithms for the Construction and Analysis of Systems* の第4963巻 (LNCS)、351–366ページ. Springer Berlin Heidelberg、2008年.
- [12] C. Cadar、D. Dunbar、D. Englerによる論文。KLEEは、複雑なシステムプログラムに対して高カバレッジなテストを自動的かつ支援なしに生成するツールです。*Proceedings of the 8th USENIX Symposium on Operating Systems Design and Implementation (OSDI'08)*、第8巻、209–224ページ、2008年。
- [13] C. Cadar, V. Ganesh, P. M. Pawlowski, D. L. Dill, and D. R. Engler. EXE: Automatically Generating Inputs of Death. *Proceedings of the 13th ACM Conference on Computer and Communications Security*, ページ 322–335, 2006年.
- [14] G. Campana. Fuzzgrind: 自動ファジングツール。*Actes du 7eme symposium sur la s ` ecurit ´ e des technologies de linformation et ´ des communications (SSTIC)*, ページ 213–229, 2009年。
- [15] D. Caselden、A. Bazhanyuk、M. Payer、L. Szekeres、S. McCamant、および D. Song。「Transformation-aware Exploit Generation using a HI-CFG」。テクニカルレポート、DTIC Document、2013年。
- [16] S. K. Cha, T. Avgerinos, A. Rebert, and D. Brumley. Unleashing Mayhem on Binary Code. In *Proceedings of the IEEE Symposium on Security and Privacy*, pages 380–394, 2012.
- [17] S. K. Cha, M. Woo, and D. Brumley. Program-Adaptive Mutational Fuzzing. In *Proceedings of IEEE Symposium on Security and Privacy*, volume 2015-July, pages 725–741, 2015.
- [18] P. Chen, X. Xing, B. Mao, L. Xie, X. Shen, and X. Yin. x86上でのジャンプ指向プログラミングシェルコードの自動構築について。*Proceedings of the 6th ACM Symposium on Information, Computer and Communications Security*、20–29ページ、ACM、2011年。
- [19] V. Chipounov、V. Georgescu、C. Zamfir、G. Candea。Selective Symbolic Execution。*Proceedings of the 5th Workshop on Hot Topics in System Dependability*, 2009年。
- [20] V. Chipounov、V. Kuznetsov、G. CandeaによるS2Eは、ソフトウェアシステムの実行中マルチパス解析のためのプラットフォームです。*Proceedings of the sixteenth International Conference on Architectural Support for Programming Languages and Operating Systems* に掲載されており、ページは265–278、発行年は2011年です。
- [21] C. Cifuentes と M. Van Emmerik. バイナリコードからジャンプテーブルの case 文を復元する方法について述べています。*Proceedings of the Seventh International Workshop on Program Comprehension*、192–199 ページ、IEEE、1999 年。
- [22] P. M. Comparetti、G. Wondracek、C. Kruegel、E. Kirdaによる論文で、Prospex: Protocol Specification Extractionについて述べられています。これは*Proceedings of the 2009 IEEE Symposium on Security and Privacy*に収録されており、該当箇所は110–125ページです。IEEEより2009年に発表されました。
- [23] DAPRA. DARPA Cyber Grand Challenge. http: //www.cybergrandchallenge.com/.
- [24] DARPA. CyberGrandChallengeのサンプルgitリポジトリ。https://github.com/CyberGrandChallenge/samples.
- [25] L. De Moura と N. Bjørner による Z3: An Efficient SMT Solver。 *Proceedings of the Theory and Practice of Software, 14th International Conference on Tools and Algorithms for the Construction and Analysis of Systems*, TACAS'08/ETAPS'08 に収録、ページ 337–340、ベルリン、ハイデルベルク、2008年、Springer-Verlag。
- [26] D. EnglerとD. Dunbarによる「Under-constrained Execution: Making Automatic Code Destruction Easy and Scalable」。*Proceedings of the 2007 international symposium on Software testing and analysis*に収録、2007年、1–4ページ。
- [27] ForAllSecure. Mayhem CRSの解き放ち. http: //blog.forallsecure.com/2016/02/09/unleashing-mayhem/.
- [28] P. Godefroid, N. Klarlund, and K. Sen. DART: Directed Automated Random Testing. In *Proceedings of the 2005 ACM SIGPLAN Conference on Programming Language Design and Implementation*, volume 40, pages 213–223, 2005.
- [29] P. Godefroid, M. Y. Levin, and D. Molnar. SAGE: Whitebox Fuzzing for Security Testing. *ACM Queue*, 10(1):20, 2012.
- [30] I. Haller、A. Slowinska、M. Neugschwandtner、H. Bos。Dowser: バッファオーバーフローの脆弱性を見つけるためのガイド付きファザー。*Proceedings of the 22nd USENIX Security Symposium*、49–64ページ、2013年。
- [31] S.-K. Huang, M.-H. Huang, P.-Y. Huang, C.-W. Lai, H.-L. Lu, および W.-M. Leong. CRAX: 攻撃をシンボリック継続としてモデル化することによる自動エクスプロイト生成のためのソフトウェアクラッシュ解析。In *Software Security and Reliability (SERE), 2012 IEEE Sixth International Conference on*, pages 78–87. IEEE, 2012.
- [32] Indefinite Studies. リバースエンジニアにとっての停止問題. http://indefinitestudies.org/2010/12/19/the-halting-problem-for-reverseengineers/.
- [33] J. Kinder と H. Veith による Jakstab: バイナリのための静的解析プラットフォーム。*Proceedings of the 20th international conference on Computer Aided Verification* の中で、423–427ページ、ベルリン、2008年。Springer-Verlag。
- [34] C. Kruegel, W. Robertson, F. Valeur, and G. Vigna. 難読化されたバイナリの静的逆アセンブル。*Proceedings of the 13th USENIX Security Symposium*、第13巻、18–18ページ、2004年。
- [35] V. Kuznetsov、J. Kinder、S. Bucur、G. Candeaによる「Efficient State Merging in Symbolic Execution」。*Proceedings of the 2012 ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI'12)*の193ページ、2012年。
- [36] J. Lee、T. Avgerinos、D. Brumley。「TIE: Principled Reverse Engineering of Types in Binary Programs」。*第18回Network and Distributed System Security Symposium (NDSS'11)*、2011年。
- [37] Y. Li, Z. Su, L. Wang, and X. Li. Steering Symbolic Execution to Less Traveled Paths. In *Proceedings of the 2013 ACM SIGPLAN international conference on Object Oriented Programming Systems Languages & Applications*, pages 19–32, 2013.
- [38] B. P. Miller, L. Fredriksen, and B. So. UNIXユーティリティの信頼性に関する実証的研究。*Communications of the ACM*, 33(12):32–44, 1990年。
- [39] C. Miller. コードカバレッジを利用したファジングの事例紹介。https: //fuzzinginfo.files.wordpress.com/2012/05/cmiller toorcon2007.pdf.
- [40] M. Muller-Olm と H. Seidl による論文。線形代数を用いた精密な手続き間解析について述べています。*Proceedings of the 31st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages*、第39巻、330–341ページ、2004年に掲載されました。
- [41] J. A. Navas, P. Schachte, H. Søndergaard, and P. J. Stuckey. Signedness-Agnostic Program Analysis: Precise Integer Bounds for Low-Level Code. In *Lecture Notes in Computer Science (including*

*subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)*、7705 LNCS巻、115–130ページ、2012年。

- [42] M. Neugschwandtner, P. Milani Comparetti, I. Haller, and H. Bos. The BORG: Nanoprobing Binaries for Buffer Overreads. In *Proceedings of the 5th ACM Conference on Data and Application Security and Privacy*, pages 87–97. ACM, 2015.
- [43] J. Newsome, D. Brumley, J. Franklin, and D. Song. Replayer: バイナリ解析による自動プロトコルリプレイ。*Proceedings of the ACM Conference on Computer and Communications Security*、311–321ページ、2006年。
- [44] F. Perez と B. E. Grangerによる IPython: 対話的な科学計算のためのシステム。*Computing in Science and Engineering*, 9(3):21–29, 2007年5月。 http://ipython.org.
- [45] J. Pewny、B. Garmany、R. Gawlik、C. Rossow、T. Holz による "Crossarchitecture bug search in binary executables"。*Proceedings of the 2015 IEEE Symposium on Security and Privacy*（2015年7月号）、709–724ページ、2015年。
- [46] D. a. RamosとD. Englerによる「Under-Constrained Symbolic Execution: Correctness Checking for Real Code」。これは*Proceedings of the 24th USENIX Security Symposium*の49–64ページに掲載され、2015年に発表されました。
- [47] P. Saxena、P. Poosankam、S. McCamant、D. Song. Loop-Extended Symbolic Execution on Binary Programs. *第18回国際ソフトウェアテストおよび分析シンポジウム論文集*、225ページ、2009年。
- [48] E. Schwartz, T. Avgerinos, and D. Brumley. Q: Exploit hardening を簡単に実現する方法について述べています。*Proceedings of the 20th USENIX Security Symposium*、第8巻、25ページ、2011年。
- [49] E. J. Schwartz, T. Avgerinos, および D. Brumley による “All You Ever Wanted to Know About Dynamic Taint Analysis and Forward Symbolic Execution (but Might Have Been Afraid to Ask)” は、*Proceedings of the 2010 IEEE Symposium on Security and Privacy*（SP '10）、2010年、ワシントンD.C.、IEEE Computer Societyに掲載されており、317～331ページに渡って詳細に解説されています。
- [50] B. Schwarz、S. Debray、G. Andrewsによる論文「Disassembly of Executable Code Revisited」は、*Proceedings of Ninth working conference on Reverse engineering, 2002*に収録されており、ページは45–54、IEEEより2002年に発表されました。
- [51] D. K. Sean Heelan. *Automatic Generation of Control Flow Hijacking Exploits for Software Vulnerabilities*. PhD thesis, University of Oxford computing laboratory, 2009年9月.
- [52] H. Shacham. The Geometry of Innocent Flesh on the Bone: Returninto-libc without Function Calls (on the x86). In *Proceedings of the 14th ACM Conference on Computer and Communications Security*, volume 22, pages 552–561, 2007.
- [53] Y. Shoshitaishvili, R. Wang, C. Hauser, C. Kruegel, and G. Vigna. Firmalice - バイナリファームウェアにおける認証バイパス脆弱性の自動検出。*Proceedings of Network and Distributed System Security Symposium*、番号 February、8–11ページ。Internet Society、2015年。
- [54] N. Stephens, J. Grosen, C. Salls, A. Dutcher, R. Wang, J. Corbetta, Y. Shoshitaishvili, C. Kruegel, および G. Vigna. Driller: 選択的シンボリック実行によるファジングの強化。*Network and Distributed System Security Symposium* の論文集、2016年。
- [55] L. Szekeres、M. Payer、T. Wei、およびD. Song。SoK: Memoryにおける終わりなき戦い。*Proceedings of the IEEE Symposium on Security and Privacy*に掲載、2013年、ページ48–62。
- [56] K. Thompson. 信頼を信頼することについての考察。*Communications of the ACM*, 27(8):761–763, 1984年8月。
- [57] Trail of Bits Blog. Cyber Grand Challengeでの私たちの成果について。http://blog.trailofbits.com/2015/07/15/how-we-fared-in-the-cybergrand-challenge/.
- [58] J. Troger と C. Cifuentes による "Analysis of Virtual Method Invocation for Binary Translation"。*Proceedings of Ninth Working Conference on Reverse Engineering, 2002* に収録、ページ 65–74。IEEE、2002年。
- [59] L. Xu、F. Sun、Z. Suによる「Constructing Precise Control Flow Graphs from Binaries」*University of California, Davis, Tech. Rep*, 2009年。
- [60] F. Yamaguchi, N. Golde, D. Arp, and K. Rieck. コードプロパティグラフを用いた脆弱性のモデリングと発見について述べています。*Proceedings of the 2014 IEEE Symposium on Security and Privacy* に掲載されており、ページは590–604、2014年発行です。
- [61] F. Yamaguchi, A. Maier, H. Gascon, and K. Rieck. Taintスタイルの脆弱性に対するサーチパターンの自動推論について記述しています。*Proceedings of the 2015 IEEE Symposium on Security and Privacy*の2015年7月号、797–812ページ、2015年に掲載されました。
- [62] M. Zalwski. Bunny the Fuzzer Documentation. http: //code.google.com/p/bunny-the-fuzzer/wiki/BunnyDoc.
