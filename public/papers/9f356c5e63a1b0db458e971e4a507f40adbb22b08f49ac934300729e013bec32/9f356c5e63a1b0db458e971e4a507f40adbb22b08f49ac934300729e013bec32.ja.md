# (State of) The Art of War: Offensive Techniques in Binary Analysis

Yan Shoshitaishvili、Ruoyu Wang、Christopher Salls、Nick Stephens、Mario Polino、Andrew Dutcher、John Grosen、Siji Feng、Christophe Hauser、Christopher Kruegel、Giovanni Vigna UC Santa Barbara

{yans,fish,salls,stephens,mario,dutcher,jmg,slipper,christophe,chris,vigna}@cs.ucsb.edu

*Abstract*—バイナリコードにおける脆弱性の発見と悪用は、困難な作業です。データ構造や制御構造に関する高水準で意味的に豊かな情報が不足しているため、プログラムの特性を分析することがより困難で大規模化しにくくなります。しかし、バイナリアナリシスの重要性は高まっています。多くの場合、バイナリアナリシスが、*実際に* 実行されているコードに関する特性を証明（または否定）する唯一の方法となります。

本論文では、過去に提案された複数の解析手法を実装したバイナリ解析フレームワークを紹介する。この手法群の体系的な実装により、他の研究者がこれらを組み合わせたり、新しいアプローチを開発したりすることが可能となる。さらに、これらの手法を統一されたフレームワーク内で実装することで、各手法を直接比較し、それぞれの利点と欠点を特定することができる。本論文に含まれる評価は、バイナリ脆弱性解析手法の有効性を評価するためにDARPAが最近作成したデータセットを用いて実施している。

私たちのフレームワークはオープンソース化されており、セキュリティコミュニティで利用可能です。

#### I. INTRODUCTION

インタプリタ言語やワールドワイドウェブの台頭にもかかわらず、バイナリ解析はコンピュータセキュリティの分野で依然として非常に重要な話題のままです。これにはいくつかの理由があります。まず、インタプリタ言語自体がバイナリプログラムによって解釈されたり、もしくはJust-In-Time（JIT）コンパイルによってバイナリコードに変換されたりしています。次に、「コア」となるOSの構成要素やパフォーマンスが重要なアプリケーションは、依然として（通常はCやC++などの）バイナリコードにコンパイルされる言語で記述されています。さらに、Internet of Thingsの普及によって登場したデバイスは、一般的に非常に限られたリソースしか持っていません。インタプリタやJust-In-Timeコンパイルに費やす余裕がないため、こうしたデバイスのファームウェアも、やはりCなどのバイナリにコンパイルされる言語で書かれている傾向があります。

残念ながら、多くの低水準言語はほとんどセキュリティ保証を提供しておらず、それがしばしば脆弱性の原因となっています。例えば、バッファオーバーフローは、こうした脆弱性を緩和する技術が開発されてきたにもかかわらず、依然として最も一般的なソフトウェア上の欠陥の一つとして根強く残っています。さらに悪いことに、「メモリ破壊脆弱性」と呼ばれるより広い範囲の脆弱性の大部分も、安全でない言語の使用に起因しており、こうした脆弱性が一般的な脆弱性の大きな割合を占めています [2]。この問題は汎用計算機上のソフトウェアに限ったものではありません。スマートロックやペースメーカー、さらには自動車まで、さまざまな機器でリモートから悪用可能な脆弱性が発見されています [10]。

もう一つ重要な点は、コンパイラやツールチェーンにバグがないわけではないということです。プログラムのソースコードを解析して証明された性質が、同じプログラムをコンパイルした後には必ずしも成り立つとは限りません。このようなことは実際に起きています。最近では、Xcodeの悪意あるバージョンであるXcode Ghostが、コンパイル時に悪意のあるコードを挿入することで40以上の人気iOSアプリケーションにひそかに感染し、何百万人ものユーザーのデバイスを危険にさらしました。こうした脆弱性は重大で現実的な影響をもたらすため、悪用される前に発見することが非常に重要です。この目的のために、セキュリティ研究コミュニティはバイナリプログラムの欠陥を特定するための解析技術の開発に多大な努力を注いできました。このような解析技術は、調査対象のアプリケーションに対する「攻撃」を見つけることから「オフェンシブ」と呼ばれ、アプローチや対象となる脆弱性の種類は多岐にわたりますが、主に2つの問題点を抱えています。

まず、バイナリ解析技術の多くの実装は、研究用のプロトタイプとして誕生し、その役割を終えます。こうなると、その貢献のために費やされた多くの努力が無駄になり、将来の研究者はこれらの手法に基づく作業を実装する際に、しばしば一から始めなければなりません。このような立ち上げコストは進歩を阻害します。以前の技術を再実装するのに毎週費やされる時間は、新しい解決策を開発するために使える時間が減ることを意味します。

第二に、これらのシステムを再現するために必要な作業量と、それらが一般公開されていないことが多いという事情のため、結果の再現は非現実的になります。その結果、個々のバイナリ解析技術の*適用性*が、他の技術と比べて明確でなくなります。これに加え、現代のオペレーティングシステムの本質的な複雑さや、アプリケーションとその環境との相互作用を正確かつ一貫してモデル化することの難しさにより、比較のための共通基盤を確立するのは非常に困難です。比較が存在する場合であっても、異なる実装の詳細や異なる評価データセットを持つシステム同士を比較している傾向があります。

最初の問題を緩和するために、私たちは angr というバイナリ解析フレームワークを作成しました。これは、文献にある最新のバイナリ解析技術の多くを統合したものです。私たちはこの分野を体系化し、次世代のバイナリ解析技術の開発を促進することを目指して、現在の研究で提案されている有効な技術を、誰でも利用しやすくオープンで実用的な形で実装しました。これにより、個々の技術を簡単に相互比較できるようにしています。angr は

© 2016, Yan Shoshitaishvili. IEEEのライセンスの下で提供されています。DOI 10.1109/SP.2016.17

![](_page_0_Picture_16.jpeg)

多くの種類の分析のための基本要素となり、静的および動的両方の手法を用いることで、提案された研究アプローチを容易に実装でき、その有効性を互いに比較することができます。さらに、これらの基本要素は、分析を*合成*することで、それぞれの強みを活用することも可能にします。

過去1年間で、研究の再現性を念頭に置いて、分析手法やツールを比較するための第2の問題に対する解決策も導入されました。具体的には、DARPAがCyber Grand Challengeを主催し、自動バイナリ解析、脆弱性発掘、エクスプロイト生成、ソフトウェアパッチ作成の現状を探るためのコンペティションを開催しました。この競技の一環として、DARPAは自動解析システムに現実的な課題を提示するために特別に設計されたアプリケーション群のコーパスを作成し、これらの課題に対する*ground truth*（ラベル付けされた脆弱性やエクスプロイト）を提供しました。このバイナリのデータセットは、近年提案されている様々な分析手法の相対的な有効性を測定するための理想的なテストスイートとなっています。さらに、DARPA CGCの予選イベントでは、世界中のチームがこれらのバイナリに対して攻撃・防御を行う自動バイナリ解析システムを投入しました。これらの結果は公開されており、既存の攻撃手法と競技参加者が提供した最先端の手法とを比較する機会を提供しています1。

私たちの目標は、現代の攻撃技術の相対的な有効性を、これらをバイナリアナリシスシステムに実装することで理解することです。本稿では、次世代バイナリアナリシスエンジンである angr の実装について詳述します。これらの技術を使用して開発した複数の攻撃的解析（具体的には、現在文献で説明されている手法の再現）を提示し、脆弱性発見、エクスプロイトの再現、自動エクスプロイト生成、ROP シェルコードのコンパイル、エクスプロイトのハードニングといった分野での結果を再現します。また、これらの技術を組み合わせて機能を拡張することで克服した課題や達成した改良点についても説明します。共通の解析エンジン上にこれらを実装することで、アプローチごとの理論的な違いに起因する効果の差異を、基盤となる解析エンジンの実装差とは切り離して調査できます。これにより、DARPA の提供したデータセットを用いたこれらの手法の比較評価が可能となりました。

要約すると、私たちは以下の貢献を行います。

- 1) 我々は、既存の攻撃的バイナリ解析手法の多くを、単一で統一されたフレームワーク上で再現し、現在の攻撃的バイナリ解析技術の相対的な有効性を理解することを目指しています。
- 2) 多様なバイナリアナリシステクニックを組み合わせて大規模に適用する際の困難さと、その困難さへの解決策を示します。
- 3) 私たちは、将来のバイナリコード解析の研究のために、私たちのフレームワークである angr をオープンソース化します。

上位7チームそれぞれに75万ドルの賞金が贈られました。この動機づけにより、各チームは利用可能な中で最良の分析を行ったと私たちは期待しています。

#### II. AUTOMATED BINARY ANALYSIS

研究者たちは、長年にわたり自動化されたバイナリ解析技術の開発に取り組んできました。しかし、この分野で近年進歩が見られるにもかかわらず、現実世界でそのようなシステムを開発し運用することは依然として困難です。というのも、手法によっては、現実のソフトウェアに対して自動解析を実現するために克服しなければならない深刻な制約が存在するからです。このセクションでは、自動解析の課題に触れ、なぜDARPA Cyber Grand Challengeコンテストがさまざまな解析手法を比較するための有意義な方法を提供できるのかについて議論します。

#### *A. Trade-offs*

バイナリ解析が難しい理由は明白です。「クラッシュするか？」という問いは、ある意味「停止するか？」という問いと同じであり、このような解析はすぐに停止問題[32]に直面します。プログラム解析、特に攻撃的なバイナリ解析は、現実的な実行可能性を保つために、慎重にバランスを取った理論的なトレードオフに導かれる傾向があります。このようなトレードオフを行わなければならない主な領域は2つあります。

リプレイ可能性。バグにはさまざまな種類があります。システムがどのようなトレードオフを選択するかによって、ある解析で発見されたバグが必ずしも「リプレイ可能」とは限りません。これは、解析が動作する「スコープ」に関わっています。いくつかの解析手法はアプリケーション全体を最初から実行し、脆弱性を引き起こすために「正確に」何を行えばよいかを論理的に把握できます。一方、他のシステムはアプリケーションの個別部分だけを解析します。これにより、特定のモジュール内でバグを発見できても、そのモジュールの実行をどのように「引き起こす」かまでは論理的に考察できません。そのため、クラッシュを自動的に「リプレイ」することはできないのです。

Semantic insight. 一部の解析手法では、プログラムについて意味的に有意な方法で推論する能力が不足しています。たとえば、動的解析はアプリケーションによって実行されたコードを追跡することはできても、「なぜ」そのコードが実行されたのかや、「どの部分」の入力がアプリケーションをその特定の動作に導いたのかを理解することはできません。一方で、特定のプログラム動作の原因となる入力バイトを特定できるようなシンボリック解析であれば、より高い意味的理解を持っていると言えるでしょう。

リプレイ可能性のある入力やセマンティックな洞察を提供するためには、解析手法はある種のトレードオフを行わなければなりません。例えば、高いリプレイ可能性は低いカバレッジと関連しています。これは直感的です。なぜなら、リプレイ可能な入力を生成する解析手法は、解析したいコードに到達する方法を理解しなければならないため、リプレイ可能性を考慮しない解析手法ほど多くのコードを解析することができないからです。一方で、バグを検証するためのトリガー入力をリプレイできない場合、バグのリプレイ可能性を優先しない解析手法は、多くの*偽陽性*（実際の脆弱性ではない欠陥検出）が発生することになります。リプレイ可能な入力がない場合、これらの偽陽性はヒューリスティックによってフィルタリングされる必要があり、結果として偽陰性を引き起こす可能性があります。

同様に、解析対象のプログラムについて意味的な洞察を得るためには、大量のデータを保存し処理しなければなりません。例えば、意味的な洞察を持つ動的解析では、特定の分岐が実行されるために成立しなければならない条件を保存することがあります。一方で、静的解析では、選択したデータ領域によって意味的な洞察の深さが調整されます。より単純なデータ領域（つまり、実際の値ではなく*範囲*を追跡するなど）は、意味的な洞察の度合いが低くなります。

再現性と高いセマンティックな理解の両方を試みる分析は、スケーラビリティの問題に直面します。エントリーポイントからアプリケーション全体、そして取り得るすべてのアクションにわたってセマンティック情報を保持するには、あらゆる可能な条件下でプログラムを実行する場合と本質的に同じ程度の処理能力が必要となります。このような分析はスケールしないため、実用に供するためには情報を捨て、「*健全性*」（すなわち、潜在的な脆弱性をすべて発見できるという保証）を犠牲にしなければなりません。

これらの基本的な課題に加えて、実装に関する課題も存在します。その中で最も大きなものが*環境モデル*です。高度なセマンティックな理解を要する解析は、アプリケーションが環境とどのように相互作用するかをモデル化しなければなりません。現代のオペレーティングシステムにおいて、このような相互作用は非常に複雑です。たとえば、Linuxの最新バージョンには三百以上のシステムコールが含まれており、解析システムが完全であるためには、それらすべての影響をモデル化しなければなりません。

例. バイナリアナリシスにおけるさまざまな課題を示すために、いくつかの脆弱性を含むプログラムの具体例を Listing 1 に示します。わかりやすさと紙面の都合から、この例は簡略化されており、後ほど本文で議論する内容の考え方を読者に紹介することだけを目的としています。

memcpyへの3つの呼び出しを観察してください。10行目と30行目の呼び出しではバッファオーバーフローが発生しますが、16行目の呼び出しでは発生しません。しかし、追跡する情報量によっては、静的解析手法は3つ全てのmemcpyの呼び出しを潜在的なバグとして報告するかもしれません。これは、16行目にバッファオーバーフローが発生しないことを判断するための情報を持っていないためです。さらに、静的解析によるレポートにはこれらのバグの位置は含まれますが、それらを引き起こす入力は提供されません。

ファジングのような動的手法は、発見されたバグを引き起こす実際に使える入力を生成できるという利点があります。一方で、単純なファジング手法は通常、浅いバグしか見つけられず、厳密に作り込まれた入力が必要なコードを通過することができません。リスト1では、動的手法は10行目のバグを発見するのが難しいでしょう。これは、その条件を満たす特定の入力が必要だからです。しかし、30行目のオーバーフローはランダムなテストによって引き起こすことができるため、ファジング手法によってバグを引き起こす入力を見つけることができるはずです。

バグを10行目で見つけるために、多くの可能な入力を同時に考慮できる抽象的なデータモデルを導入する方法があります。その一つのアプローチがDynamic Symbolic Execution (DSE) です。しかし、ダイナミックシンボリック技術は強力である一方で、「パス爆発問題」という課題に直面します。これは、分岐ごとにパスの数が指数関数的に増加し、すぐに手に負えなくなってしまう現象です。シンボリック実行を使えば、10行目のバグを検出し、制約ソルバーを利用してそのバグを引き起こす入力を生成できます。また、16行目のmemcpyがオーバーフローしないことも証明できるはずです。しかし実行時には、バグを引き起こさない経路が多すぎるため、30行目のバグはおそらく見つけられないでしょう。

```
1 int main(void) {
2 char buf[32];
4 char *data = read_string();
5 unsigned int magic = read_number();
7 // difficult check for fuzzing
8 if (magic == 0x31337987) {
9 // buffer overflow
10 memcpy(buf, data, 100);
11 }
13 if (magic < 100 && magic % 15 == 2 &&
14 magic % 11 == 6) {
15 // Only solution is 17; safe
16 memcpy(buf, data, magic);
17 }
19 // Symbolic execution will suffer from
20 // path explosion
21 int count = 0;
22 for (int i = 0; i < 100; i++) {
23 if (data[i] == 'Z') {
24 count++;
25 }
26 }
28 if (count >= 8 && count <= 16) {
29 // buffer overflow
30 memcpy(buf, data, count*20);
31 }
33 return 0;
34 }
```
リスト1：異なる手法が異なるバグを報告する例。

#### *B. The DARPA Cyber Grand Challenge*

2013年10月、DARPAはDARPA Cyber Grand Challenge [23] を発表しました。他分野（ロボティクスや自律走行車など）でのDARPA Grand Challengeと同様に、CGCでは世界中から集まったチームが互いに競い合い、すべての参加者が自律プログラムでなければなりません。Cyber Grand Challengeにおける参加者の目標は明確です。システムは与えられたソフトウェアの脆弱性を自律的に発見し、利用し、修正しなければなりません。数百万ドル規模の賞金が発表されており、CGC Qualifying Event（2015年6月開催）を完了した上位7チームにはそれぞれ750,000ドル、CGC Final Event（2016年8月開催）での上位3チームにはそれぞれ2,000,000ドル、1,000,000ドル、750,000ドルが授与されます。

Cyber Grand Challenge の主催者たちは、自動化されたバイナリ解析システムのための競技を設計するにあたり、様々な点に深く配慮しています。たとえば、*環境モデル* の問題に対応するため、CGC 専用の新しい OS を開発しました。それが DECREE OS です。DECREE は非常にシンプルなオペレーティングシステムで、システムコールはわずか7つしかありません。transmit、receive、waitfd はファイルディスクリプタを介したデータの送信・受信・待機用、random はランダムデータの生成用です。

Certainly! Please provide the Markdown paragraph you would like translated into natural Japanese.

I'm sorry, but there is no paragraph to translate. Please provide the Markdown paragraph you would like translated into Japanese.

I'm sorry, but there is no paragraph to translate. The input "12" does not contain any Markdown paragraph. If you provide the text you want translated, I'll be happy to help!

I'm sorry, but there is no prose to translate in "18". If you have a paragraph you would like me to translate, please provide the full text.

I'm sorry, but there is no paragraph to translate. If you provide a Markdown paragraph, I'll be happy to translate it for you.

I'm sorry, but there is no Markdown paragraph provided to translate. Please provide the text you would like me to translate.

メモリ管理のための割り当てと解放、そして終了するための終了処理を行います。

簡単な環境モデルにもかかわらず、DARPAがCGCのために提供したバイナリは非常に多様な複雑さを持っています。サイズは4キロバイトから10メガバイトまでさまざまであり、機能も単純なエコーサーバからウェブサーバ、画像処理ライブラリに至るまで幅広く実装されています。DARPAはこれまでに競技で使用されたすべてのバイナリを、概念実証用のエクスプロイトや脆弱性に関する解説付きでオープンソース化しています [24]。

単純な環境モデルにより、大規模にバイナリ解析手法を正確に実装・評価することが可能になるため、本論文の比較評価にはDARPA CGCのサンプルをデータセットとして使用しています。

#### *C. Comparative Analysis of CGC Binaries*

攻撃的なバイナリ解析は、対象となるアプリケーションを解釈するためにさまざまな基礎技術を用います。例えば、異なる*ドメイン*でデータを解析したり、テスト対象のアプリケーションとのさまざまなレベルの相互作用を利用したりすることがあります。次の2つのセクションでは、現在の最先端技術を概観し、この論文の残りの部分で詳細に評価するいくつかの解析手法を選びます。ここでは特に、バイナリソフトウェアの脆弱性（たとえば、シンボリック実行を用いたメモリ安全性違反の特定）の識別および悪用を目的とした解析に焦点を当てます。それに対して、これらの解析の基礎となるより一般的なバイナリ解析技法そのもの（この場合はシンボリック実行自体）には焦点を当てません。

# III. BACKGROUND: STATIC VULNERABILITY DISCOVERY

静的手法は、プログラムを実行せずにその内容を解析します。通常、プログラムは*抽象領域*上で解釈されます。ビット列で構成されるメモリ領域には、他の抽象的な存在が含まれます（身近な例としては整数ですが、後述するようにより抽象的な構成要素を含む場合もあります）。さらに、メモリのレイアウトや実行経路といったプログラムの構成要素自体も、抽象化されることがあります。

ここでは、静的解析を2つのパラダイムに分けます。1つはプログラムの特性をグラフ（つまり、*制御フローグラフ*）としてモデル化するもの、もう1つはデータ自体をモデル化するものです。

静的脆弱性識別技術には、セクションII-Aで議論されたトレードオフに関連する2つの主な欠点があります。第一に、結果が「再現可能」ではありません。静的解析による検出は、検出された脆弱性をどのように引き起こすかという情報が得られないため、手作業で確認する必要があります。第二に、これらの解析はより単純なデータ領域で動作する傾向があり、そのため「意味的な洞察」が低下します。要するに、これらは過剰に近似します。つまり、特定のプログラム特性（たとえば脆弱性）の「不在」については確実に推論できる一方で、脆弱性の「存在」に関しては高い誤検出率に悩まされがちです。

#### *A. Recovering Control Flow*

命令の基本ブロックがノードとなり、それらの間のエッジが可能な制御フロー遷移を表す*control-flow graph*（CFG）の復元は、ほとんどすべての脆弱性発見のための静的手法における前提条件となっています。

制御フローのリカバリは、既存の文献でも広く議論されている [21], [33], [34], [50], [58], [59]。CFGリカバリは再帰的なアルゴリズムとして実装されており、基本ブロック（例えばBa）を逆アセンブルして解析し、その*出口*（つまり後続の基本ブロック、例えばB<sup>b</sup>やBc）を特定し、CFGにまだ追加されていない場合は追加し、B<sup>a</sup>からB<sup>b</sup>やBcへの接続を行い、さらにB<sup>b</sup>やB<sup>c</sup>についても再帰的に解析を繰り返す。これを新たな出口が見つからなくなるまで続ける。CFGリカバリには本質的な課題がひとつある。それは間接ジャンプである。間接ジャンプは、制御フローがレジスタやメモリ上の値で指定されたターゲットへと移る場合に発生する。*直接*ジャンプと異なり、直接ジャンプではターゲットが命令自体にエンコードされているため容易に解決できるが、間接ジャンプのターゲットは様々な要因によって変化しうる。特に、間接ジャンプはいくつかのカテゴリに分類される。

- 計算によるジャンプ。計算によるジャンプのターゲットは、コードで指定された計算をアプリケーションが実行することによって決定されます。この計算は、他のレジスタやメモリ内の値に依存する場合もあります。この一般的な例としてジャンプテーブルがあります。アプリケーションは、レジスタやメモリ内の値を使ってメモリ上に格納されたジャンプテーブルのインデックスを決定し、そのインデックスからターゲットアドレスを読み取り、そこにジャンプします。
- コンテキスト依存。間接ジャンプはアプリケーションのコンテキストに依存する場合があります。一般的な例としては、標準Cライブラリの qsort() があります。この関数は、渡された値を比較するために*コールバック*を受け取ります。その結果、qsort() 内部の基本ブロックのジャンプ先のいくつかは、呼び出し元がコールバック関数を提供するため、呼び出し元によって決まります。
- オブジェクトセンシティブ。コンテキストセンシティブの特別なケースとして、オブジェクトセンシティブがあります。オブジェクト指向言語では、オブジェクトの多態性により仮想関数の使用が求められます。これは多くの場合、関数ポインタの*仮想テーブル*として実装されており、実行時にジャンプ先を決定するために参照されます。そのため、ジャンプ先は呼び出し元が関数に渡すオブジェクトの型に依存します。

さまざまな間接ジャンプの種類に対応するために、異なる手法が考案されており、そのいくつかの実装についてはセクションVIIで説明します。最終的に、CFG復元の目的は、できるだけ多くのこれらの間接ジャンプのターゲットを*解決*し、CFGを作成することにあります。ある間接ジャンプは、*値の集合*（例えば、ジャンプテーブル内のすべてのアドレス。特定の条件下でその使用が引き起こされる場合）に解決される場合があり、この集合はオブジェクト感度やコンテキスト感度に基づいて変わることがあります。ジャンプターゲットがどれだけ正確に解決できるかによって、CFG復元解析には次の2つの特性があります。

健全性。CFGリカバリ手法が*健全*であるとは、すべての潜在的な制御フロー遷移が生成されたグラフに表現されている場合を指します。つまり、間接ジャンプが実際に到達可能なアドレスの*部分集合*にしか解決されなかった場合、グラフの健全性は低下します。基本ブロックの潜在的なターゲットが見逃されると、CFGリカバリアルゴリズムがそのブロックを認識できず、そのブロックから行われるすべての直接・間接ジャンプも見逃されることになります。これは累積的な効果をもたらし、間接ジャンプの解決に失敗するとグラフの完全性が著しく損なわれる可能性があります。健全性はバイナリにおける間接ジャンプターゲット識別の*真陽性率*と考えることができます。

完全性。完全なCFGリカバリでは、すべてのエッジが実際に可能な制御フロー遷移を表すCFGが構築されます。CFG解析が*完全性*を重視しすぎると、実際には存在し得ないエッジが含まれる可能性が高くなります。完全性は、間接ジャンプ先識別の*偽陽性*率の逆であると考えることができます。

空のグラフを生成するCFGリカバリ解析は「完全」であると見なされ、すべての命令が他のすべての命令を指すグラフを生成する解析は「健全」であると考えられます。<sup>2</sup> 理想的なのはその中間ですが、スケーラブルなアルゴリズムでこれを実現するのは困難です。したがって、異なる解析ごとに両者の間で異なる妥協が必要になります。

制御フローグラフに関するさらなる困難は、*コードカバレッジ*、つまり制御フローグラフによって発見されるコードの範囲を正確に測定することです。これはしばしば、いかなるジャンプからも到達不可能な*デッドコード*の存在によって複雑になります。

#### *B. Vulnerability Detection with Flow Modeling*

プログラムの一部の脆弱性は、プログラム特性のグラフを解析することで発見することができます。

グラフベースの脆弱性発見。プログラムプロパティグラフ（たとえば、制御フローグラフ、データフローグラフ、制御依存グラフなど）は、ソフトウェア内の脆弱性を特定するために使用することができる。これらの手法は当初ソースコードに適用されていたが [60], [61]、その後バイナリにも拡張されている [45]。このような手法では、制御フローグラフやデータ依存グラフ上のノードの集合としてバグのモデルを構築し、このモデルがアプリケーション内で現れる箇所を特定することに依存している。しかし、この種の手法は主に脆弱なコードのコピーを検索するためのものであり、既に存在する脆弱性に関する事前知識から恩恵を受けることができる。一方で、本論文の焦点は、これらの手法とは異なり、まったく新しい脆弱性の発見にある。

# *C. Vulnerability Detection with Data Modeling*

静的解析は、アプリケーションが操作するデータの抽象化についても推論することができます。

Value-Set Analysis. 一般的な静的解析手法のひとつに、*Value-Set Analysis*（VSA）[6]があります。大まかに言うと、VSAは任意の時点におけるプログラムの状態（*つまり*、メモリやレジスタに格納されている値）について、できるだけ厳密な過大近似を特定しようとします。

2Xu et. al. は、CFGの健全性と完全性を逆の方法で定義しており、空のグラフが健全で、完全なグラフが完全であるとしています [59]。本論文では、セクションIII-Aで示した定義に従います。

プログラム。これは、間接ジャンプの可能なターゲットや、メモリ書き込み操作の可能なターゲットを理解するために利用できます。これらの近似は精度に欠けるという問題がありますが、「健全性」を持っています。つまり、過大に近似することはあっても、不足して近似することはありません。

メモリの読み書きの近似的なアクセスパターンを解析することで、バイナリ内の変数やバッファの位置を特定することができます。この作業が完了した後、復元された変数やバッファの位置をさらに解析し、*重なり合っている*バッファを見つけることができます。このような重複したバッファは、例えばバッファオーバーフローの脆弱性によって引き起こされる可能性があり、各検出は潜在的な脆弱性の一つとなります。

# IV.

#### BACKGROUND: DYNAMIC VULNERABILITY DISCOVERY

Dynamic approachesは、特定の入力が与えられた際にプログラムがどのように動作するかを、実際の環境やエミュレートされた環境で実行しながら調査する手法です。このセクションでは、これらの手法の中でも、基盤となる一般的なバイナリアナリシス技術ではなく、脆弱性の特定に使用される動的手法に焦点を当てて解説します。

動的手法は大きく2つのカテゴリ、具体的実行と記号実行に分けられます。これらの手法は非常に*再実行可能*な入力を生成しますが、*意味的な洞察*という点では違いがあります。

#### *A. Dynamic Concrete Execution*

動的コンクリート実行とは、最小限に計測された環境でプログラムを実行するという概念です。プログラムは通常通りに動作し、通常動作時と同じ*ドメイン*のデータ（つまり、0と1）を扱います。これらの解析は、通常、単一経路のレベルで推論を行います（つまり、「この特定の入力を与えたとき、プログラムはどの経路をたどったか」）。そのため、動的コンクリート実行にはユーザーが*テストケース*を用意する必要があります。これは問題となります。なぜなら、大規模または未知のデータセット（私たちのもののように）では、そのようなテストケースが容易には用意できないからです。

*1) Fuzzing:* 動的な具体的実行が脆弱性発見のために最も関連して応用されているのがファジングです。ファジングは、アプリケーションに異常な入力を与え、クラッシュを引き起こそうとする動的手法です。最初は、このような入力はハードコードされたルールによって生成され、実行の詳細な監視はほとんど行わずにアプリケーションに与えられていました [38]。特定の入力でアプリケーションがクラッシュした場合、その入力がバグを引き起こしたとみなされました。そうでない場合は、その入力がさらにランダムに変異されます。残念ながら、ファザーには*テストケース*の要件という問題があります。変異させるために注意深く作成されたテストケースがなければ、ファザーはプログラムの表面的な機能しか試すことができません。

Coverage-based fuzzing. コードカバレッジに基づくファジングの登場により、慎重に作成されたテストケースの必要性は部分的に軽減されました[39]。コードカバレッジベースのファザーは、対象アプリケーション内で実行されるコード量を最大化する入力を生成しようとします。これは、より多くのコードが実行されることで、脆弱なコードが実行される可能性が高まるという考えに基づいています。American Fuzzy Lop (AFL) [1]は、コードカバレッジの指標のみを指針とする最先端のファザーであり、多くの最近の脆弱性を発見した実績があります。その成功により、近年ファジングへの関心が高まっています。

カバレッジベースのファジングは、ターゲットアプリケーションに対するセマンティックな洞察が欠けているという問題があります。これは、コードの特定の部分がまだ実行されていないことを検出することはできても、そのコードを実行させるために入力のどの部分を変異させるべきかを理解できないことを意味します。

Taintベースのファジング。ファジングを改善する別のアプローチとして、*taint-based*ファザーの開発があります[9]、[62]。これらのファザーは、アプリケーションが入力をどのように処理するかを分析し、次回以降の実行で入力のどの部分を変更すべきかを理解します。これらのファザーの中には、taintトラッキングとデータ依存性の回復[30]、[42]などの静的手法を組み合わせているものもあります。また、プロトコル解析の成果を取り入れてファジングのカバレッジを向上させているものもあります[22]。

テイントベースのファザーは、プログラム内で特定の経路に実行を導くために入力のどの部分を変異させるべきかを理解できますが、それでもその入力を*どのように*変異させればよいかについては把握していません。

*2) Dynamic Symbolic Execution:* シンボリック手法は、静的解析と動的解析のギャップを埋め、ファジングの限定的なセマンティック情報の課題に対処するための解決策を提供します。ダイナミック・シンボリック・エグゼキューションはシンボリック・エグゼキューションの一種であり、動的な手法として、プログラムをエミュレートされた環境で実行します。しかし、この実行は*シンボリック変数*の*抽象的*な領域で行われます。これらのシステムはアプリケーションをエミュレートしながら、プログラム実行中のレジスタやメモリの状態と、変数に対する*制約条件*を追跡します。条件分岐に到達すると、実行は分岐して*両方*のパスをたどり、分岐を通ったパスには分岐条件を、通らなかったパスには分岐条件の逆を、それぞれパス上の制約として保存します[49]。

ファジングとは異なり、動的シンボリック実行はターゲットアプリケーションに対して非常に高い意味的な洞察を持っています。このような技術は、蓄積されたパス制約を利用して、実行中のパスのいずれかで解析が関心を持つ条件が引き起こされた場合に、そこに到達するための適切な入力を後から生成することで、特定の望ましいプログラム状態を*どのように*引き起こすか推論することができます。これにより、ソフトウェアのバグを特定する上で非常に強力なツールとなり、その結果、動的シンボリック実行は現在非常に活発な研究分野となっています。

古典的な動的シンボリック実行。動的シンボリック実行は、ソフトウェアの脆弱性を直接発見するために利用することができる。当初はソースコードのテストに適用されていたが [12], [13]、Mayhem [16] や S2E [19] によってバイナリコードにも拡張された。これらのエンジンは、パス探査を実行しながらアプリケーションを解析し、脆弱な状態（例えば、攻撃者の入力によって命令ポインタが上書きされる場合）が特定されるまで探索を続ける。

しかし、II-A節で述べたトレードオフがここで問題となります。現在提案されている全てのシンボリック実行手法は、「パス爆発」と呼ばれる問題により、きわめて限定的なスケーラビリティしか持っていません。これは、各分岐で新たなパスが生成されるため、プログラム内のパスの数が、各パスに含まれる分岐命令の数に対して指数関数的に増加するからです。パス爆発を乗り越えるために、有望なパスを*優先*させる方法 [11], [37] や、適切な状況下でパスを*統合*する方法 [5], [35], [47] などが試みられてきました。しかし一般的には、純粋な動的シンボリック実行解析エンジンにとって、この課題は依然として克服されておらず（本論文の後半で示すように）、このようなシステムによって発見されるバグのほとんどは*浅い*ものです。

Symbolic-assisted fuzzing。パス爆発問題への対応策の一つとして、より高速な手法であるファジングに多くの処理をオフロードする方法が提案されています。このアプローチは、ファジングの強み、つまりその高速性を活かし、最大の弱点であるアプリケーションに対する意味的な理解の不足を補うことを目指しています。そのため、研究者たちはファジングとsymbolic executionを組み合わせています [14], [15], [17], [28], [29], [54]。このような*symbolically-guided fuzzers*は、ファジングコンポーネントによって特定された入力を動的symbolic executionエンジンで処理することで改変します。動的symbolic executionは、解析対象プログラムをより深く理解し、適切に入力を変異させることで、新たなテストケースを生成し、これまで探索されていなかったコードを実行させ、ファジングコンポーネントがコードカバレッジの観点で更なる進展を続けられるようにします。

制約不十分なシンボリック実行。動的シンボリック実行の実用性を高めるもう一つの方法は、アプリケーションの*一部*のみを実行することです。このアプローチは、制約不十分なシンボリック実行として知られており、*潜在的な*バグの特定に効果的ですが、2つの欠点があります。第一に、アプリケーションの一部を実行する際に適切な実行コンテキストを保証することができず、そのため結果の中に多くの偽陽性が混じってしまいます。第二に、静的脆弱性検出技術と同様に、制約不十分なシンボリック実行は拡張性を優先する代わりに、検出したバグの再現性を犠牲にします。

#### V. BACKGROUND: EXPLOITATION

脆弱性発見の解析は、実際には*クラッシュを引き起こす入力*を発見します。これらのクラッシュ入力をトリアージする、すなわち、どのクラッシュが実際のセキュリティ問題を示しているかを理解することは、ほとんどの手法の範囲外です。しかし、発見された脆弱性の再現や解析に関する研究もいくつか存在します。本節では、特定されたクラッシュを再現するプロセス、クラッシュのセキュリティ影響を検証するためにエクスプロイトを自動生成する方法、そして現代の緩和技術のもとでエクスプロイトを堅牢化する方法について説明します。

# *A. Crash Reproduction*

ほとんどの脆弱性発見解析は、テスト対象のアプリケーションを現実とはやや異なる条件下で実行します。たとえば、多くのファザーは*ランダム性の排除*を行います。つまり、実行ファイルのPIDや現在時刻など、ランダム性のある要素をハードコーディングします。これには主に2つの理由があります。第一に、現代の多くのファジング手法では、同じ入力をアプリケーションの2つのインスタンスに与えた場合、両方で同じ結果が得られるという暗黙の前提があります。第二に、動的シンボリック実行など他の手法におけるランダム性のモデリングは、あまり研究が進んでいない分野です。

非ランダム化（de-randomization）によって、脆弱性発見手法で報告されたクラッシュは、解析環境外では簡単には再現できないことがあります。例えば、あるアプリケーションがランダムなトークンを生成し、そのトークンをユーザーに入力させてから危険なコード領域に入ってクラッシュするケースを考えてみましょう。非ランダム化された解析環境では、生成されるトークンは常に同じ値となり、解析によって特定されたクラッシュを引き起こす入力は毎回同じ経路を辿り、クラッシュが発生します。しかし、解析環境*外部*では、トークンは毎回異なるため、それまでクラッシュしていた入力が*クラッシュしない*経路を辿る可能性があります。

再現が容易でないクラッシュ入力は、一般的に2つのカテゴリに分類されます。

- 欠落データ。脆弱性発見手法では、時としてアプリケーションからレスポンス値を受け取る前に、正しい値を「推測」できてしまう場合があります。この例で使われているトークンは、デランダマイズされた環境では常に一定の値になっており、fuzzerのような解析エンジンは、プログラムからその値を最初に取得せずに偶然当ててしまうことがあります。その結果得られたクラッシュ入力を解析環境外で再現しようとすると、トークン値が一致せず、クラッシュが発生しません。
- 関係性の欠如。ファジングのように意味的な洞察が低い手法では、プログラムから取得したデータとその後プログラムに提供されるデータとの*関係性*を把握することができません。たとえば本例では、クラッシュを引き起こす入力によってアプリケーションがユーザーにトークンを提供し、それが後でクラッシュを引き起こすために使われる場合でも、ファザーの出力には、アプリケーションがユーザーに提供するトークン値と、ユーザーがアプリケーションに提供すべきトークン値との間の関係性が含まれていません。

データが欠落している場合、入力は解析環境の外では単純に再現できず、新たなクラッシュを引き起こす入力が見つかる可能性があります。データ漏洩の特定を専門とする解析手法も存在します [42] が、私たちはまだそのような解析をangrに実装していません。

後者の場合、デランダム化されたクラッシュ入力は、アプリケーションとの通信方法を定義する*入力仕様*に変換する必要があります。このとき、アプリケーションから受け取るデータと後でそれに提供するデータとの関係に基づいて仕様を定めます。この課題への一つのアプローチとして、Replayer [43] があります。これは、実環境下でプログラムの実行経路を再現する方法を理解するために、プログラム経路に対する事前条件を算出します。

# *B. Exploit Generation*

上記で説明したいずれかの手法を利用した効率的な脆弱性発掘エンジンを使うことで、テスト対象となるアプリケーションに対して多くのクラッシュが発生する可能性があります。しかし、これらのクラッシュすべてが悪用可能というわけではありません。悪用不可能な入力の例としてはNULLポインタのデリファレンスがあります。現代のオペレーティングシステムではアドレス0にメモリを割り当てることが禁止されているため、以前は悪用可能だった状況も、現在では悪用不可能なクラッシュにとどまっています。クラッシュが悪用可能かどうかを理解することはバグのトリアージ（すなわち、どのバグを優先的に調査・修正すべきかを判断すること）に役立ちます。

クラッシュが悪用可能かどうかをテストする最も明白な方法は、実際にそれを悪用しようとすることです。この目的のために、クラッシュを引き起こす入力を自動的にアプリケーション用のエクスプロイトへと変換しようとするいくつかのシステムが提案されています [4], [31], [51]。

# *C. Exploit Hardening*

近年、非実行スタック領域やアドレス空間配置のランダム化（ASLR）などのバイナリ強化技術によって、従来型のエクスプロイト、例えば第一世代の自動エクスプロイトエンジンによって生成されるものなどの有効性は大きく低下しています。そのため、たとえ悪用可能な脆弱性が存在しても、最新の防御機構によって対策される可能性があります。

現在の自動化されたエクスプロイト手法は、最新の緩和技術が広く採用される以前に設計されたものであり、現代のソフトウェア保護機構によって、それらが生み出すエクスプロイトは機能しなくなっています。この問題を回避するため、現在の手法で生成されたエクスプロイトをそのような防御策に対して自動的に*強化*するアプローチが考案されています。これらの技術は、従来のシェルコードベースのエクスプロイトを、Return-Oriented Programming を利用した同等のエクスプロイトに変換することで機能します。そのため、Return-Oriented Program を自動的に構築する手法が必要となり、いくつかのアプローチが開発されています。

# VI. ANALYSIS ENGINE

III、IV、およびV節で説明した分析は、過去数年にわたりさまざまな時期に提案され、異なる技術で実装され、異なる方法論でさまざまなデータセットに対して評価されてきました。これは問題であり、異なるアプローチの相対的な有効性や、それらがさまざまなタイプのアプリケーションにどのように適用できるかを理解するのが難しくなります。

この問題を解決するために、私たちは柔軟で高機能な次世代のバイナリアナリシスシステムであるangrを開発し、前節で紹介したいくつかの解析手法を実装しました。本節では、この解析システムと、その設計目標、さらにこの設計が現実的なバイナリの解析に与えた影響について説明します。

#### *A. Design Goals*

angr の設計目標は以下のとおりです。

- クロスアーキテクチャ対応。組み込みデバイスの普及により、これらはしばしばARMやMIPSプロセッサ上で動作しており、現代のソフトウェアはさまざまなハードウェアアーキテクチャ向けに作られています。これは、ほとんどの解析エンジンにx86のサポートだけで十分だった以前の10年とは異なる状況です。現代のバイナリ解析エンジンは、クロスアーキテクチャ解析を実行できる必要があります。さらに、32ビットプロセッサはもはや標準ではなくなっており、現代の解析エンジンは64ビットバイナリの解析をサポートしなければなりません。
- クロスプラットフォーム対応。クロスアーキテクチャ対応と同様に、現代の分析システムはさまざまなオペレーティングシステムのソフトウェアを解析できる必要があります。これは、個別のオペレーティングシステムに固有の概念を理解することを意味します。

システムは抽象化され、さまざまな実行可能ファイル形式の*ロード*をサポートする機能を実装する必要があります。

- 異なる解析パラダイムへの対応。有用な解析エンジンは、前のセクションで述べた幅広い解析に対応できる必要があります。そのためには、エンジン自体が抽象化されており、さまざまな種類のメモリモデルやデータドメインを提供できなければなりません。
- ユーザビリティ。angrの目的は、セキュリティコミュニティにとって、バイナリ解析の手法を再現・改善・作成する際に役立つツールを提供することです。そのため、angrの習得コストを低く抑え、使いやすさを重視しています。angrはほとんどがPythonで実装されており、IPythonのインタラクティブシェル[44]から簡単に利用できる、簡潔でシンプルなAPIを備えています。Pythonは他の言語選択肢に比べて実行速度が常にやや劣るものの、多くのバイナリ解析手法は*アルゴリズム的*な遅さに起因するため、言語による性能低下が問題になることはほとんどありません。言語のオーバーヘッドが*重要*になる場合には、angrをPythonのJITエンジンであるPyPy上で実行することで、大幅な高速化が期待できます。

私たちの目標は、angrを使って、典型的なバイナリアナリシステクニックをプラットフォーム上で約1週間で再現できるようにすることでした。実際には、Veritesting [5]を8日で再現でき、ガイデッド・シンボリック・エグゼキューションは1か月、AEG [4]は週末で、Q [48]は約3週間で、underconstrained symbolic execution [46]は2日で実現できました。動的シンボリックエグゼキューションや値集合解析については、システム自体を2年間かけて構築する過程で実装したため、実装にかかる労力の見積もりを出すのは難しいです。

これらの設計目標を達成するために、私たちは分析エンジンを慎重に構築する必要がありました。そのために、さまざまな分析のためのモジュール式の構成要素を作成し、それぞれの間に厳密な分離を保つことに注意しました。これにより、上位レベルの angr の部分（たとえば状態表現）が下位レベルの部分（たとえばデータモデル）について抱える前提を減らすことができます。これによって、異なる分析手法をその場で組み合わせたり変換したりしやすくなります。また、他の研究者も angr の個々のモジュールを再利用しやすくなることを期待しています。次のいくつかのセクションでは、angr の各サブモジュールの技術的な設計について説明します。

## *B. Submodule: Intermediate Representation*

複数のアーキテクチャをサポートするために、アーキテクチャ固有のネイティブバイナリコードを中間表現（IR）に変換し、その上で解析を実装しています。非常に多くの工数を要する「IRリフタ」を自作するのではなく、ValgrindプロジェクトのIRリフタであるlibVEXを活用しました。libVEXは、プログラム解析向けに特別に設計されたVEXというIRを生成します。私たちはもともとFirmalice [53] のために開発したPyVEXを使い、VEX IR を Python に公開しています。VEXを利用することで、ARM、MIPS、PPC、x86（x86の64ビット版はamd64）プロセッサの32ビット版および64ビット版の解析サポートを提供できます。Valgrindのコントリビューターによる改良は継続的に行われており、例えば現在SPARCアーキテクチャへの移植作業が進行中です。

後ほど説明するように、angrが常にIRとしてVEXを使用しなければならないという根本的な制約はありません。実装上も、別の中間表現をサポートすることは、単純なエンジニアリング作業で実現可能です。

#### *C. Submodule: Binary Loading*

アプリケーションバイナリを解析システムにロードする作業は、CLEと呼ばれるモジュールによって処理されます。CLEは「CLE Loads Everything」の再帰的頭字語です。CLEはさまざまなバイナリ形式を抽象化し、指定されたバイナリやそれが依存するライブラリのロード、動的シンボルの解決、リロケーションの実行、プログラム状態の適切な初期化を行います。CLEを通じて、angrはほとんどのPOSIX準拠システム（Linux、FreeBSDなど）、Windows、およびDARPA Cyber Grand Challenge向けに作成されたDECREE OSのバイナリをサポートしています。

CLEは、バイナリオブジェクト（すなわちアプリケーションバイナリ、POSIXの.so、またはWindowsの.dll）を表す複数の基本クラス、これらのオブジェクト内のセグメントやセクション、そしてそれらセクション内部の位置を示すシンボルを提供することで、バイナリローダの拡張可能なインターフェースを提供します。CLEはファイル形式パース用ライブラリ（具体的にはLinuxバイナリにはelftools、Windowsバイナリにはpefile）を利用してオブジェクトそのものを解析し、その後、必要なリロケーションを実施して*ロード済み*アプリケーションのメモリイメージを公開します。

### *D. Submodule: Program State Representation/Modification*

SimuVEXモジュールは、*プログラム状態*（つまり、レジスタやメモリ内の値、開いているファイル、*など*のスナップショット）を表現する役割を担っています。SimuVEXの用語でSimStateと呼ばれるこの状態は、*ステートプラグイン*の集合として実装されています。これらのプラグインは、ステート作成時にユーザーまたは解析によって指定される*ステートオプション*によって制御されます。現在、以下のステートプラグインが存在しています。

- レジスタ：SimuVEXは、プログラム内の任意の時点でのレジスタの値を、対応するプログラム状態のステートプラグインとして管理します。
- シンボリックメモリ。シンボリック実行を可能にするために、SimuVEXは状態プラグインとしてシンボリックメモリモデルを提供しています。これは、Mayhem [16] で提案されたインデックス付きメモリモデルを実装しています。
- 抽象メモリ。抽象メモリ状態プラグインは、静的解析でメモリをモデル化するために使用されます。連続したインデックス付きメモリモデルを実装するシンボリックメモリとは異なり、抽象メモリは多くの静的解析で使われている*領域*ベースのメモリモデルを提供します。
- POSIX. POSIX対応環境のバイナリを解析する際、SimuVEXはこのステートプラグイン内で*システム状態*を追跡します。例えば、シンボリック状態で開かれているファイルなどがこれに含まれます。各ファイルはメモリ領域とシンボリックな位置インデックスとして表現されます。
- ログ。SimuVEXは、このプラグイン内で状態に対して行われたすべての操作（例：メモリ書き込み、ファイル読取など）のログを記録します。
- インスペクション。SimuVEX は強力なデバッグインターフェースを提供しており、汚染や正確な式構成など、複雑な条件に対してブレークポイントを設定することができます。

シンボリック条件です。このインターフェースは、SimuVEXの挙動を*変更*するためにも使用できます。たとえば、メモリ読み取りを計装して、メモリマップドI/Oデバイスをエミュレートすることができます。

- Solver。Solverは、データモデルプロバイダ（後述のClaripy）を介して、さまざまなデータドメインへのインターフェースを提供するプラグインです。たとえば、このプラグインがシンボリックモードに設定されている場合、レジスタ、メモリ、ファイル内のデータをシンボリックに解釈し、アプリケーションの解析中にパス制約を追跡します。
- アーキテクチャ。architectureプラグインは、解析に役立つアーキテクチャ固有の情報（スタックポインタの名前やアーキテクチャのワードサイズなど）を提供します。このプラグインの情報は、angrの一部として配布されているarchinfoモジュールから取得されています。

これらのステートプラグインは、さまざまな方法で組み合わせることができる構成要素を提供し、さまざまな解析をサポートします。

さらに、SimuVEXは解析の基本単位を実装しています。これは、アプリケーションコードのブロックによってプログラム状態に加えられるセマンティックな変化を表現するものです（SimuVEXの用語では、このようなコードブロックをSimRunと呼びます）。つまり、SimuVEXはVEXで表現されたコードのブロックを通して*入力*状態を処理し、*出力*状態（あるいは、条件分岐ジャンプのように複数の出力状態が生じ得る場合は出力状態の集合）を生成する機能を提供します。このSimuVEXの部分もモジュール化されています。基本ブロックのVEX変換に加えて、SimuVEXは現在、ユーザーが手作業で作成したPython関数をSimRunとして提供することも可能にしています。これにより、Pythonコードでブロックに強力なインストルメント処理を施すことができます。実際、環境モデルの実装もこの方法を利用しています。システムコールは、プログラム状態を変更するPython関数として実装されています。

## *E. Submodule: Data Model*

SimStateのレジスタやメモリに格納されている*値*は、別のモジュールであるClaripyによって提供される抽象化で表現されています。

Claripyは、すべての値を内部的な*式*の表現に抽象化し、その値が使われるすべての操作を追跡します。つまり、式xに式5を加えると、xと5を引数として持つx + 5という式になります。これらの式は「式の木」として表現され、値は葉ノード、操作は非葉ノードになります。

任意の時点で、式はClaripyの*バックエンド*によって提供されるデータドメインに変換することができます。具体的には、Claripyは具体的ドメイン（整数および浮動小数点数）、シンボリックドメイン（Z3 SMT solver [25]によって提供されるシンボリック整数およびシンボリック浮動小数点数）、およびValue Set Analysis [6]用の値集合抽象ドメインをサポートするバックエンドを提供しています。Claripyは他のバックエンドにも容易に拡張可能です。特に、他のSMT solverの実装は興味深いでしょう。というのも、異なるsolverが異なる種類の制約の解決において優れていることが示されているからです [8]。

ユーザーが直接操作する処理、たとえばバックエンドが提供する構成要素（例：Z3バックエンドによって提供される記号式 x+1）をPythonのプリミティブ（たとえば、制約を解いた結果として得られる x+1 の可能な整数解）に変換する処理は、*フロントエンド*によって提供されます。フロントエンドは、バックエンドに対してさまざまな複雑さを持つ追加の機能を付与します。現在、Claripyはいくつかのフロントエンドを提供しています。

- FullFrontend。 このフロントエンドはユーザーに対してシンボリックな解決を提供し、制約を追跡し、Z3バックエンドを用いてそれらを解決し、結果をキャッシュします。
- CompositeFrontend。KLEEやMayhemが提案しているように、制約を独立したセットに分割することでソルバーへの負荷を減らすことができます。CompositeFrontendは、この機能への透過的なインターフェースを提供します。
- LightFrontend。このフロントエンドは制約追跡をサポートしておらず、VSAバックエンドを使ってVSAドメイン内の式を単純に解釈します。
- ReplacementFrontend. ReplacementFrontendは、LightFrontendを拡張し、VSA値に対する*制約*のサポートを追加します。制約（例：x+1 < 10）が導入されると、ReplacementFrontendはその制約を解析し、関連する変数の範囲（例：0 <= x <= 8）を特定します。その後、ReplacementFrontendが変数xの可能な値について参照された際には、あらかじめ決定された範囲とその変数を交差させ、VSA単体では得られない、より正確な結果を提供します。
- HybridFrontend. HybridFrontendは、FullFrontendとReplacementFrontendを組み合わせることで、記号制約解決のための高速な近似サポートを提供します。Mayhem [16] でもこのような機能の可能性が示唆されていましたが、私たちの知る限り、angrは研究コミュニティにこの機能を公開した最初のツールです。

このモジュラー設計により、Claripyはさまざまなデータドメインによって提供される機能を強力な方法で組み合わせ、それをangrの他の部分に提供することができます。

#### *F. Submodule: Full-Program Analysis*

angrのアナリスト向け部分は、動的シンボリック実行や制御フローグラフの復元といった完全な解析機能を提供しています。これらの解析への「エントリーポイント」となるのがProjectであり、これはバイナリとそれに関連するライブラリを表します。このオブジェクトから、他のサブモジュールのすべての機能（例：状態の作成、共有オブジェクトの検査、基本ブロックの中間表現の取得、バイナリコードをPython関数でフックすることなど）へアクセスできます。加えて、全プログラム解析用の二つの主なインターフェースとしてPath GroupsとAnalysesがあります。

Path Groups。PathGroupは動的記号実行のためのインターフェースであり、アプリケーション内を実行するパス、分岐したパス、終了したパスを追跡します。このインターフェースの作成は、記号実行中のパス管理に対するフラストレーションから生まれました。angrの初期開発段階では、記号実行を利用する各解析ごとにパス管理をその場しのぎで実装していました。同じ機能、つまり分岐や結合に伴うパスの階層構造の追跡、注目すべきまたは探索で優先すべきパスの分析、有望でないパスの判断と終了の機能を繰り返し実装していることに気付きました。そこで、パスのグループに対して共通して行われる操作を統一し、PathGroupインターフェースを作成しました。

分析。angr は、Analysis クラスを使って、あらゆる完全なプログラム解析のための抽象化を提供します。このクラスは、制御フローグラフの再構成のような静的解析のライフサイクルや、第IX節で紹介されたような複雑な動的解析の管理を行います。

angr がバイナリについて何らかの *事実*（つまり、「アドレス X の基本ブロックがアドレス Y の基本ブロックにジャンプできる」など）を見つけた場合、それは対応する Project の *knowledge base* に保存されます。この共有された knowledge base により、複数の解析が協力してアプリケーションに関する情報を発見できるようになります。

# *G. Open-Source Release*

私たちは、新しいバイナリアナリシス手法を実装できるプラットフォームを開発することを目標に angr の開発を始めました。実際のバイナリの解析に伴う予期しない課題に直面する中で、このような解析エンジンがセキュリティコミュニティにとって非常に有用であることに気付きました。私たちは、バイナリアナリシスの未来の基盤となり、研究者たちが同じ課題に何度も取り組む負担から解放されることを願って、angr をオープンソース化しました。angr は約65,000行のコードで実装されており、IPythonシェルから直接利用したり、pythonモジュールとしても活用でき、標準的なPythonパッケージマネージャであるpip経由で簡単にインストールできます。

angrのオープンソースリリースには、解析エンジンモジュール（セクションVI-AからVI-Fで説明されています）が含まれており、その上にセクションXVで議論されているアプリケーションを実装しました。後者の中では、制御フローグラフ復元、静的解析フレームワーク、動的シンボリック実行エンジン、および制約の緩いシンボリック実行の実装をオープンソース化しています。今後他のアプリケーションもリリースする予定ですが、現時点ではこれらはプロトタイプレベルのコードであったり、DARPA Cyber Grand Challengeに積極的に活用されたりしている段階です。

angrはコミュニティから非常に高い熱意をもって迎えられています。オープンソースとして公開してから最初の3ヶ月間で、システムを構成するさまざまなモジュールを合わせて、GitHub上で約500件の「スター」（ソフトウェアを高く評価する人の数の指標）を集めました。同じ期間内に、angrはpip経由でおよそ6,000回インストールされ、Gitリポジトリの「クローン」も週平均20回行われていました。angrはすでに、他の教育機関で学生にバイナリ解析を紹介するためのクラスプロジェクトでも少なくとも1度利用された実績があります。さらに、他のいくつかの教育機関が研究用プロトタイプの構築基盤としてangrを利用していることや、複数の企業が商用バイナリ解析システムへの応用を目的として評価していることも把握しています。

# VII. IMPLEMENTATION: CFG RECOVERY

angr が CFG を生成する際に使用するプロセスについて説明します。また、最終的な結果の完全性と健全性を向上させるために開発された特定の手法についても取り上げます。

特定のプログラムが与えられると、angrはプログラムのエントリーポイントから開始して、いくつかの必要な最適化を行いながら反復的にCFGのリカバリを実行します。angrは、*強制実行*、*逆向きスライシング*、および*シンボリック実行*を組み合わせて活用し、可能な限り各間接ジャンプのすべてのジャンプ先を復元します。さらに、ターゲットアプリケーションについて大量のデータを生成して保存し、これらのデータは後のデータ依存性追跡のような他の分析でも使用できます。

このアルゴリズムには主に3つの欠点があります。処理速度が遅いこと、「デッドコード」を自動的に処理しないこと、そして、未解析の間接ジャンプによってのみ到達可能なコードを見逃す可能性があることです。この問題に対応するため、私たちはセカンダリのアルゴリズムを作成しました。このアルゴリズムは、バイナリを迅速に逆アセンブルし（どの基本ブロックも実行せずに）、関数の特定、関数内の制御フロー、および関数間の直接的な制御フロー遷移を識別するヒューリスティックを用います。ただし、セカンダリのアルゴリズムは精度がかなり劣ります。関数間の到達可能性情報がなく、コンテキストに依存しませんし、複雑な間接ジャンプを解析することもできません。

このセクションの残りでは、私たちがCFGAccurateと名付けた高度なリカバリーアルゴリズムについて説明します。続いて、Section VII-Fで高速アルゴリズムCFGFastについて議論します。

#### *A. Assumptions*

angrのCFGAccurateは、アルゴリズムの実行時間を最適化するためにバイナリに関していくつかの仮定を行っています。

- 1) プログラム内のすべてのコードは、異なる関数に分割することができます。
- 2) すべての関数は、明示的な呼び出し命令（またはその同等物）によって呼び出されるか、または制御フロー内で直前にテールジャンプが置かれています（これはしばしば再帰関数でスタック領域を節約するために使われる最適化であり、関数の最後での呼び出しを*ジャンプ*に変更することで、新しく呼び出された関数が単に呼び出し元のリターンアドレスを再利用するようにします）。
- 3) 各関数のスタッククリーンアップの挙動は、その関数がどこから呼び出されても予測可能です。これにより、CFGAccurateは呼び出し元の関数を解析している際に、すでに解析済みの関数を安全にスキップしつつ、スタックのバランスを保つことができます。

これらの仮定は、angrが解析することを想定しているバイナリの種類に制約を課しています。仮定1、2、および3は、解析対象のバイナリが難読化されておらず、「通常通り」に動作することを求めています。難読化されたバイナリや異常なバイナリを解析する場合、これらの仮定を取り除くこと*は可能*ですが、その場合CFGリカバリの実行時間が長くなってしまいます。

私たちのCFGリカバリーのコードは、関連する文献 [21], [34], [50], [58], [59] で提案された手法に基づいて構築されています。しかし、これらの手法は、現実のバイナリに対しては厳しすぎる、あるいは非現実的な仮定をしています。具体的には、私たちはCFGリカバリーの元となったこれらの研究とは異なり、以下のいずれの仮定も行っていません。

1) すべての関数は、呼び出し元の次の命令に戻ります [59]。

- 2) 間接分岐のジャンプ先は常に制御フローパスによって決定され、プログラムの状態やコンテキストによって決まるわけではありません [59]。例えば、既存の文献の中には、間接ジャンプはすべて*計算された*ものであり、以前のコンテキストから関数ポインタとして渡されるものではないと仮定しているものもあります。
- 3) 間接ジャンプのジャンプターゲットの表現は、一般的なイディオムのセットに一致していなければなりません [21], [58]。従来の研究とは異なり、私たちはポインタに適用できる操作の種類については一切仮定しません。
- 4) 関数に入る前と、そこから戻った後で、スタックポインタは同じである。
- 5) 2つの関数が重複することはありません（言い換えれば、基本ブロックを共有することはできません[34]）。CFGAccurateは、コードを共有する関数にも対応しています。
- 6) シンボルテーブルや再配置情報などの追加情報が利用可能である[50]。

実際にバイナリからコントロールフローグラフを復元するアルゴリズムについては、次のいくつかのセクションで説明します。

# *B. Iterative CFG Generation*

残念ながら、どの手法もCFGAccurateの目標である完全かつ正確なCFGの復元を単独では実現できません。そのため、CFGAccurateは複数の手法を組み合わせて交互に適用し、迅速性と完全性の両立を図りながらCFGを構築します。具体的には、強制実行、軽量な後方スライシング、シンボリック実行、値集合解析の4つの手法が利用されます。これらの手法によって反復的に復元されるCFGであるCは、アプリケーションのエントリーポイントにある基本ブロックから初期化されます。

CFGリカバリの過程において、CFGAccurateはジャンプ先が解決されていない間接ジャンプのリスト L<sup>j</sup> を維持します。解析がこのようなジャンプを検出すると、それがL<sup>j</sup>に追加されます。各イテレーティブな手法が終了するたびに、CFGAccurateはリスト内の次の手法を実行します。この次の手法は、L<sup>j</sup>内のジャンプを解決する場合もあれば、新たな未解決ジャンプをL<sup>j</sup>に追加したり、CFG C にベーシックブロックやエッジを追加したりする場合もあります。CFGAccurateは、すべての手法の実行後にL<sup>j</sup>やCに変更がなかった場合、すなわち利用可能な解析ではこれ以上間接ジャンプが解決できないと判定されたときに終了します。

# *C. Forced Execution*

angrのCFGAccurateは、CFGリカバリの最初の段階でDynamic Forced Executionという概念を活用しています [59]。Forced Executionは、あらゆる分岐点で条件分岐の両方の方向が必ず実行されることを保証します。

CFGAccurateは、基本ブロックの作業リストBwと、解析済みブロックのリストBaを管理します。解析が開始されると、作業リストにはCに含まれているがBaには含まれていないすべての基本ブロックが初期化されます。作業リストから基本ブロックを解析すると、その基本ブロックおよびそこからの*直接*ジャンプがCに追加されます。しかし、間接ジャンプはこの方法では処理できません。強制実行下では、間接ジャンプの遷移先が実際のプログラムの実行時とは異なる場合があります。これは強制実行が予期しない順序でコードを実行するためです。そのため、各間接ジャンプは後から解析するためにリストL<sup>j</sup>に保存されます。

間接ジャンプを解決できないため、この解析は迅速なCFG（制御フローグラフ）復元解析として機能し、検出された基本ブロックや未解決の間接ジャンプを他の解析に素早く提供します。

# *D. Symbolic Execution*

動的強制実行の主な問題は間接ジャンプの存在であり、間接ジャンプのターゲットが正しく解決されるかどうかを保証する方法がない点にあります。一方で、間接ジャンプは完全に解決不能な場合もあります（つまり、強制実行の結果、ジャンプターゲットが初期化されていないメモリから読み込まれる状態になる）、この場合、復元されたCFG内に壊れた制御フロー遷移が残ることになります。もう一方で、間接ジャンプは部分的にしか解決できない場合もあります（つまり、解析によって全ての可能なジャンプターゲットの一部しか取得できない場合です）。

各ジャンプ J ∈ L<sup>j</sup> について、CFGAccurate は制御フローグラフ（CFG）を後方にたどり、最初の *マージポイント*（つまり、間接ジャンプに向かう途中で複数の経路が合流する点）を見つけるまで、または所定のブロック数に達するまで探索します（経験的には、適切な閾値は8ブロックであることが分かりました）。そこから、間接ジャンプまで順方向のシンボリック実行を行い、制約ソルバーを用いて間接ジャンプのターゲットとなる可能性のある値を取得します。

CFGAccurate は、計算されたジャンプ先の候補集合が閾値より小さい場合、そのジャンプが解決されたと見なします。この閾値には 256 を使用していますが、実際にはジャンプが*正しく*解決されなかった場合、この値には*制約がありません*（つまり、ジャンプ先の候補集合はアドレスのビット数によってのみ制限されます）。

ジャンプが正常に解決された場合、JはL<sup>j</sup>から削除され、ジャンプ先の各可能な値に対して、CFGにエッジとノードが追加されます。

## *E. Backward Slicing*

angrの強制実行やシンボリック実行による解析は、多くの未解決ジャンプを解決できません。これは*コンテキスト*の不足が原因です。これらの解析はコンテキスト非依存で行われます。そのため、もし関数が引数としてポインタを受け取り、そのポインタが間接ジャンプのターゲットとして使用される場合、解析はそれを解決することができません。

より高い完全性を実現するために、CFG生成にはコンテキストに依存した要素が必要となります。これを実現するために、*backward slicing* を用います。CFGAccurateは未解決のジャンプ地点からバックワードスライスを計算します。このスライスは、直前の *call context* の始点まで拡張されます。つまり、解析対象の間接ジャンプが関数 F<sup>a</sup> にあり、それが F<sup>b</sup> と Fc の両方から呼び出されている場合、スライスは F<sup>a</sup> 内のジャンプ地点から遡り、F<sup>b</sup> の開始位置と Fc の開始位置という2つの開始ノードを含むことになります。

CFGAccurateは次に、このスライスをangrのシンボリック実行エンジンを使って実行し、制約エンジンを用いてシンボリックジャンプの可能なターゲットを特定します。このとき、ジャンプターゲットの解集合のサイズについては同じく256という閾値が使われます。ジャンプターゲットが正常に解決されると、そのジャンプはL<sup>j</sup>から削除され、制御フロー遷移を表すエッジおよびターゲットとなる基本ブロックが復元されたCFGに追加されます。

## *F. CFGFast*

高速CFG生成アルゴリズムの目的は、バイナリ内の関数の位置と内容を少なくとも特定できる、高いコードカバレッジを持つグラフを生成することです。このグラフには多くの*制御フロー*が欠けているため、完全ではありません。しかし、このようなグラフでも、バイナリの手動および自動分析の両方で役立つことがあります。

CFGFastは、以下の手順を実行します。

- 関数の識別。アプリケーション内の関数を識別するために、ByteWeight [7] のような手法から生成されたハードコーディングされた関数プロローグのシグネチャを使用します。アプリケーションに関数の位置を指定する *シンボル* が含まれている場合、それらも関数開始位置としてグラフに追加されます。さらに、プログラムのエントリーポイントを表す基本ブロックもグラフに追加されます。
- 再帰的逆アセンブリ。再帰的逆アセンブリは、特定された関数内の直接ジャンプを復元するために用いられます。
- 間接ジャンプの解決。軽量なエイリアス解析やデータフロー追跡、あらかじめ定義された戦略を組み合わせて、関数内の制御フロー転送を解決します。現在、CFGFast にはジャンプテーブルの識別や間接呼び出しターゲットの解決のための戦略が含まれています。

目標は、関数同士の到達可能性を理解することにはこだわらず、迅速に高いカバレッジを持つCFGを復元することです。

# *G. Using the CFG Recovery*

angrは、CFGリカバリアルゴリズムをCFGFastとCFGAccurateという2つの解析手法として提供しています。これらの解析は、CFGデータをangrのナレッジベースに出力します（セクションVI-Fで説明しています）。このデータは、その後の手動解析や後続の自動解析で利用することができます。

#### VIII. IMPLEMENTATION: VALUE SET ANALYSIS

一度CFGが生成されると、さらに高度な解析を実行することができます。そのひとつがValue-Set Analysis [6]です。Value-Set Analysis (VSA)は、バイナリプログラムに対する数値解析とポインタ解析を組み合わせた静的解析手法です。VSAでは、Value-Set Abstract domainと呼ばれる抽象領域を用いて、各プログラムポイントにおいてレジスタや抽象的な場所が保持している可能性のある値を近似的に算出します。

VSAは、関数内のすべてのプログラムポイントについて*不動点*に到達するまでプログラムを解析します。この不動点は、関数内の任意の時点で任意のレジスタや抽象的なメモリ位置が取り得るすべての値の厳密な過大近似を表しています。例えば、計算されたアドレスAへのメモリ書き込みの場合、計算された不動点におけるAの値を参照することで、すべての可能な書き込み先の完全なリストを得ることができます。

Balakrishnan らによって提案された元々のVSA設計 [6] は、実際のバイナリを解析する際には十分な性能を発揮しません。そのため、VSAをこうしたバイナリに適用するために、私たちは解析の精度を高めるためのいくつかの改良を行う必要がありました。

- 離散的なストライドインターバル集合の作成。VSAの基本データ型であるストライドインターバルは、本質的には数値の集合の近似です。この型は、通常の具体的な値の集合を近似する際には非常に有効です。しかし、これらの値がプログラム内でジャンプ先として使用される場合、ストライドインターバルの過剰近似的な性質により、本来ジャンプ先でないアドレスにも制御フロー遷移が作られ、復元されたCFGにおいて非健全な結果が生じます。この問題を効果的に解決するために、「ストライドインターバル集合」と呼ばれる新しいデータ型を開発しました。これは、ストライドインターバルを結合せずに集合として表現するものです。ストライドインターバル集合は、含まれる要素数がKを超えた場合にのみ、単一のストライドインターバルに結合されます。Kは調整可能な閾値です。Section II-Aで述べた我々のモデルでは、この閾値が意味的な洞察とスケーラビリティのトレードオフを制御しています。Kの値を高く設定すると、高い精度を維持することができますが、その分解析の複雑さが増加します。
- 経路述語に代数ソルバーを適用する。分岐条件を追跡することで、条件分岐の後やマージ手続き中に状態内の変数を制約することができ、より精度の高い解析結果を得ることができる。Affine-Relation Analysis はこれらの条件を追跡する手法として提案されている [40]。しかし、これは実装が複雑であり（一般的に制約式でごく限られた算術演算しかサポートされなくなる）、現実的には計算コストも高い。我々の解決策は、ストライド付き区間ドメイン上で動作する軽量な代数ソルバーを実装することであり、これは一部のアフィン関係を扱えるように剰余算術を基盤としている。新しい経路述語が現れたとき（つまり条件分岐をたどったとき）、それを簡略化して解き、経路述語に関与する変数に対して値の範囲を求めることを試みる。その後、新しく生成された値の範囲と、それぞれの変数の元々の値との間で共通部分を取る。この手法により、新たな分岐条件が現れるたびに value set 解析の結果を継続的に洗練し、最終的な不動点の精度を高めることができる。
- 符号なし／符号付きに依存しないドメインの採用。元々提案された通り、VSA は符号付きストライド区間ドメイン上で動作し、すべての値が符号付きであると仮定している。つまり、nビットのストライド区間で下限を l、上限を h とした場合、常に l ∈ [−2<sup>n</sup>−<sup>1</sup>, 2<sup>n</sup>−<sup>1</sup> − 1] ∧ h ∈ [−2<sup>n</sup>−<sup>1</sup>, 2<sup>n</sup>−<sup>1</sup> − 1] ∧ l ≤ h となる。しかし、この方法では符号なし算術演算の結果が大きく過大近似されてしまう。実際には、この過大近似はジャンプアドレスが符号なしであること、すなわちジャンプアドレスの計算が通常符号なしの値（例：符号なし比較の場合）に依存していることにより、さらに悪化する。この問題を解決するには、解析で符号なし／符号付きに依存しないドメインを採用する必要がある。*Wrapped Interval Analysis* [41] はこのような

LLVMコードを解析するためのインターバルドメインであり、符号付き数値と符号なし数値の両方に同時に対応しています。私たちは、この理論をVSAドメインに適用し、符号情報に依存しないストライド付きインターバルドメインを構築しました。

私たちは、メモリ破損の検出のためにVSAを三つの段階で使用します。まず、VSA中にプログラム内のすべての読み書きアクセスパターンを収集します。これらのアクセスパターンに基づいて、スタック領域とヒープ領域の両方に存在する変数のリカバリを行います。私たちの実装はTIE [36] における変数リカバリと似ています。次に、すべてのスタック領域とヒープ領域を走査し、異常なバッファ（a）重複バッファ、および（b）境界外のバッファを見つけます。その後、すべての異常なバッファを潜在的なメモリ破損として単純に報告します。

## *A. Using VSA*

angrが全プログラムのVSA解析に提供する主なインターフェースは*Value Flow Graph*です。VFGは、各プログラム位置におけるVSAの不動点を表す*プログラム状態*を含む強化版CFGです。VFG解析に渡すパラメータによって、単一の関数、関数呼び出しのツリー、またはプログラム全体を対象とすることができます。

VFGに含まれるプログラム状態は、SimuVEXによって提供される抽象的なレイアウトでメモリを表現しています（具体的には、SimAbstractMemoryメモリモデルを使用）。メモリ内の値は、Claripyによって提供される値集合で表されています。私たちは、メモリアクセスが取り得る値の範囲を分析することで、これらのプログラム状態に含まれるデータに対してバッファオーバーラップ解析を実施しました。

## IX. IMPLEMENTATION: DYNAMIC SYMBOLIC EXECUTION

私たちの解析プラットフォームの動的シンボリック実行モジュールは、主にMayhem [16]で説明されている技術に基づいています。私たちの実装は、同じメモリモデルとパス優先順位付け技法に従っています。このモジュールはangrの主要な機能の一つを構成しており、Veritestingや制約の少ないシンボリック実行などの他の解析もこのモジュールを基盤としています。

私たちは、Claripy のインターフェースを利用して Z3 へアクセスし、SimuVEX が提供するシンボリックメモリモデル（具体的には SimSymbolicMemory）を構築しています。プログラム内の個々の実行経路は angr が提供する Path オブジェクトによって管理されており、これらのオブジェクトは経路上で取られたアクションや経路の述語、その他の経路特有の情報を追跡します。これらの経路のグループは angr の PathGroup 機能によって管理されており、動的シンボリック実行の過程で経路の分岐、統合、フィルタリングを管理するインターフェースを提供します。

angr には Veritesting [5] のネイティブサポートが搭載されており、Veritesting のアナリシスとして実装されているほか、PathGroup オブジェクトにオプションを渡すことで、その機能を簡単に利用できます。この高度な状態マージ手法は、静的かつ選択的にパスを統合することで、状態数が指数関数的に増加する問題の緩和に役立ちます。

# X. IMPLEMENTATION:

# UNDER-CONSTRAINED SYMBOLIC EXECUTION

私たちは、UC-KLEE [46] で提案されたアンダーコンストレインド・シンボリックエグゼキューション（UCSE）を実装し、これをUC-angrと名付けました。UCSEは、各関数ごとに個別に実行を行う動的シンボリックエグゼキューション手法です。分析ではその特定の関数*への到達方法*を推論できないため、UCSEによる検出結果は再現性がありません。また、各関数はそれぞれの*コンテキスト*（すなわち、実際の実行時にどのような引数やグローバル変数とともに呼び出されるか）を考慮せずに生成されるため、分析の精度は低く、誤検出（偽陽性）が発生しやすくなります。

UCSEは、状態内のコンテキストが不足しているタグを*underconstrained*として扱います。このような制約の緩いデータがポインタとして使用されると、新しい制約の緩い領域が作成され、そのポインタは新しい領域を指します。この「オンデマンド」のメモリ割り当てによって、複雑なデータ構造を管理するコードの解析が可能になります。セキュリティ違反が特定された場合（例：スタック上の保存されたリターンアドレスへの書き込み）、関係する値が*under-constrained*かどうかが確認されます。特定の条件下（つまり、すべての関与するデータが制約の緩いものである場合）には、その違反は偽陽性としてフィルタリングされます。

UCSE で説明されている手法に対して、私たちは2つの変更を加えました。

- グローバルメモリの過小制約。元のUC-KLEE実装では、グローバルメモリへのアクセスを過小制約として扱っていません。しかし、このようなメモリはプログラムのコンテキストの一部であり、UCSEでは予測が不可能です。なぜなら、ある関数を解析するとき、グローバルデータがすでに上書きされている可能性があるからです。そのため、すべてのグローバルデータを過小制約としてマークし、誤検知率を下げることができます。
- パス制限装置。元々のUC-KLEEの実装には、パスの爆発を防ぐためのいくつかの組み込み制限がありました。たとえば、制約の少ないポインタのデリファレンスの深さを制限することで、制約のないリンクリストの探索が終わらない事態を避けていました。私たちは、追加の制限装置を導入しました：ある関数がパス爆発の原因となっていると判断した場合、その関数の解析を中断します。これは、ハードコードされた制限（実験では経験的に決定した64パスという値を使用）に到達したときに検出します。一つの関数がこの数のパスに分岐すると、その関数を即座にリターンするよう置き換え、関数の呼び出し元から解析を巻き戻します。これにより、パス爆発を避けて解析の実行可能性を保つことができますが、さらに解析の精度は低下します。
- 偽陽性のフィルタリング。UCangrの実装にいくつかの追加の偽陽性フィルタを導入しました。具体的には、悪用可能な状態を検出した際、その状態が制約の不足によって誤って悪用可能と判断されないようにしています。まず、追加の制約E（その状態が悪用可能で「ない」ことを表す制約）を加えて制約解決を行います。例えば、セキュリティ違反がリターンアドレスの上書きである場合、そのリターンアドレスが上書きされ「ない」ように状態を制約します。次に、この悪用不可能な状態から、それぞれの制約が甘い値を可能な解に制約します。これらの制約をUと呼びます。最後に、制約Eを削除し、制約Uを維持したまま、確認します。

それでもまだその状態が悪用可能である場合、これはその関数自体に何らかの本質的な欠陥がある可能性を示しています。そしてこの欠陥は、必ずしも文脈からの*データ*が欠落していることに起因するとは限りません。なお、この欠陥は、*制約*が不足しているために生じた誤検出である場合や、制約が十分でないデータに対する文脈情報の限界によって生じている可能性もあります。

UC-angrは、制約の少ないデータアクセスを追跡し、必要なリロケーションを実行するSimStateプラグインとして実装されています。このプラグインが初期化されると、動的シンボリック実行と同じPathGroupのパラダイムを使って、制約の少ないシンボリック実行を行うことができます。

# XI. IMPLEMENTATION: SYMBOLIC-ASSISTED FUZZING

ここでは、私たちのシンボリック支援型ファジング実装の概要を述べますが、全体的な手法であるDrillerの詳細については、別の論文 [54] で説明されています。

私たちのシンボリック支援型ファジングの実装は、AFLファザーを基盤とし、angrをシンボリックトレーサーとして使用しています。AFLのパフォーマンスを監視することで、AFLが生成した入力をシンボリックトレースし始めるタイミングを判断できます。この判断を行うために、ファザーが新しい状態遷移を発見する速度に注目します。AFLが入力の変異を一巡行った後に新しい状態遷移が発見されなかったと報告した場合、ファザーが進展に苦労していると見なし、AFLが*ユニーク*と判断したすべてのパス（すなわち、他のパスが持たないジャンプ―ソースアドレスとデスティネーションアドレスのタプルで識別される―を含むパス）にangrを適用し、AFLが入力を見つけられなかった遷移を探します。

Drillerのシンボリックコンポーネントはangrのシンボリック実行エンジンを利用して実装されており、AFLが提供する具体的な入力に基づいてパスをシンボリックにトレースします。これにより、各具体的な入力が1つの（トレースされた）パスに対応し、これらの入力はAFLによって有望なものだけがトレースされるように厳選されるため、シンボリック実行に固有のパス爆発問題を回避します。各具体的な入力はPathGroup内の個々のパスに対応します。PathGroupの各ステップにおいて、すべての分岐がチェックされ、直近のジャンプ命令がAFLにとって未知のパスにつながるかどうかを確認します。このようなジャンプが見つかった場合、SMTソルバーに問い合わせて、新しいジャンプに実行を導く入力を生成します。この入力はAFLにフィードバックされ、今後のファジング段階で変異されます。このフィードバックループにより、コストのかかるシンボリック実行時間と低コストなファジング時間のバランスがとれ、プログラム動作に対するファジングのセマンティックな洞察力の低さが緩和されます。

#### XII. IMPLEMENTATION: CRASH REPRODUCTION

私たちは、Replayer [43] によって提案された手法を実装し、入力値（攻撃者が送信する値）と出力値（攻撃者がアプリケーションから漏洩させる値）の間の失われた関係を復元しました。

私たちのReplayerの実装は、自作のシンボリック実行エンジンの上に構築されています。クラッシュを引き起こす入力のリプレイ問題は、初期状態sからクラッシュ状態qにプログラムを遷移させる入力仕様i<sup>s</sup>の探索問題として定義できます。私たちのアルゴリズムは、プログラムP、初期状態s<sup>a</sup>（すなわち実行ファイルのエントリポイントでの状態）、クラッシュ状態qa、およびs<sup>a</sup>からq<sup>a</sup>へインストゥルメントされた（ランダム性を排除した）環境で遷移する入力i<sup>a</sup>を受け取りますが、これらは非インストゥルメント環境では正しくリプレイできません。私たちの実装では、s<sup>a</sup>からqaへのパスを、入力iaを使ってシンボリックに実行します。この時、Pの実行中に生成されるすべての制約を記録します。記録された制約、実行パス、プログラムP、および新しい初期状態sbが与えられれば、*未制約*のシンボリック入力を使ってPをシンボリック実行し、以前記録した実行パスに従って新しいクラッシュ状態q<sup>b</sup>に到達します。この時点で、入力と出力に関する入力制約を分析し、それらの関係を導出できます。この関係データを利用して入力仕様isを生成し、クラッシュ入力のリプレイを可能にしています。

Replayerによって提案された実装には、クラッシュ再現への応用において主に2つの制限があります。第一に、セクションV-Aで議論するように、特定のクラッシュではクラッシュを適切に再現するために必要なすべてのデータが取得できない場合があります。Replayerはこれらのケースを扱うことができず、新たなクラッシュ入力を見つける必要があります。

第二に、Replayerはクラッシュ入力を処理する際に、アプリケーションが非ランダム化環境で実行した正確なパスのみを使って、入力仕様を生成します。もしバイナリの実行トレースがランダムデータの正確な値によって変化する場合、Replayerは正しい入力を計算できません。例えば、ランダムなクッキーがデコーディング関数を通じて特定のパスの実行を引き起こし、パス条件を導入する場合、その正確なパスで再実行すると、クッキーの値が当初のものと異なる場合があります。このような場合、再実行されたクッキーは正しくならず、再現の試みは失敗します。後ほど述べるように、AEGも同様の制限に直面しています。これは、この分野の研究が両方の課題に対して進展する可能性を示唆しています。

#### XIII. IMPLEMENTATION: EXPLOIT GENERATION

AXGEN [51]、AEG [4]、Mayhem [16] で説明されているものと類似したアルゴリズムを実装することによって、最新の自動エクスプロイト生成技術の有効性を評価することができました。私たちの実装により、脆弱性に対するエクスプロイトを作成することが可能となり、攻撃者は保存された命令ポインタを書き換えることでプログラムの実行を制御できるようになります（たとえば、関数ポインタの書き換えや、スタック上のバッファオーバーフローの悪用など）。

脆弱な状態。AEG/Mayhemとは異なり、AXGENと似て、私たちはangrを使ってプログラムのクラッシュ入力に対してコンコリック実行を行い、エクスプロイトを生成します。コンコリック実行を進める際には、クラッシュした入力を実際にプログラムに適用して得られた動的トレースと同じ経路をたどるように強制します。コンコリック実行は、プログラムがクラッシュした時点で停止し、その時のシンボリック状態を調査してクラッシュの原因を特定し、エクスプロイト可能性を測定します。特定のレジスタにおけるシンボリックビットの数を数えることで、フレームポインタの上書き、インストラクションポインタの上書き、任意書き込みなど、クラッシュをいくつかのカテゴリーに分類することができます。

命令ポインタの上書き手法。最も単純で悪用可能なバグは、クラッシュ時に命令ポインタ内にシンボリックなビットが現れる場合です。命令ポインタにシンボリックなビットが含まれていることを検出した場合、命令ポインタを制御可能な命令列（たとえばシェルコード）や、スタックをシンボリックなバッファにピボットするROPガジェットに向けるよう制約を加えることができます。こうすることで、そこに生成したROPチェイン（エクスプロイトのハードニング段階で作成したもの）を実行できます。angr自体は、AEGやAXGENで解説されている多くの実装上の詳細、例えばテイントトラッキングやパス条件の構築などを扱ってくれるため、私たちはシンボリックメモリバッファを発見し、レジスタの値に制約を加えてエクスプロイトを生成することだけに専念できるのです。これはこれらのアプローチで提案されている通りです。

CGCバイナリの悪用。Cyber Grand Challengeは、ゲームをカスタムOS上で実行しており、そのOSには7つのシステムコールしか含まれていません。プログラムの実行やファイルのオープンができるシステムコールがないため、Cyber Grand Challenge内でのエクスプロイトは、レジスタの制御やメモリの読み書き能力を示すことに限定されます。DARPAの基準によると、CGCには2種類のエクスプロイトが存在します。

- タイプ1のエクスプロイトは、攻撃者が汎用レジスタと命令ポインタレジスタを制御していることを示しています。
- Type 2エクスプロイトは、攻撃者がプロセスメモリ空間から制御された読み出しを実行できることを示しています。

126個のバイナリにAEGを適用した中で、実際にエクスプロイトに成功したのは4つのバイナリだけでした。そのうち2つのバイナリに対してのみ、「Type 2」エクスプロイトの生成に成功しました。これらの「Type 2」エクスプロイトはいずれもROPによるハードニングができず、シェルコードへのジャンプに頼らざるを得ませんでした。さらに、AEGが生成できたハード化されたROPの「Type 1」エクスプロイトは2つだけでした。これらの結果から、自動エクスプロイト生成の分野にはまだ多くの課題が残されており、現行の手法が最新の脆弱性にはあまり適用できないことが示されていると考えます。

Challenges Faced. ここでは、CROMU00019 [24] を用いて、私たちのツールが Cyber Grand Challenge のバイナリを攻略しようとした際に直面した課題のいくつかを示します。特に、このチャレンジの README で言及されている2番目の脆弱性（具体的には、攻撃者が提供した文字列のデコード中に発生するスタック上のバッファオーバーフロー）の悪用に焦点を当てます。

エクスプロイト生成中に直面した主な問題は、オーバーフローするデータの各バイトが1つの特定の値に制約されるようなパス述語が存在することでした。これは、これらのバイトの値がシンボリック入力に基づいて選ばれているにもかかわらず発生します。CROMU00019は、そのdecode関数においてこの状況を示しています。ペイロードの各バイトは、decode内に含まれるswitch文の分岐をたどり、脆弱な状態を表す我々のパスに厳しい述語を課します。このswitch文の各分岐はシンボリックデータに基づいて選ばれますが、返されるデータは具体的な値となり、それぞれの分岐はプログラム内の別々のパスを表します。従来のAEG手法は、シンボリックデータに適切な制約を課して制御フローの乗っ取りを実現できることを前提としていますが、この動作はdecode関数内で望むバイトを出力バッファに配置できる*唯一*のパスを見つける必要があります。

この問題の解決策は、脆弱な条件が存在する複数の経路の中から、望ましい制御フローのハイジャックを実行する単一の経路を探索することです。しかし、現在の自動エクスプロイト生成技術にはこの能力がなく、このようなケースが原因で、CGC Qualifierイベントで提示された多くのスタックバッファオーバーフロー脆弱性が、最新の自動エクスプロイト生成の技術では悪用されないままになっています。

#### XIV. IMPLEMENTATION: EXPLOIT HARDENING

現代の緩和技術に対するエクスプロイトを強化するために、私たちは Q [48] のアイデアに基づいた ROP チェーンコンパイラを実装しました。これにより、メモリへのデータ書き込みやライブラリ内の任意の関数呼び出しなど、最終的な目的を達成するための ROP ペイロードを自動的に生成することができます。このセクションでは、Q 自体との違いや、私たちが加えた改良点に焦点を当てます。

私たちのアプローチは、以下のステップで構成されています。

- ガジェットの発見。アプリケーション内のすべての実行可能コードを、バイトオフセットごとにスキャンし、ROPガジェットを特定し、その効果に応じて分類します。例えば、mov [ebx], eax; pop ebx; ret という命令列は、メモリ書き込みおよびレジスタのロードとして分類されます。分類を行うために、私たちの解析は angr の Path オブジェクトが提供するアクション履歴や、Claripy によるシンボリックな関係性を活用しています。
- ガジェットの配置。ROPチェーン・コンパイラは次に、ガジェットの*配置*を決定します。これによって*高レベル*な動作を実現します。例えば、データをスタックにプッシュするガジェットとデータをポップするガジェットを組み合わせることで、あるレジスタから別のレジスタへデータを移動させる配置が作れます。
- ペイロード生成。ROPコンパイラが必要なガジェットの配置を特定した後、これらのガジェットを*チェーン*として結合し、高レベルな動作（攻撃者が指定した引数でシステムコールを実行するなど）を実現します。これは、angrのプログラム状態にガジェットの配置を書き込んで、出力を指定された引数に制約し、SMTソルバにそれらの入力の解を問い合わせることで行われます。

私たちの実装は、Qとはいくつかの細かい点で異なります。まず、Qはスタックを作業用の一時記憶領域として利用していませんでした。その理由は明確ではありません。一つの説明としては、彼らの解析プラットフォームがスタック操作のモデリングに対応していなかった可能性、もう一つとしては、スタックが必ずしもスタックポインタによって指されているとは限らない（つまり、未知の場所にある）と仮定することで、手法がより一般的なものになるためかもしれません。私たちの統合システムでは、スタックポインタが実際にスタックを指しているかどうかを判別することができました。これは、私たちがAEGを実装して生成したエクスプロイトから得たメタデータを利用できたためです。

もう一つの改良点は、ガジェットの分類に関するものです。Qは特定のガジェットクラスを特定するために*値サンプリング*手法を用いましたが、サンプルのカバレッジが限られていたため、いくつかのガジェットチェーンを見逃してしまいました。

| Technique                  | Based On                 | Described In |
|----------------------------|--------------------------|--------------|
| Dynamic Symbolic Execution | 様々 [12], [16], [20]    | IV-A2, IX    |
| Veritesting                | Veritesting [5]          | IV-A2, IX    |
| Under-constrained DSE      | UCSE [46]                | IV-A2, X     |
| Symbolic-Assisted Fuzzing  | Driller [54]             | IV-A1, XI    |
| Static Analyses            | VSA [6]                  | III-C, VIII  |
| Crash Replay               | Replayer [43]            | V-A, XII     |
| Exploit Generation         | AEG [4]                  | V-B, XIII    |
| Exploit Hardening          | Q [48]                   | V-C, XIV     |

TABLE I

本論文で実施・評価した分析、それらの分析が基づいている文献、および本論文内でそれらについて議論しているセクション。

データです。私たちの手法では、すべてのガジェットをシンボリックに解析し、解析速度を維持するために工夫されたキャッシング技術を使用しています。

#### XV. COMPARATIVE EVALUATION

angrの設計を活用することで、これまで議論してきたバイナリ解析手法を同じコードベース上で再現することができ、その有効性を比較評価することが可能になりました。私たちの知る限り、これはこれまで行われていません。以前の比較研究では異なる実装で行われていたため、実装の違いによって結果に差異が生じる可能性が残されていました。ファザー自体（AFL）を除き、私たちの解析はすべて同じ解析エンジン上で実装されており、お互いに90%以上のコードベースを共有しています。

私たちは評価を行うために、DARPAがCGC Qualification Eventのために公開したCGCバイナリのコーパスを使用します。Section II-Bで述べたように、これらのバイナリは複雑さが大きく異なりますが、解析システムの実装コストを削減するためにDARPAが設計した単純な環境モデルを利用しています。

私たちは、CFGリカバリ、動的および静的な脆弱性発見、クラッシュリプレイ、エクスプロイト、エクスプロイト・ハードニングのために実装した技術を評価します。私たちが実装し評価した分析の概要、およびそれらが基づいている文献と本論文の中で記述されているセクションは、Table I にまとめられています。

#### *A. CFG recovery*

angrではCFGが他の解析の前提条件として使用されるため、angrのCFGリカバリの精度を理解することは重要です。Section VIIで詳しく説明したように、angrには2つのCFGリカバリアルゴリズムがあります。CFGAccurateは*強制実行*という基本的な手法に依拠しており、間接ジャンプ解決のために*逆方向スライシング*と*シンボリック逆探索*という2つの方法を提供しています。一方、CFGFastは主に再帰的逆アセンブルとヒューリスティックを用いて、関数や関数間の制御フローを素早く特定します。

これらのリカバリ手法の有効性を理解するために、私たちはCFGFastおよびCFGAccurateと、最先端の商用ツールであるIDA Pro 6.9のCFGリカバリをCGCバイナリ上で比較しました。IDA ProがどのようにCFGを復元するかについての詳細な情報はほとんど公開されていませんが、先行研究[59]の記述や私たち自身の観察に基づき、IDA Proはバイナリを再帰的に逆アセンブルし、シンボルや他のヒューリスティクスを用いて場所を特定していると考えられます。

| CGC Qualifying Position  | Binaries Crashed |
|--------------------------|------------------|
| First                    | 77               |
| Second                   | 12               |
| Third                    | 57               |
| Fourth                   | 9                |
| Fifth                    | 23               |
| Sixth                    | 57               |
| Seventh                  | 44               |
| Eighth (did not qualify) | 39               |
| Ninth (did not qualify)  | 65               |

TABLE III

CGC予選イベントにおける上位9競技者のクラッシュしたバイナリ数。

バイナリ全体の関数を特定した後、さらに軽量なデータフロー解析を用いて、間接ジャンプのターゲットを解決します。これは概念的にはCFGAccurateよりもCFGFastに近いものです。正確なCFGの情報が存在しないため、IDAのCFG復元結果と自分たちのCFG復元結果とを比較し、復元された基本ブロック数や制御フローの転送数の相対的な数で評価を行います。

まず最初に、CFGFastが識別したブロックやエッジと、IDA Proが生成したグラフを比較することで、私たちのCFGの完全性を評価します。Table IIにその結果を示します。CFGFastはIDA Proよりもわずかに高いコードカバレッジを持ち、より多くのエッジを復元しています。これは、CFGFastで使用している軽量なデータフロー解析やヒューリスティックが、IDAで用いられているものよりも高度であるためだと考えています。いくつかのバイナリで復元結果を手動で解析してみたところ、CFGFastはコード復元に関してより積極的であることが分かりました。IDA Proはコードの特定部分が到達不可能だと判断し、コードとして逆アセンブルするのを拒否するのに対し、CFGFastはそのような場所もコードとして識別します。これについて考えられる説明のひとつは、私たちのアプローチが*過度に*積極的であり、その結果としてそのような場所を誤って識別してしまう可能性があることです。しかし、CGCバイナリを解析する際にはそのような事例は特定されていません。

バイナリ解析の中には、エントリーポイントからの*到達可能性情報*が必要となる場合があるため、IDA Proによって生成されたCFGの*到達可能*な部分（すなわち、エントリーポイントからパスがたどれるブロックから構成されるCFG）と、angrのCFGAccurate解析によって復元されたCFGとの比較も行いました。Table IIに結果を示します。angrは、強制実行手法に後方スライシングを組み合わせることで、CFGの再構築能力を大幅に向上させています。しかし、CFGAccurateは*アドホックな*ヒューリスティックに頼っていないため、生成されるCFGのコードカバレッジはIDA Proほど高くはありません。より高いカバレッジを得るためには、ユーザーがCFGFastで復元されたすべての関数をCFGAccurateの開始点として与えることが可能です。

# *B. Evaluation of Vulnerability Analysis Techniques*

第VIII章から第XI章では、いくつかの脆弱性発見手法の実装について説明します。ここでは、これらの手法をCGCデータセットに適用した比較評価の結果を示します。これらの評価は、評価データセットを取得したDARPAコンペティションの期間である24時間のタイムアウトを設定して実行しました。

これらの結果の要約を表IVに示します。さらに、数値のより良い文脈を提供するために

| Approach                       | Functions |       | Function Edges |        | Blocks |         | Block Edges |         | Bytes  |           | Time (s) |       |
|--------------------------------|-----------|-------|----------------|--------|--------|---------|-------------|---------|--------|-----------|----------|-------|
|                                | M         | A     | M              | A      | M      | A       | M           | A       | M      | A         | M        | A     |
| IDA Pro 6.9                    | 48        | 52.96 | 76.5           | 99.62  | 829    | 3589.93 | 1188        | 6487.68 | 14037  | 104779.66 | 1.14     | 1.80  |
| angr - CFGFast                 | 61        | 70.08 | 88             | 118.74 | 843    | 3609.45 | 1193        | 6538.52 | 14296  | 105007.49 | 0.87     | 5.01  |
| IDA Pro 6.9 - reachability     | 37        | 40.96 | 74             | 90.76  | 496    | 1043.81 | 759         | 1693.01 | 7874   | 21721.85  | 1.14     | 1.80  |
| angr - forced execution        | 31        | 33.24 | 48             | 55.22  | 349.5  | 413.85  | 612         | 751.96  | 6125   | 13963.5   | 23.50    | 36.96 |
| angr - symbolic back traversal | 32        | 33.76 | 50             | 56.28  | 368    | 635.41  | 645         | 1089.78 | 6323   | 10883.51  | 27.22    | 34.10 |
| angr - backward slicing        | 30        | 32.80 | 47.5           | 53.89  | 344.5  | 653.56  | 594         | 1178.98 | 6109.5 | 14641.85  | 24.78    | 79.46 |

TABLE II

CFGFastとCFGAccurateが復元したCFGと、IDA Proが復元したCFGの比較評価。すべてのバイナリにおける各値の中央値（M）および平均値（A）を示す。

| Technique                                | Replayable | Semantic Insight | Scalability | Crashes | False Positives |
|------------------------------------------|------------|------------------|-------------|---------|-----------------|
| Dynamic Symbolic Execution               | Yes        | High             | Low         | 16      | 0               |
| Veritesting                              | Yes        | High             | Medium      | 11      | 0               |
| Dynamic Symbolic Execution + Veritesting | Yes        | High             | Medium      | 23      | 0               |
| Fuzzing (AFL)                            | Yes        | Low              | High        | 68      | 0               |
| Symbolic-Assisted Fuzzing                | Yes        | High             | High        | 77      | 0               |
| VSA                                      | No         | Medium           | High        | 27      | 130             |
| Under-constrained Symbolic Execution     | No         | High             | High        | 25      | 346             |

TABLE IV

すべての脆弱性発見手法における評価結果。

私たちの手法によって特定されたクラッシュ数と比較するために、Table III には実際の CGC 予選イベントで競合チームによって特定されたクラッシュ数も記載しています。チームの総合スコアはクラッシュ数だけで決まるものではなく、したがって予選イベントでの順位はクラッシュ数の多さとは相関していません。これらの競合チームのうち、1位のチーム [27] と7位のチーム [57] は、大会で用いた手法についてブログに投稿しています。両チームとも、Driller と概念的に似たシンボリック支援型ファジング手法を使用していました。私たちが実装した Driller も1位のチームと同じ数の脆弱性を発見していますが、これは偶然であり（おそらく手法の類似性によるものです）、意図したものではありません。

動的シンボリック実行については、単体の場合と、Veritestingのパス爆発緩和手法を併用した場合の両方で評価することにしました。これらの手法の実装の詳細については、セクションIXで説明します。

予想通り、動的シンボリック実行はパス爆発問題によく悩まされました。全体として、標準的なアプローチでは16個のCGCバイナリに脆弱性が見つかりました。パス爆発問題を部分的に緩和することを目的としたVeritestingでは、脆弱性が見つかったのは11個だけでした。これらを合わせると、脆弱性が特定されたアプリケーションは合計23個となります。

私たちは最初、より良い結果が得られたにもかかわらず、Veritestingアプローチがダイナミックシンボリック実行単独よりも脆弱性を少なく発見したことに驚きました。これら四つのバイナリについて調査する中で、Veritestingに内在する興味深いトレードオフを特定しました。Veritestingは効率的なパス統合を利用してパス爆発に対処しており、これによってパス爆発がさらなる進行を不可能にする前により深いパスの探索を可能にしています。しかし、このようなパス統合は複雑な式を導入します（例：レジスタeaxの値が統合される二つのパスで異なる場合、統合後の値は両方の以前の値を符号化する複雑な式になります）し、制約ソルバーへの負荷を増大させます。そのため、多くの統合が行われるほど、制約ソルバーの解決時間は長くなる傾向があります。制約解決自体がNP困難な問題であるため、この複雑性の増加によって、妥当な時間内に脆弱性へ到達できなくなります。その結果、Veritestingは、ダイナミックシンボリック実行がパス爆発を起こしてしまう浅いバグを特定できる一方で、より長いパスで制約ソルバーが圧倒されてしまうのです。

記号的手法を支援するファジング。支援型ファジングは、文献において非常に効果的であることが証明されています。セクションXIでは、Driller [54]と名付けられた記号的手法支援型ファジング手法の実装について議論します。

このシンボリック支援ファザーは、ファジングコンポーネントとしてAFLを使用します。AFLが生成する各入力は、動的シンボリック実行エンジンでトレースされ、入力を慎重に変異させることで到達可能なコード領域が特定されます。この慎重な変異は、シンボリック制約ソルバーによって実行され、その入力はさらなる実行と変異のために再びAFLに戻されます。DSEエンジンでトレースされる個々の入力は分岐しない（すべての入力が具体的であるため）、トレース中にパス爆発は発生しません。また、AFLはコードカバレッジを増やさないすべての入力を除外することで、DSEエンジンに渡す入力数を制限します。

AFL単体でも、CGCサービスのかなりの数の脆弱性を特定できることは言及しておくべきです。実際、私たちのsymbolic-assisted fuzzerが検出した77件の脆弱性のうち、68件はAFL単体で検出されました。残りの9件はsymbolic assistanceを用いることで発見されました。

DSEとファジング。さまざまな動的記号実行アプローチの結果の違いは驚くべきものです。DSEが、記号的に補助された手法とほぼ同じくらいの数の脆弱性を特定できると合理的に予想するかもしれませんが、

![](_page_17_Figure_0.jpeg)

図1. ファジングと動的シンボリック実行によって発見されたクラッシュ経路の長さ

ファジング、そして単なるファジング以上のものです。実際には、ファジングはほぼ*3倍*もの脆弱性を特定しました。ある意味で、これは最近のセキュリティ業界の傾向を反映しています。シンボリック解析エンジンは実用的でないと批判される一方で、ファザーはますます注目を集めています。しかしながら、この状況はここ数年の研究の方向性とは矛盾しているようです。研究分野ではシンボリック実行が重視されているように見えるからです。

これらの手法によって発見されたクラッシュを引き起こす入力を分析したところ、興味深い結果が明らかになりました。すなわち、動的シンボリック実行エンジンによって発見されたエクスプロイトは、*短い*パスを表す傾向があるということです。この結果はFigure 1に示されています。また、動的シンボリック実行（Veritestingを用いた場合でさえ）で脆弱性の発見に*失敗*したいくつかのアプリケーションをいくつか確認したところ、これはパスの長さに比例して解析の複雑さが指数的に増加するためであると結論づけました。

具体的には、パスAが与えられた場合、次の条件分岐の終わりでAが分岐する確率がp<sup>a</sup>あり、A<sup>1</sup>は分岐先のパスを、A<sup>2</sup>は分岐しないパスをたどることになります。次の条件分岐でも、A<sup>1</sup>とA<sup>2</sup>がさらに分岐する可能性があります。このようにして、分析すべき結果的なパスの数は指数関数的に増加し、分析によって実行された基本ブロック数が多くなるほど、非合理的なほど多くのパスを分析しなければならない確率も指数関数的に増加します。その結果、一般的な動的シンボリック実行アプローチは、多くの基本ブロックの実行を必要としない*浅い*クラッシュを発見するのに最適です。一方、*深い*クラッシュは、このパス爆発によって発見が困難になりやすいのです。

さらに、手法間の相対的な効果を理解するために、生成されたテストケースの*コードカバレッジ*を計算しました。シンボリック実行（Veritesting を含む）は、バイナリごとに平均 330 ブロック（中央値 260）をカバーしました。一方、ファズィングは 689 ブロック（中央値 402）、シンボリック支援ファズィングは 698 ブロック（中央値 406）をカバーしました。これらの結果から、もう一つ興味深い結論が導かれます。つまり、ファズィングやシンボリック支援ファズィングによって生成されたパスを*グラフ*として統合すれば、CFGAccurate で復元されるものよりも多くのコードカバレッジを持つ制御フローグラフ（CFG）が構成できることになります（さらに、グラフ内の各エッジは定義上到達可能であるため、完全性は完璧です）。このことは、より正確なCFG復元アルゴリズムのさらなる改良の必要性を示唆しています。

アンダー制約付きシンボリック実行。私たちは、angrを拡張してアンダー制約付きのシンボリック実行をサポートし、このような手法が私たちのデータセットに対してどれほど有効かをよりよく理解できるようにしました。これらの詳細については、Section Xで説明しています。

UC-angrは、CGCバイナリにおいて371件の脆弱性を報告しました。

しかし、この手法は関数を文脈抜きで解析するため、静的解析と同様の問題を抱えています。つまり、結果に多数の誤検知（false positive）が含まれ、さらに結果を再現することができません（つまり、クラッシュを引き起こす入力は生成されず、脆弱性の位置のみが指摘される、ということです）。実際、UC-angrの結果に346件の誤検知を確認し、25件の真陽性が残りました。これにより誤検知率は93%となり、UC-KLEE [46] で報告されている数値と同等です。

静的バッファオーバーラップ検出。ファジングやシンボリック実行、その他の静的解析によって特定されたさまざまな種類の脆弱性を比較できるようにするため、VSAベースのメモリ破損検出解析を実装しました。詳細についてはセクションVIIIで説明します。

UC-angrの場合と同様に、私たちのVSAの結果も再現性がなく、誤検出（偽陽性）の問題があります。全体として、VSAはCGCバイナリから実際に27件の脆弱性を特定できましたが、130件の誤検出も発生し、偽陽性率は82.8%となりました。

Non-replayable と replayable な解析の比較。もう一つ驚くべき結果は、non-replayable な手法（VSA および制約の緩いシンボリック実行）のパフォーマンスが比較的低かったことです。これらの手法はリプレイ可能性の制約がないため、より広範囲にわたる解析が可能ですが、文脈情報が不足しているため、このデータセットにおいて膨大な数の誤検出が生じてしまうことが分かりました。誤検出率を適切な水準に保つため、私たちは積極的な誤検出フィルタリング（Section X で議論した通り）を導入しなければならず、その結果、多くの真陽性も除外されてしまうこととなりました。

実際のバイナリに対する静的解析技術の向上は、さらなる研究が必要とされている分野のように思われます。私たちはこれを今後の研究の方向性として検討しています。

# *C. Exploitation Evaluation.*

上記の手法でクラッシュが特定された後、その深刻度を理解するために、私たちは再現および悪用を試みます。

クラッシュのリプレイ。セクションV-Aで議論したように、脆弱性発見分析によって特定されたクラッシュ入力は、環境データ（例えばランダムシード）が分析によって *非ランダム化* されているため、単純にはリプレイできない場合があります。私たちは、各CGCバイナリに対してクラッシュを分析し、脆弱性識別技術で脆弱性を特定できなかったバイナリについては、DARPAが提供したリファレンスのクラッシュ入力を使用しました。これらのクラッシュ入力のうち、6つは簡単にはリプレイできないものでした。つまり、脆弱性識別エンジンから提供されたクラッシュ入力を単にリプレイするだけではなく、それらのバイナリに含まれるチャレンジレスポンスの要素を復元するために、バイナリとのやり取りを再分析する必要がありました。

興味深いことに、DARPAはCGC Qualifying EventのCGCバイナリの作成者に対し、ランダムデータによって制御フローが影響を受けることを禁止しています。これは、Section XIIで論じたReplayerの制限、すなわちランダムデータの値が異なることによって異なる経路述語が導入される問題が、CGCバイナリの操作には当てはまらないことを意味します。angrが1つのアプリケーションでハングしたものの、手動による解析の結果、これはアプローチそのものの問題ではなく実装上の問題であることが判明し、予想どおりReplayerは残りの5つの入力仕様を復元することができました。

6つのバイナリは大規模なデータセットとは言えませんが、この結果は、現時点のこの分野の手法が、ランダムなデータによって引き起こされる制御フローの変化がない場合には、バイナリを適切に扱えることを示唆しています。今後は、より複雑な制御フローを持つ実際のバイナリに対して、これらの手法を評価し、必要に応じて拡張するためのさらなる研究が必要です。

自動エクスプロイト生成。クラッシュを特定し、それをReplayerで実行した後、ターゲットアプリケーションを確実にクラッシュさせる入力仕様が得られます。しかし、そのような入力が*悪用可能*とは限りません。例えば、CGCデータセット内に多数存在するヌルポインタ参照によるクラッシュは、現代のシステムでは悪用できません。悪用可能な入力とそうでない入力を区別するために、クラッシュからエクスプロイトの生成を試みます。

私たちは、AEGシステム [4] で提案された手法を用いて、すべてのCGCアプリケーションに対して自動的にエクスプロイトの生成を試みました。しかし、これらの手法を用いて武器化できたクラッシュ・エクスプロイトはわずか*4*件しかありませんでした。バイナリをさらに詳しく調査したところ、その理由が分かりました。まず、CGC予選イベントの目的は、バイナリに対して*クラッシュ*を見つけることであり、エクスプロイトを見つけることではありませんでした。そのため、これらのバイナリに存在する多くの脆弱性は、実際にはエクスプロイト可能ではありません（例：ヌルポインタ逆参照）。また、CGCバイナリは現実的なさまざまなエクスプロイトシナリオをモデル化しているため、AEGで提案された手法が大半のケースに適用できないことが分かりました。

この分野の現状はかなり基本的なものであり、そのことがこれらの結果にも表れています。複雑な脆弱性を自動的に悪用するためには、この分野におけるさらなる研究が必要です。

エクスプロイトの耐性強化。たとえ悪用可能な脆弱性があった場合でも、現代的な保護機能によって緩和される可能性があります。その結果、*エクスプロイトの耐性強化*が必要とされ、近年の研究でも調査されています。私たちはQ [48]によって提案された手法を再実装し、AEGによって生成されたエクスプロイトの耐性強化を試みました。

Qの実装は、AEGが生成した4つのエクスプロイトのうち2つの防御を強化することができました。残りの2つのエクスプロイトが防御を強化できなかった理由について分析したところ、Qの手法はバイナリ内の十分な情報を活用していないことがわかりました。これら2つの例では、スタック上に攻撃者が制御できるデータが十分に存在せず、プログラムの他の部分で攻撃者制御データを使用するには*スタックピボット*が必要です。Qの手法ではこのような操作を考慮する根拠がないため、これらのエクスプロイトは防御を強化できません。

#### XVI. CONCLUSIONS

本論文では、angrを紹介しました。angrは、バイナリ内の脆弱性の自動的な特定および悪用のためのさまざまな手法を、統一されたフレームワークで実装するシステムです。私たちは、それぞれの解析手法と、それらをフレームワークに組み込む際に直面した課題について、体系的に説明しました。これらのアプローチを単一のシステムに実装することで、これらの手法を評価するために作成されたデータセット上で、それぞれの有効性を意味のある形で比較することができました。この評価結果は、今後の研究の方向性を明確にしたり、既存の手法を改善したりするための基礎として利用できます。

私たちはangrをオープンソース化しました。これにより、コミュニティがその上に新たなものを構築し、バイナリ解析分野における未解決の課題に取り組むことができるようになります。

謝辞。本研究は、契約番号N66001-13-2-4039のもとDARPAによって、また契約番号N00014-15-1-2948のもとONRによって支援されています。米国政府は、ここに記載されている著作権表示にかかわらず、政府の目的のためにリプリントを複製および配布する権利を有します。

#### REFERENCES

- [1] American Fuzzy Lop. http://lcamtuf.coredump.cx/afl/.
- [2] OWASP Top 10 Project. http://http://www.owasp.org.
- [3] XcodeGhost マルウェア。http://www.apple.com/cn/xcodeghost/ #english.
- [4] T. Avgerinos, S. K. Cha, B. L. Tze Hao, and D. Brumley. AEG: Automatic Exploit Generation. In *Proceedings of the 18th Annual Network and Distributed System Security Symposium (NDSS'11)*, 2011.
- [5] T. Avgerinos, A. Rebert, S. K. Cha, and D. Brumley. Veritestingによるシンボリック実行の強化。ページ 1083–1094, 2014年。
- [6] G. Balakrishnan, T. Reps, D. Melski, and T. Teitelbaum. WYSINWYX: What You See Is Not What You eXecute. *Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)*, 4171 LNCS:202–213, 2008.
- [7] T. Bao, J. Burket, M. Woo, R. Turner, and D. Brumley. BYTEWEIGHT: Learning to Recognize Functions in Binary Code. In *Proceedings of the 23rd USENIX Security Symposium*, pages 845–860, 2014.
- [8] C. Barrett、L. De Moura、A. Stump。SMT-COMP: 理論付き充足可能性競技会。*Computer Aided Verification* において、20–23ページ。Springer、2005年。
- [9] S. Bekrar, C. Bekrar, R. Groz, and L. Mounier. スマートファジングのためのテイントベースのアプローチ。*Software Testing, Verification and Validation (ICST), 2012 IEEE Fifth International Conference on*、ページ818–825。IEEE、2012年。
- [10] Bloomberg Business. 病院の機器はあなたの命を救うこともあれば、あなたの個人情報がハッキングされる原因にもなり得ます。 http://www.bloomberg.com/features/2015-hospital-hack/.
- [11] P. Boonstoppel, C. Cadar, and D. Engler. RWset: 制約ベースのテスト生成におけるパス爆発への攻撃. *Tools and Algorithms for the Construction and Analysis of Systems*、4963巻 LNCS、351–366ページ。Springer Berlin Heidelberg、2008年。
- [12] C. Cadar, D. Dunbar, and D. Engler. KLEE: 複雑なシステムプログラムに対して、高カバレッジのテストを自動かつ無人で生成する手法です。*Proceedings of the 8th USENIX Symposium on Operating Systems Design and Implementation (OSDI'08)*, volume 8, pages 209–224, 2008.
- [13] C. Cadar, V. Ganesh, P. M. Pawlowski, D. L. Dill, and D. R. Engler. EXE: Automatically Generating Inputs of Death. In *Proceedings of the 13th ACM Conference on Computer and Communications Security*, pages 322–335, 2006.
- [14] G. Campana. Fuzzgrind: 自動ファジングツール。*Actes du 7eme symposium sur la sécurité des technologies de linformation et des communications (SSTIC)*、213–229ページ、2009年。
- [15] D. Caselden、A. Bazhanyuk、M. Payer、L. Szekeres、S. McCamant、および D. Song。「Transformation-aware Exploit Generation using a HI-CFG」。テクニカルレポート、DTIC Document、2013年。
- [16] S. K. Cha、T. Avgerinos、A. Rebert、およびD. Brumleyによる論文「Unleashing Mayhem on Binary Code」。*Proceedings of the IEEE Symposium on Security and Privacy*に収録、ページ380–394、2012年。
- [17] S. K. Cha, M. Woo, and D. Brumley. Program-Adaptive Mutational Fuzzing. In *Proceedings of IEEE Symposium on Security and Privacy*, volume 2015-July, pages 725–741, 2015.
- [18] P. Chen、X. Xing、B. Mao、L. Xie、X. Shen、X. Yinによる「x86プラットフォームにおけるジャンプ指向プログラミングシェルコードの自動生成」。*Proceedings of the 6th ACM Symposium on Information, Computer and Communications Security*に収録、ページ20–29。ACM、2011年。
- [19] V. Chipounov, V. Georgescu, C. Zamfir, および G. Candea. Selective Symbolic Execution. In *Proceedings of the 5th Workshop on Hot Topics in System Dependability*, 2009.
- [20] V. Chipounov、V. Kuznetsov、および G. Candea による S2E: ソフトウェアシステムのイン・ヴィヴォ マルチパス解析のためのプラットフォーム。*Proceedings of the sixteenth International Conference on Architectural Support for Programming Languages and Operating Systems* に収録、265–278 ページ、2011年。
- [21] C. Cifuentes and M. Van Emmerik. バイナリコードからジャンプテーブルのcase文の復元について。*Proceedings of the Seventh International Workshop on Program Comprehension*、192–199ページ。IEEE、1999年。
- [22] P. M. Comparetti、G. Wondracek、C. Kruegel、およびE. KirdaによるProspex: Protocol Specification Extraction。*Proceedings of the 2009 IEEE Symposium on Security and Privacy*の110–125ページに掲載。IEEE、2009年。
- [23] DAPRA. DARPA Cyber Grand Challenge. http: //www.cybergrandchallenge.com/.
- [24] DARPA. CyberGrandChallengeのサンプルを収めたgitリポジトリです。https://github.com/CyberGrandChallenge/samples.
- [25] L. De MouraとN. BjørnerによるZ3は、高効率なSMTソルバーです。*Proceedings of the Theory and Practice of Software, 14th International Conference on Tools and Algorithms for the Construction and Analysis of Systems*、TACAS'08/ETAPS'08において、ページ337–340、2008年にベルリンおよびハイデルベルクで発表されました。Springer-Verlagより出版されています。
- [26] D. Engler と D. Dunbar. Under-constrained Execution: 自動コード破壊を簡単かつスケーラブルにするために. 『2007年国際ソフトウェアテストおよび分析シンポジウム論文集』, pp. 1–4, 2007年.
- [27] ForAllSecure. Mayhem CRSの解放。http: //blog.forallsecure.com/2016/02/09/unleashing-mayhem/.
- [28] P. Godefroid、N. Klarlund、K. SenによるDART: Directed Automated Random Testing。『Proceedings of the 2005 ACM SIGPLAN Conference on Programming Language Design and Implementation』、第40巻、213–223ページ、2005年。
- [29] P. Godefroid, M. Y. Levin, and D. Molnar. SAGE: Whitebox Fuzzing for Security Testing. *ACM Queue*, 10(1):20, 2012.
- [30] I. Haller、A. Slowinska、M. Neugschwandtner、H. Bos。Dowser: バッファオーバーフローの脆弱性を発見するためのガイド付きファジング手法。*Proceedings of the 22nd USENIX Security Symposium*、49–64ページ、2013年。
- [31] S.-K. Huang, M.-H. Huang, P.-Y. Huang, C.-W. Lai, H.-L. Lu, and W.-M. Leong. CRAX: Software Crash Analysis for Automatic Exploit Generation by Modeling Attacks as Symbolic Continuations. In *Software Security and Reliability (SERE), 2012 IEEE Sixth International Conference on*, pages 78–87. IEEE, 2012.
- [32] Indefinite Studies. リバースエンジニアのための停止性問題。http://indefinitestudies.org/2010/12/19/the-halting-problem-for-reverseengineers/.
- [33] J. Kinder と H. Veith による Jakstab は、バイナリのための静的解析プラットフォームです。*Proceedings of the 20th international conference on Computer Aided Verification* に収録されており、ページは 423–427、2008 年、ベルリンで発表されました。Springer-Verlag より出版されています。
- [34] C. Kruegel, W. Robertson, F. Valeur, and G. Vigna. 難読化されたバイナリの静的逆アセンブリ。*Proceedings of the 13th USENIX Security Symposium*、第13巻、18–18ページ、2004年。
- [35] V. Kuznetsov, J. Kinder, S. Bucur, and G. Candea. Symbolic Executionにおける効率的な状態マージについて述べています。*Proceedings of the 2012 ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI'12)*、193ページ、2012年。
- [36] J. Lee、T. Avgerinos、D. Brumley。TIE: バイナリプログラムにおける型の体系的なリバースエンジニアリング。*Proceedings of the 18th Network and Distributed System Security Symposium (NDSS'11)*、2011年。
- [37] Y. Li, Z. Su, L. Wang, and X. Li. Steering Symbolic Execution to Less Traveled Paths. *Proceedings of the 2013 ACM SIGPLAN international conference on Object Oriented Programming Systems Languages & Applications*, 2013年、19-32ページに掲載。
- [38] B. P. Miller、L. Fredriksen、B. So。UNIXユーティリティの信頼性に関する実証的研究。*Communications of the ACM*, 33(12):32–44, 1990年。
- [39] C. Miller. コードカバレッジによるファズィングの実例. https: //fuzzinginfo.files.wordpress.com/2012/05/cmiller toorcon2007.pdf.
- [40] M. Muller-Olm と H. Seidl による「線形代数による正確な手続き間解析」。*Proceedings of the 31st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages*、第39巻、330–341ページ、2004年。
- [41] J. A. Navas、P. Schachte、H. Søndergaard、P. J. Stuckeyによる論文「Signedness-Agnostic Program Analysis: Precise Integer Bounds for Low-Level Code」。*Lecture Notes in Computer Science (including*

*subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)*, volume 7705 LNCS, 2012年、ページ115–130。

- [42] M. Neugschwandtner、P. Milani Comparetti、I. Haller、および H. Bos。「The BORG: Nanoprobing Binaries for Buffer Overreads」。*Proceedings of the 5th ACM Conference on Data and Application Security and Privacy*、87–97ページ。ACM、2015年。
- [43] J. Newsome、D. Brumley、J. Franklin、D. Songによる「Replayer: Automatic Protocol Replay by Binary Analysis」。*Proceedings of the ACM Conference on Computer and Communications Security*に収録、311–321ページ、2006年。
- [44] F. Perez と B. E. Granger. IPython: インタラクティブな科学計算のためのシステム。*Computing in Science and Engineering*, 9(3):21–29, 2007年5月。 http://ipython.org.
- [45] J. Pewny、B. Garmany、R. Gawlik、C. Rossow、およびT. Holz。バイナリ実行ファイルにおけるクロスアーキテクチャのバグ検索。*Proceedings of the 2015 IEEE Symposium on Security and Privacy*、2015年7月号、709–724ページ、2015年。
- [46] D. a. Ramos および D. Engler. 未制約記号実行: 実際のコードの正当性検証について述べています。*Proceedings of the 24th USENIX Security Symposium*、ページ 49–64、2015年。
- [47] P. Saxena, P. Poosankam, S. McCamant, and D. Song. バイナリプログラムに対するループ拡張型シンボリック実行。*Proceedings of the 18th International Symposium on Software Testing and Analysis*、225ページ、2009年。
- [48] E. Schwartz、T. Avgerinos、D. Brumley。Q: Exploit hardeningを簡単に実現。*第20回USENIX Security Symposium*の論文集、第8巻、25ページ、2011年。
- [49] E. J. Schwartz, T. Avgerinos, and D. Brumley. Dynamic Taint AnalysisとForward Symbolic Execution について知りたかったことすべて（でも聞くのが怖かったかもしれないこと）に関する論文です。*Proceedings of the 2010 IEEE Symposium on Security and Privacy*（SP '10）の317–331ページに掲載されており、2010年にWashington, DC, USAで発表されました。IEEE Computer Societyによって出版されています。
- [50] B. Schwarz, S. Debray, and G. Andrews. 実行可能コードの逆アセンブルの再考。*Proceedings of Ninth working conference on Reverse engineering, 2002* に収録、ページ 45–54。IEEE、2002年。
- [51] D. K. Sean Heelan. *Automatic Generation of Control Flow Hijacking Exploits for Software Vulnerabilities*. PhD thesis, University of Oxford computing laboratory, 2009年9月.
- [52] H. Shacham. The Geometry of Innocent Flesh on the Bone: Returninto-libc without Function Calls (on the x86). In *Proceedings of the 14th ACM Conference on Computer and Communications Security*, volume 22, pages 552–561, 2007.
- [53] Y. Shoshitaishvili, R. Wang, C. Hauser, C. Kruegel, and G. Vigna. Firmalice - バイナリファームウェアにおける認証バイパス脆弱性の自動検出。*Proceedings of Network and Distributed System Security Symposium*、2月号、8–11ページ。Internet Society、2015年。
- [54] N. Stephens, J. Grosen, C. Salls, A. Dutcher, R. Wang, J. Corbetta, Y. Shoshitaishvili, C. Kruegel, および G. Vigna. Driller: 選択的なシンボリック実行によるファジングの強化について述べています。*Proceedings of the Network and Distributed System Security Symposium*, 2016 に掲載されています。
- [55] L. Szekeres, M. Payer, T. Wei, and D. Song. SoK: Eternal War in Memory. In *Proceedings of the IEEE Symposium on Security and Privacy*, pages 48–62, 2013.
- [56] K. Thompson. 信頼を信頼することについての考察。*Communications of the ACM*, 27(8):761–763, Aug. 1984.
- [57] Trail of Bits Blog. How We Fared in the Cyber Grand Challenge. http://blog.trailofbits.com/2015/07/15/how-we-fared-in-the-cybergrand-challenge/.
- [58] J. Troger と C. Cifuentes による「Analysis of Virtual Method Invocation for Binary Translation」。*Proceedings of Ninth Working Conference on Reverse Engineering, 2002*に収録、65–74ページ。IEEE、2002年。
- [59] L. Xu, F. Sun, and Z. Su. バイナリから正確な制御フローグラフを構築します。*University of California, Davis, Tech. Rep*, 2009.
- [60] F. Yamaguchi、N. Golde、D. Arp、および K. Rieck による論文です。コードプロパティグラフを用いた脆弱性のモデリングと発見について述べられています。これは *Proceedings of the 2014 IEEE Symposium on Security and Privacy* に掲載されており、ページ範囲は 590–604、発行年は 2014 年です。
- [61] F. Yamaguchi、A. Maier、H. Gascon、およびK. Rieckによる「Automatic Inference of Search Patterns for Taint-style Vulnerabilities」。*Proceedings of the 2015 IEEE Symposium on Security and Privacy*（2015年7月号）、797–812ページ、2015年。
- [62] M. Zalwski. Bunny the Fuzzer Documentation. http: //code.google.com/p/bunny-the-fuzzer/wiki/BunnyDoc.
