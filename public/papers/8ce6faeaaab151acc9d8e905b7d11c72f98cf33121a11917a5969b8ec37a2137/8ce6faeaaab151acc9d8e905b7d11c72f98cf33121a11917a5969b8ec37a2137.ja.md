# Modeling and Discovering Vulnerabilities with Code Property Graphs

Fabian Yamaguchi∗、Nico Golde†、Daniel Arp∗およびKonrad Rieck∗ ∗University of Gottingen, Germany ¨ †Qualcomm Research Germany

*Abstract*—現在直面しているセキュリティ侵害の大多数は、不安全なコードが直接的な原因である。そのため、コンピュータシステムの保護は、ソフトウェア中の脆弱性を厳格に特定することに大きく依存しており、これは多大な専門知識を必要とする退屈かつエラーの起こりやすい作業である。残念ながら、単一の欠陥だけでシステムのセキュリティは損なわれてしまうため、監査すべきコードの膨大な量が攻撃者にとって有利に働くことになる。本論文では、大量のソースコードから効果的に脆弱性を発掘する手法を提案する。この目的のために、*code property graph*と呼ばれるソースコードの新しい表現を導入する。この表現は、古典的なプログラム解析の概念、すなわち抽象構文木、制御フローグラフ、プログラム依存グラフを統合したデータ構造である。この包括的な表現により、*graph traversals*を用いた一般的な脆弱性のテンプレートをエレガントにモデル化することができる。これによって、例えばバッファオーバーフロー、整数オーバーフロー、フォーマット文字列脆弱性、メモリ情報漏洩といった問題を特定することができる。我々は本手法を有名なグラフデータベースで実装し、その有効性をLinux kernelのソースコードにおいて18件のこれまで知られていなかった脆弱性を特定することで示した。

#### *Keywords*—*Vulnerabilities; Static Analysis; Graph Databases*

#### I. INTRODUCTION

コンピュータシステムのセキュリティは、その基盤となるソフトウェアの品質に本質的に依存している。学術界および産業界における長年の研究の蓄積にもかかわらず、セキュリティ脆弱性はプログラムコード内で定期的に現れる。例えば、バッファ境界を考慮しない実装や、入力データの検証が不十分である場合などがある。その結果、ソフトウェアの脆弱性は、今日においてもセキュリティ侵害の主要な原因の一つであり続けている。例えば、2013年には、ユニバーサルプラグアンドプレイライブラリにおける一つのバッファオーバーフローにより、2,300万台以上のルーターがインターネットからの攻撃に対して脆弱となった[26]。同様に、現在でも何千人ものユーザがJavaランタイム環境の様々な欠陥を悪用するウェブベースのマルウェアの被害に遭っている[29]。

ソフトウェアの脆弱性発見は、古典的でありながらも困難なセキュリティ問題である。プログラムが他のプログラムの非自明な特性を識別できないため、ソフトウェア脆弱性発見の一般的問題は決定不能である[33]。その結果、セキュリティ上の欠陥を発見する現在の手段は、特定の種類の脆弱性に限定されるか、煩雑かつ手動による監査に依存している。特に、オペレーティングシステムカーネルのような大規模ソフトウェアプロジェクトのセキュリティ確保は困難な作業に類似しており、単一の欠陥が全コードベースの安全性を損なう可能性がある。バッファオーバーフローやフォーマット文字列脆弱性のように、ソフトウェア業界全体で長年にわたり再発している特定のクラスの脆弱性も存在するが、これらが特定のソフトウェアプロジェクトでどのように現れるかを自動的に検出することは、依然として相当な専門知識なしにはしばしば不可能である[16]。

この状況の結果として、セキュリティ研究は当初、不適切なライブラリ関数によって引き起こされる不具合[6]、バッファオーバーフロー[45]、整数オーバーフロー[40]、入力データの不十分な検証[18]など、特定の種類の脆弱性を静的に発見することに焦点を当てていた。ソフトウェアテストの概念に基づき、より広範な脆弱性の検出が、単純なファズテスト[例: 38, 42]から高度なテイントトラッキングやシンボリック実行[例: 2, 35]に至る動的プログラム解析を用いて実現されてきた。これらの手法によってさまざまな種類の不具合を発見できるものの、実際には効率的に運用するのが難しく、実行時の制約や考慮すべき実行経路の指数的増加が原因で、しばしば適切な結果を提供できないことが多い[16, 21]。この対策として、最近のセキュリティ研究では、監査中にアナリストを支援するアプローチの検討が始まっている。提案されている手法は、専門知識によって静的プログラム解析を拡張することで監査プロセスを加速させ、これにより脆弱性の探索を導くことを可能としている[例: 39, 43, 44]。

本論文では、この研究の方向性を継続し、脆弱性を発見するために大量のソースコードをマイニングする新しい手法を提案する。我々の手法は、プログラム解析の古典的な概念と、グラフマイニング分野における最近の発展を組み合わせたものである。本手法の根底にある主要な洞察は、多くの脆弱性がコードの構造、制御フロー、依存関係を同時に考慮することで初めて十分に発見できるという点にある。この要件に対応するため、*code property graph* と呼ばれるソースコードの新しい表現を導入する。このグラフは、抽象構文木、制御フローグラフ、プログラム依存グラフの性質を統合したデータ構造となっている。この包括的なコードの視点により、*graph traversals* を用いて一般的な脆弱性のテンプレートを優雅にモデル化することが可能となる。データベースのクエリに似て、グラフトラバーサルは code property graph 上を通過し、コード構造、制御フロー、各ノードに関連するデータ依存性を調査する。このように異なるコード特性へ同時にアクセスできるため、複数タイプの欠陥に対する簡潔なテンプレートを作成することができ、結果として大量のコードから脆弱性を監査することを支援する。

我々は、一般的なグラフデータベースを用いて本手法を実装し、バッファオーバーフロー、整数オーバーフロー、フォーマット文字列脆弱性、メモリ漏洩など、いくつかの著名な脆弱性タイプに対するグラフトラバーサルを設計することで、その実用性を示す。実例として、大規模かつ充分に監査されたコードベースであるLinuxカーネルのソースコードを分析する。その結果、報告されたほぼすべての脆弱性は

© 2014, Fabian Yamaguchi. IEEEへのライセンスの下で提供されている。DOI 10.1109/SP.2014.44

![](_page_0_Picture_14.jpeg)

2012年のLinuxカーネルは、そのコードプロパティグラフ内のトラバーサルを用いて記述することができる。オープンソースコミュニティによるカーネルのセキュリティ向上に対する多大な努力にもかかわらず、これらのトラバーサルによって*18件のこれまで知られていなかった脆弱性*がLinuxカーネルに発見できた。このことは、コードプロパティグラフの実際の能力を示している。

要約すると、我々は脆弱性発見の問題に対して以下の貢献を行った。

- *Code property graph.* ソースコードの新しい表現を導入する。本表現は、抽象構文木、制御フローグラフ、プログラム依存グラフの特性を組み合わせ、統合的なデータ構造として表現したものである。
- *脆弱性タイプのためのトラバーサル*。一般的な脆弱性のタイプは、コードプロパティグラフのトラバーサルとして洗練して表現でき、効率的な検出テンプレートを生み出すことができる。
- *効率的な実装* コードプロパティグラフをグラフデータベースにインポートすることによって、Linuxカーネルのような大規模なコードベースに対してもトラバーサルを効率的に実行できることを示す。

本論文の残りの構成は以下の通りである。第II章ではコード表現に関する背景情報を提供し、第III章ではプロパティグラフおよびグラフトラバーサルの概念を定義する。第IV章では我々の新しい表現手法であるコードプロパティグラフを紹介し、第V章ではそれを用いて脆弱性を特徴付ける方法を示す。第VI章では我々の手法を評価する。関連研究および限界については、第VII章と第VIII章でそれぞれ議論する。第IX章が本論文の結論となる。

#### II. REPRESENTATIONS OF CODE

プログラム解析およびコンパイラ設計の分野では、プログラムの特性を論じるために様々なコード表現が開発されてきた。これらの表現は主にコードの解析および最適化のために設計されてきたが、本稿で検討するように、コードの特徴づけにも適している。特に、本研究では*抽象構文木*、*制御フローグラフ*、および*プログラム依存グラフ*という三つの古典的表現に焦点を当てており、これらが脆弱性発見へのアプローチの基盤となる。コード表現に関する詳細な議論はAhoらによる書籍[1]に記載されている。

| void foo()        | 1 |
|-------------------|---|
| {                 | 2 |
| int x = source(); | 3 |
| if (x < MAX)      | 4 |
| {                 | 5 |
| int y = 2 * x;    | 6 |
| sink(y);          | 7 |
| }                 | 8 |
| }                 | 9 |

図1：例示的なコードサンプル（図2を参照）。

このセクション全体を通して異なる表現を示しながら説明する単純な例として、Figure 1に示されたコードサンプルを考える。

#### *A. Abstract Syntax Trees (AST)*

抽象構文木は、通常、コンパイラのコードパーサによって生成される最初の中間表現の一つであり、多くの他のコード表現生成の基礎となるものである。これらの木は、文や式がどのように入れ子になってプログラムを構成しているかを忠実に符号化している。しかし、*構文解析木*とは対照的に、抽象構文木はもはやプログラムを表現するために選択された具体的な構文を表現していない。たとえば、C言語においては、カンマ区切りの宣言リストは、2つの連続した宣言と通常同じ抽象構文木を生成するのである。

抽象構文木とは、内側のノードが*演算子*（例えば加算や代入）を表し、葉ノードが*オペランド*（例えば定数や識別子）に対応する順序付き木である。例として、Figure 1で示されているコードサンプルに対する抽象構文木をFigure 2aに示す。抽象構文木は単純なコード変換には適しており、意味的に類似したコードの特定にも用いられてきた[3, 43]が、デッドコードや未初期化変数の検出のような、より進んだコード解析には適用できない。この欠点の理由は、このコード表現では制御フローやデータ依存関係が明示的に示されていないためである。

### *B. Control Flow Graphs (CFG)*

制御フローグラフは、コード文が実行される順序および特定の実行経路が選択されるために満たすべき条件を明示的に記述するものである。この目的のために、文や述語はノードとして表現され、制御の移動を示す有向エッジによって接続される。これらのエッジは、抽象構文木の場合のように順序付けされている必要はないが、各エッジには*true*、*false*のラベルを割り当てる必要がある。特に、文ノードは1本の出力エッジを持ち、そのラベルは-となり、述語ノードは述語の評価が*true*または*false*となる2本の出力エッジを持つ。制御フローグラフは、抽象構文木から2段階の手順で構築できる。まず、構造化された制御文（例：*if*、*while*、*for*）を考慮して、予備的な制御フローグラフを構築する。次に、*goto*、*break*、*continue*といった非構造化制御文も加味して、その予備的な制御フローグラフを修正する。Figure 2bは、Figure 1で与えられたコードサンプルに対するCFGを示している。

制御フローグラフは、セキュリティ分野において様々な用途で利用されてきた。例えば、既知の悪意あるアプリケーションの亜種を検出するためや、ファズテストツールを案内するためなどである。さらに、リバースエンジニアリングにおける標準的なコード表現として、プログラムの理解を助けるためにも利用されている。しかし、制御フローグラフはアプリケーションの制御フローを明らかにする一方で、データフロー情報を提供することはできない。特に脆弱性分析の観点では、制御フローグラフだけでは攻撃者の影響を受けたデータを処理する文を特定することが容易ではないということになる。

## *C. Program Dependence Graphs (PDG)*

Ferranteら[9]によって導入されたプログラム依存グラフは、元々プログラムスライシングを実行するために開発されたものである。

![](_page_2_Figure_0.jpeg)

図2：図1の例に対するコードの表現である。制御依存関係およびデータ依存関係は、プログラム依存グラフ内でCおよびDによって示されている。

すなわち、指定された文における変数の値に影響を与えるすべての文および述語を決定することである。プログラム依存グラフは、文や述語間の依存関係を明示的に表現する。特に、このグラフは二種類のエッジを用いて構築される。1つは、ある変数が別の変数に与える影響を反映するデータ依存エッジであり、もう1つは、述語が変数の値に及ぼす影響に対応する制御依存エッジである。プログラム依存グラフのエッジは、各文および述語によって*定義*される変数の集合と*使用*される変数の集合をまず決定し、各文や述語に対する*到達定義*を計算することによって、制御フローグラフから算出できる。この手法は、コンパイラ設計における標準的な問題である[1参照]。

例として、Figure 2cはFigure 1に示したコードサンプルのプログラム依存グラフを示している。制御依存のエッジは単なる制御フローエッジではないこと、特に文が実行される順序はこのグラフからはもはや決定できないことに注意されたい。一方で、文と述語の間の依存関係は明確に可視化されている。

#### III. PROPERTY GRAPHS AND TRAVERSALS

提示された各表現は、それぞれ基盤となるプログラムの異なる側面を強調するソースコードに対する独自の視点を提供する。これらの視点を統合して脆弱性発見のための共同表現とするために、*property graph* [34]という概念を用いる。これは、多くのグラフデータベース、例えばArangoDB、Neo4J、OrientDBにおいて構造化データの基本的な表現である。形式的には、property graphは次のように定義される。

定義1. *プロパティグラフ* G = (V, E, λ, μ) とは、有向エッジラベル付き属性付き多重グラフである。ここで、V はノードの集合、E ⊆ (V × V) は有向エッジの集合、λ : E → Σ は、アルファベット Σ から各エッジへラベルを割り当てるエッジラベル付与関数である。エッジおよびノードには、μ : (V ∪ E) × K → S という関数によってプロパティを割り当てることができる。ここで、K はプロパティキーの集合、S はプロパティ値の集合である。

図3は、4つのノードを持つ単純なプロパティグラフを示している。プロパティグラフは多重グラフであり、このため2つのノードが複数のエッジで接続される場合があることに注意する必要がある。例えば、図3のノードAとBがそれに該当する。また、この例では、各ノードにキーk ∈ Kを持つプロパティが割り当てられており、ノードAおよびBのみが集合S = {x, w}からプロパティ値を保持している。

![](_page_2_Figure_8.jpeg)

Fig. 3: プロパティグラフの例である。ノードに割り当てられたプロパティは破線で示されている。

プロパティグラフにおける情報抽出の主要な手段は、いわゆる*グラフトラバーサル*、略して*トラバーサル*であり、ラベルやプロパティに応じてグラフのエッジに沿って移動するために利用できるものである。形式的には、グラフのトラバーサルは以下のように定義される。

定義2. *トラバーサル*とは、性質グラフGにおいて、ノードの集合を別のノードの集合へ写像する関数T : P(V ) → P(V )である。ただし、PはVの冪集合である。

この一般的な定義は、複数のトラバーサルを連結して使用することを可能にする。たとえば、2つのグラフトラバーサルT<sup>0</sup>およびT<sup>1</sup>は、関数合成◦を用いてT<sup>0</sup> ◦ T<sup>1</sup>として連結できる。この連結に基づき、いくつかの基本的なトラバーサルを定義することができ、これらは本論文で論じる他のすべてのトラバーサル構築の基礎となる。まず、単純なフィルタトラバーサルを定義する。

$$
\text{Filter}_p(X) = \{ v \in X : p(v) \}
$$

これは、ブール述語p(v)に一致する集合X内のすべてのノードを返すものであり、例えば、特定のプロパティをチェックすることによって実現される。

プロパティグラフのエッジに沿って移動するために、以下のフォワードトラバーサルを定義する。

$$
OUT(X) = \bigcup_{v \in X} \{u : (v, u) \in E\},\
$$

$$
OUT_l(X) = \bigcup_{v \in X} \{u : (v, u) \in E \text{ かつ } \lambda((v, u)) = l\},\
$$

$$
OUT_l^{k,s}(X) = \bigcup_{v \in X} \{u : (v, u) \in E \text{ かつ } \lambda((v, u)) = l
$$

そして $\mu((v, u), k) = s\}$ である。

これは、ノード集合Xから到達可能なノードを返すものである。詳細には、探索OUTはXから到達可能なすべてのノードを返し、OUT<sup>l</sup>はラベルlを持つエッジを通じて到達可能なすべてのノードを返し、OUTk,s <sup>l</sup>はラベルlおよびプロパティ<sup>k</sup>:sを持つエッジを通じて到達可能なすべてのノードを返す。同様に、グラフ内を逆方向に移動するための探索IN、IN<sup>l</sup>、およびINk,s lを定義する。

$$
IN(X) = \bigcup_{u \in X} \{v : (v, u) \in E\},\
$$

$$
IN_l(X) = \bigcup_{u \in X} \{v : (v, u) \in E \text{ かつ } \lambda((v, u)) = l\},\
$$

$$
IN_l^{k,s}(X) = \bigcup_{u \in X} \{v : (v, u) \in E かつ \lambda((v, u)) = l かつ \mu((v, u), k) = s\}.
$$

最後に、他のトラバーサルの出力を集約するために、ORとANDという二つのトラバーサルを次のように定義する。

$$
OR(\mathcal{T}_1, ..., \mathcal{T}_N)(X) = \mathcal{T}_1(X) \cup ... \cup \mathcal{T}_N(X)
$$
  
AND( $\mathcal{T}_1, ..., \mathcal{T}_N$ )(X) =  $\mathcal{T}_1(X) \cap ... \cap \mathcal{T}_N(X)$

やや技術的な定義ではあるが、いくつかのグラフデータベースはこれらの基本的なトラバーサルについて効率的な実装を提供している。特に、FILTER、OUT、INトラバーサルは*Gremlin*というグラフ言語の基本的な機能であり、Neo4JやInfiniteGraphのような一般的なデータベースでサポートされている。グラフトラバーサルの実装方法と本手法の評価については、Section VIで詳述する。

#### IV. CODE PROPERTY GRAPHS

セクションIIで提示された各表現は、基盤となるソフトウェアの特定の特性を捉えている。しかし、大多数の場合において、単一の表現だけで脆弱性タイプを特徴付けるには不十分である。そこで、セクションIIIで導入したプロパティグラフの概念を用いて、三つの表現を統合したデータ構造として結合する。具体的には、まずAST、CFG、PDGをプロパティグラフとしてモデル化し、その後、それらを一つのグラフに統合して、各表現の利点をすべて享受できるようにする。

#### *A. Transforming the Abstract Syntax Tree*

唯一、ソースコードを言語構成要素に詳細に分解して表現できる表現はASTである。したがって、我々はASTをプロパティグラフG<sup>A</sup> = (V<sup>A</sup>, E<sup>A</sup>, λ<sup>A</sup>, μ<sup>A</sup>)として表現することにより、統合表現の構築を開始する。ここで、ノードV<sup>A</sup>は木のノードによって与えられ、エッジE<sup>A</sup>は、ラベリング関数λ<sup>A</sup>によってASTエッジとしてラベル付けされた対応する木構造のエッジである。さらに、それぞれのノードにμ<sup>A</sup>を用いてプロパティ*code*を割り当て、各値がノードの表す演算子またはオペランドに対応付けられるようにする。最後に、木構造の順序付き構造を反映するため、各ノードにプロパティ*order*を割り当てる。その結果、グラフのプロパティキーはK<sup>A</sup> = {*code*, *order*}となり、プロパティ値の集合S<sup>A</sup>は全ての演算子およびオペランドと自然数によって与えられる。

# *B. Transforming the Control Flow Graph*

次のステップとして、CFGを統合表現に組み込むための準備を行う。これを目的として、CFGをプロパティグラフ G<sup>C</sup> = (V<sup>C</sup> , E<sup>C</sup> , λ<sup>C</sup> , ·) として表現する。ここで、ノード V<sup>C</sup> は単にASTにおける文および述語、すなわち、キー *code* に対して値が *STMT* および *PRED* であるすべてのノード V<sup>A</sup> に対応する。また、エッジラベル付け関数 λ<sup>C</sup> を定義し、プロパティグラフ内のすべてのエッジに対して、集合 Σ<sup>C</sup> = {*true*, *false*, -} からラベルを割り当てるものとする。

#### *C. Transforming the Program Dependence Graph*

PDGは、文および述語間のデータ依存関係と制御依存関係を表現するものである。このグラフのノードはCFGのものと同じであり、両グラフの違いはエッジのみである。従って、PDGは、新たなエッジ集合E<sup>P</sup>および対応するエッジラベリング関数λ<sup>P</sup> : E<sup>P</sup> → Σ<sup>P</sup>（ここでΣ<sup>P</sup> = {*C*, *D*}は制御依存関係およびデータ依存関係に対応する）を定義することで、プロパティグラフG<sup>P</sup> = (V<sup>C</sup> , E<sup>P</sup> , λ<sup>P</sup> , μp)として表現可能である。さらに、各データ依存関係には対応する記号を示すプロパティ*symbol*を、また各制御依存関係には発生元の述語の状態が*true*もしくは*false*であることを示すプロパティ*condition*を割り当てる。

#### *D. Combining the Representations*

最後のステップとして、3つのプロパティグラフを*コードプロパティグラフ*と呼ばれる共通のデータ構造に統合する。 このグラフを構築するために必要な重要な洞察は、3つのグラフのそれぞれにおいて、ソースコード内の各ステートメントおよび述語に対応するノードが存在するという点である。 実際、ASTは3つの表現の中で唯一、追加のノードを導入するものである。 したがって、ステートメントおよび述語ノードは自然に表現間を接続し、一方の表現から別の表現への遷移点の役割を果たすのである。

定義3. *コードプロパティグラフ*とは、ソースコードのAST、CFGおよびPDGから構築されたプロパティグラフ G = (V, E, λ, μ)である。

- V = VA、
- E = E<sup>A</sup> ∪ E<sup>C</sup> ∪ E<sup>P</sup> 、
- λ = λ<sup>A</sup> ∪ λ<sup>C</sup> ∪ λ<sup>P</sup> である。
- μ = μ<sup>A</sup> ∪ μE、

ここで、表記法をやや乱用してラベリング関数とプロパティ関数を組み合わせている。

コードプロパティグラフの一例を、Figure 1で示したコードサンプルについてFigure 4に示す。簡潔さのため、プロパティキーや値、ASTエッジ上のラベルは表示していない。

![](_page_4_Figure_0.jpeg)

図4：図1に示したコードサンプルのコードプロパティグラフである。

示している。グラフのノードは主にFigure 2aのASTと一致している（無関係な*FUNC*および*IF*ノードを除く）が、変換されたCFGおよびPDGは色付きのエッジで示されている。

# V. TRAVERSALS FOR WELL-KNOWN TYPES OF VULNERABILITIES

コードプロパティグラフは、さまざまな種類のプログラミングパターンを表現することができるが、これが脆弱性の発見にどのように利用できるかは直ちには明らかではない。本セクションでは、コードプロパティグラフを効果的に採掘することで、多様な種類のセキュリティ上の欠陥を特定し、脆弱性の記述用テンプレートを開発できることを示す。最初に、V-B節においてコードの純粋な構文的記述の限界を検討し、次いでさらに制御フロー情報を追加することによりわずかな改善しかもたらさないことを示す（V-C節）。最終的に、V-D節では、データフロー、制御フロー、および構文情報を組み合わせることで、多種多様な脆弱性へのアクセスが可能になることを明らかにする。

#### *A. Motivational Example*

我々は、Esser [7]によってSSH実装で発見され、多くのApple iOSアプリケーションを攻撃にさらしたバッファオーバーフローの最近の例から始める。Esserは、Figure 5に示す脆弱なコードを発見するために正規表現を用いた。

| [...]                                               | 1  |
|-----------------------------------------------------|----|
| if (channelp) {                                     | 2  |
| /* シグナル名（SIGプレフィックス無し）を設定する */    | 3  |
| uint32_t namelen =                                  | 4  |
| _libssh2_ntohu32(data + 9 + sizeof("exit-signal")); | 5  |
| channelp->exit_signal =                             | 6  |
| LIBSSH2_ALLOC(session, namelen + 1);                | 7  |
| [...]                                               | 8  |
| memcpy(channelp->exit_signal,                       | 9  |
| data + 13 + sizeof("exit_signal"), namelen);        | 10 |
| channelp->exit_signal[namelen] = '\0';              | 11 |
| [...]                                               | 12 |
| }                                                   | 13 |
| [...]                                               | 14 |

図5: *libssh2 packet add*関数における脆弱性を示すlibssh2のコード抜粋である。

脆弱な記述（赤で示されている箇所）は、6行目において関数*LIBSSH2 ALLOC*を使用してバッファ*exit signal*のメモリを割り当てている。割り当てるメモリ量は、引数内で変数*namelen*に1を加算することで直接計算されている。残念ながら、この変数は攻撃者が制御可能であり、そのため32ビット符号なし整数の最大値に選択された場合、加算がオーバーフローし、0の値が割り当て関数に渡され、その結果、ほんのわずかなパディングバイトのみが割り当てられる。その後、*namelen*バイトが9行目でサイズ不足のバッファにコピーされる際、バッファオーバーフローが発生する。

Esserは、次の正規表現を使用して6行目の脆弱な文を発見することができた。

ALLOC[A-Z0-9\_]\*\s\*\([ˆ,]\*,[ˆ;]\*[\*+-][ˆ>][ˆ;]\*\)\s\*; .

残念ながら、正規表現は割り当て呼び出し内の合計処理のみを記述しており、これは脆弱性の必要条件の一つでしかない。また、正規表現はコードの入れ子構造をマッチできないため、その記述自体が本質的に曖昧である。しかし、この定式化の最大の欠点は、攻撃者が変数*namelen*を制御できることをモデル化できていない点にある。さらに、変数が適切にサニタイズされていれば、この脆弱性は存在しなかっただろう。最後に、変数のビット幅はこの脆弱性にとって極めて重要である。

この簡単な例は、脆弱性パターンの特徴付けに関与するコードのさまざまな特性について洞察を与えるものである。まとめると、以下の側面を網羅する必要がある。

- 1) *機密性の高い操作*。保護された機能への呼び出し、バッファへのコピー、メモリの割り当てなど、セキュリティ上機密性の高い操作は記述可能である必要がある。例が示すように、割り当て内部の算術演算のような入れ子になったコードは非常に重要であり、そのためASTへの完全なアクセスが必要となる。
- 2) *型の使用法*。多くの脆弱性は、プログラムで使用されるデータ型に密接に関連している。例えば、Figure 5で示されている脆弱性は、*namelen*が32ビット整数ではなく16ビット整数であった場合、存在しなかったはずである。この情報はASTに含まれている。
- 3) *攻撃者による制御*。アナリストは、どのデータソースが攻撃者によって制御されているかを表現できなければならない。例に言及すると、*libssh2 ntohu32* によって返される変数は、攻撃者に制御されている可能性が非常に高い。なぜなら、このルーチンはネットワークバイトオーダーからホストバイトオーダーへ整数を変換するものであり、その整数はほぼ確実に

ネットワークである。これをモデル化するためには、PDGによって表現されるデータ依存性が必要である。

4) *サニタイズ*。最後に、多くの脆弱性は、プログラムが攻撃者制御データの適切なサニタイズを欠いている場合にのみ発生する。例の場合、変数*namelen*が割り当て前に安全な範囲にあるかどうかを確認していれば、脆弱性は存在しなかったであろう。したがって、CFGによって明示された文の順序をモデル化することは極めて重要である。

ここで、コードプロパティグラフによって提供される異なるビューが、脆弱性発見のための成功したグラフトラバーサルの構築にどのように寄与するかを詳細に分析する。

# *B. Syntax-Only Vulnerability Descriptions*

コードプロパティグラフは、元々抽象構文木に含まれていたすべての情報を公開している。この情報は、攻撃者によって制御されるソース、機微な操作、サニタイザを記述するのに十分であるが、本節で示すように、文同士の相互作用を捉えることはできない。

まず、Figure 5における脆弱な文をその構文構造によって説明する。脆弱性の主な特性は、加算が割り当て関数への引数内で直接行われている点であり、この単純な例だけでもすでに2つの課題がある。第一に、関数が加算および呼び出しを含むかどうかを判定する必要がある。第二に、コードの入れ子構造を把握する必要がある。

最初の問題は、関数のすべてのノードを取得し、その後それらをフィルタリングして、いずれかのノードが総和や呼び出しを表しているかどうかを判定することで対処できる。ASTのすべてのノードの中から特定の条件に合致するものを見つけることは、繰り返し発生する問題である。本稿では、ASTのルートからAST内のすべてのノードをたどる再利用可能なトラバーサルTNODESを定義することで、この問題に一度で対処する。この仕組みにより、TNODESとFILTERを組み合わせるだけで、ASTが総和ノードや呼び出しノードを含むかどうかを容易に判定できる。

$$
MATCH_p(V) = FILTER_p \circ TNODES(V)
$$

すべてのv ∈ Vを根とするASTに含まれるすべてのノードを走査し、述語pに従ってこれらのノードをフィルタリングする。コード内の割り当て関数へのすべての呼び出しに走査するには、Vをすべての関数ノードの集合とし、p(v)がvが割り当て関数への呼び出しであるときに真となるようなMATCH走査を実行すればよい。

第二の問題、すなわち関数呼び出しの引数内にネストされた総和を特定することも、容易に解決できるようになる。MATCHのトラバーサルは関数合成を用いて単純に連鎖させることができるからである。例えば、関数fのi番目の引数内の総和を特定するためには、次のトラバーサルを用いる。

$$
\mathrm{MATCH}_p \circ \mathrm{ARG}_f^i
$$

ここで、ARG<sup>i</sup> <sup>f</sup> は、fという名前の関数への呼び出しのi番目の引数を返すMATCHトラバーサルであり、p(v)はμ(v, *code*) = *Summation* のとき真、それ以外の場合は偽である。

MATCHトラバーサルだけでは、ステートメント間の相互作用を特徴付けるのには適していない。しかし、大多数の脆弱性タイプにおいて、センシティブな操作、サニタイザー、攻撃者が制御するソースを正確に記述するための基礎となる。また、単一のステートメントを特徴付けることで、そのタイプの脆弱性の探索範囲を絞り込めるケースも多数存在する（Figure 5の例参照）。以下は、MATCHトラバーサルだけでも同様に成功を収めている脆弱性タイプの例である。

• *危険な引数*。危険な引数は、脆弱性の一般的な原因である。例えば、フォーマット文字列の脆弱性 [see 12, 31, 36] は、攻撃者が制御するフォーマット文字列が *printf* や *sprintf* などの関数に渡された場合に発生し、複数のプラットフォームで任意のコード実行に悪用される可能性がある。フォーマット文字列の脆弱性が発生するための必要条件は、*printf* 、*sprintf*、*fprintf* などのユーティリティ関数に渡されるフォーマット文字列が定数文字列でないことである。これは、次のようなMATCHトラバーサルを用いて記述できる。

#### MATCH<sup>p</sup> ◦ ARG<sup>1</sup> sprintf

ここで、pはvが定数文字列を表さない場合、すなわちμ(v, *code*) = *String*である場合に真となる。この走査は攻撃者制御をモデル化してはいないが、実際には、非定数のフォーマット文字列を提供する理由がほとんどないため、十分にうまく機能している。

• *整数オーバーフロー*。割り当て関数への引数内で算術演算が行われる場合は、図5に示した例のように整数オーバーフローによるメモリ破損が発生しやすい典型的なケースである。これらは、次のような探索によって容易に表現できる。

#### MATCH<sup>p</sup> ◦ ARG<sup>1</sup> malloc

p(v) は、v が算術演算である場合に真となる。例えば、μ(v, code) = *Multiplication* である。

• *整数型の問題*。いくつかの種類の脆弱性は、開発者が予期しない型変換が直接の原因である。特に、バッファオーバーフローは、整数の暗黙的なキャストに起因して、バッファサイズの計算や検証を誤った場合によく発生する。例えば、*整数の切り捨て*は、代入の右辺にある整数が左辺の整数よりも幅広い場合に発生する。これらの種類の脆弱性を発見するのは、前述の二つの場合よりもやや複雑であり、脆弱なケースを特定するためには代入の左右の部分木を比較する必要がある。この目的のために、関数PAIRS<sup>T</sup><sup>2</sup> <sup>T</sup><sup>1</sup>を定義する。例えば、全ての代入ノードの集合から開始し、PAIRSは二つの独立したトラバーサルT<sup>1</sup>とT2を実施する。例えば、一方は代入の左部分木を、一方は右部分木をたどる、というようにして、両トラバーサルの結果をペアとして結合する。これらのペアは、FILTER2と同様に定義された関数PAIRFILTER<sup>p</sup>を用いて述語pによってフィルタリングできる。整数の切り捨ては、これら二つの関数をMATCHと組み合わせることにより容易に検出でき、以下のトラバーサルを得る。

PAIRFILTER<sup>p</sup><sup>1</sup> ◦ PAIRS<sup>T</sup><sup>2</sup> <sup>T</sup><sup>1</sup> ◦ MATCH<sup>p</sup><sup>2</sup>

<sup>1</sup>正式な定義は付録IX-Aに示してある。

<sup>2</sup>PAIRおよびPAIRFILTERの正式な定義は付録IX-Cに示してある。

ここで、p<sup>1</sup>は、2番目のノードが1番目のノードよりも広い型を持つ変数を示す場合に真となる。p<sup>2</sup>は、そのノードが代入である場合に真となる。最後に、T<sup>1</sup>とT<sup>2</sup>はそれぞれ代入の左部分木および右部分木へと辿るものである。

MATCHトラバーサルのみに基づいて脆弱性を特徴付けようとするほとんどの試みは失敗する運命にある。なぜなら、文同士が関係付けられないからである。ただし、セクションIIIで導入したANDおよびORを用いて複数のMATCHトラバーサルを組み合わせることで、潜在的に興味深いコードに絞り込むことが可能である。例えば、*missing permission checks* [see 27, 44]は、セキュリティ上重要な操作と攻撃者が制御するソースが必ず発生し、かつチェックが発生しない場合にコードが脆弱となることで特徴付けられる。不幸なことに、抽象構文木を使用してできることもこれが限界であり、この状況を捉えるために以下の定義を提供する。

定義4. *構文のみの脆弱性記述* Sは、2組 (M0,M1) であり、M<sup>0</sup> および M<sup>1</sup> はMATCHトラバーサルの集合である。ASTノードが構文のみの記述にマッチするとは、M<sup>0</sup> 内のすべてのMATCHトラバーサルにマッチし、かつM1内のいずれのトラバーサルにもマッチしない場合である。

構文のみの脆弱性記述は実際には効果的であることが多い。しかし、攻撃者の制御や文間の相互作用を表現することができないため、誤検知が多く発生しがちである。次のセクションでは、この問題に部分的に対処する制御フローに基づく記述について論じる。

#### *C. Control-Flow Vulnerability Descriptions*

コードプロパティグラフの制御フローエッジを使用することで、文の実行順序をモデル化できるため、より広範な脆弱性にアクセス可能となる。特に、以下のような制御フローグラフ内のパスに対応する脆弱性をうまく記述できる。

- *リソースリーク*。多くの脆弱性は、リソースが割り当てられた際に、すべてのエラーパスで適切に解放されない場合に存在する。典型的なケースでは、これによりシステムが利用不能になるが、更なる脆弱性を引き起こすために利用されることもある。
- *ロックの解放漏れ*。一般的な場合の並行性の問題は検出が難しいが、単純な制御フロー解析を用いることで、エラーパスにおいてロックが解放されていないケースを検出できる。
- *Use-after-free脆弱性*。コードがすでに解放されたメモリ領域にアクセスするようなソフトウェアの欠陥は、任意のコード実行に悪用されることが多い。この種の脆弱性は、一見無関係に見える複数の関数の複雑な相互作用から生じることが多いが、関数内においては単純な制御フロー解析でこれらの脆弱性を特定できる場合もある。

いずれの三つの場合にも、脆弱性は制御フローグラフ内の特定の経路と関連付けることができる。たとえば、リソースリークは、メモリを取得する文（例：*malloc*の呼び出し）から、そのリソースを解放する文（例：*free*の呼び出し）を経ずに関数の終端に至る制御フローグラフ内の経路に結び付けられる。しかし、この経路が関連するのは、割り当て関数が確かに割り当てられたメモリへのポインタを返す場合のみである。このため、制御フローグラフ内の経路には更なる制約を付加する必要がある。これらの観察を次の定義にまとめる。

定義5. *制御フロー脆弱性記述*とは、4-組 (Ssrc, Send, Sdst, {(S<sup>i</sup> cnd, ti)}<sup>i</sup>=1...N ) であり、ここでSsrcはソースステートメントの構文のみの記述、Sendはエンドステートメントの記述、Sdstはデスティネーションステートメントの記述、{(S<sup>i</sup> cnd, ti)}<sup>i</sup>=1...N は条件のための構文のみの記述およびそれに関連するアウトカムt<sup>i</sup> ∈ {true, false}のリストである。ノードvが制御フロー脆弱性記述に一致するのは、以下の条件が成り立つ場合である。

- vを根とするASTは、根ノードvsrcを持ち、Ssrcに一致する部分木を含んでいる。
- 制御フローグラフにおいて、vsrcからSendに一致するノードへの経路が存在し、その経路はSdstに一致するノードを通過しない。
- すべての1 ≤ i ≤ Nについて、もしノードがSi cndの記述に一致する場合、そのノードから始まる経路上のすべてのエッジはtiとしてラベル付けされなければならない。

制御に基づく脆弱性は、ある集合のソースノードから、宛先の説明に一致するノードを経由せず、条件の説明および関連する結果に従うエンドノードまでのすべてのパスを見つけるための深さ優先探索を実行するトラバーサルによって表現できる。簡潔さのために、このトラバーサルの正式な定義は省略する。

残念ながら、制御フローおよび構文情報だけでは、通常、脆弱性パターンを特定するには十分ではない。次のセクションで述べるように、特に攻撃者が制御するデータのフローを追跡することに関心があるためである。

#### *D. Taint-Style Vulnerability Descriptions*

最後に、構文、制御およびデータフロー情報を組み合わせて脆弱性をモデル化する。構文のみや制御フローによる脆弱性の記述と比較して、データフローエッジを用いることで攻撃者制御をモデル化する追加的な能力を得ることができる。

各ステートメントノードは、それに到達するすべての代入や変数定義からの入力データフローエッジを持っているため、これらのエッジをたどるだけで、ステートメントで使用されている変数を生成するすべてのステートメントへ容易にたどることができる。しかし、データフローエッジで接続されているのはステートメントノードだけであるため、例えば関数呼び出しの引数からそのデータ生成元へたどりたい場合、まずはその引数が属するステートメントへたどる必要があるという小さな困難が生じる。幸いなことに、これは付録IX-Bで形式的に定義されたトラバーサルSTATEMENTを用いることで容易に実現できる。一群のノードの変数の生成元は、その後、このトラバーサルを用いて計算できる。

$$
PRODUCERS_{\mathcal{N}} = \bigcup_{n \in \mathcal{N}} IN_{D}^{symbol,n} \circ \text{STATEMENT}
$$

ここでNは関心のある識別子の集合であり、これにより文で使用される変数の部分集合に分析を制限できる。便宜上、文で使用される変数のいずれかに対してデータを生成する全ての文を記述する走査としてSOURCESも定義する。

SOURCESは貴重なトラバーサルであり、機密性の高い操作やデータソースについて構文のみの記述と組み合わせることで、攻撃者が制御するデータが機密性の高い操作で使用されるケースを特定できる。たとえば、Linuxカーネルにおけるバッファオーバーフローの一般的な現れ方は、*get user*関数によって生成されたユーザ提供の整数が、*memcpy*操作のサイズフィールドとして直接使用される場合である。こうした脆弱性を特定するために、次のようなトラバーサルを定式化できる。

$$
\text{MATCH}_p \circ \text{Sources} \circ \text{ARG}_{\text{memory}}^3
$$

ここでpは、ノードが*get user*への呼び出しを表している場合にtrueを返す述語である。つまり、*memcpy*の第三引数を直接生成する*get user*へのすべての呼び出しにたどることができる。また、トラバーサルSOURCESは任意の回数連鎖させることができ、引数が攻撃者が制御するソースによって間接的にのみ生成されるケースを特定できる。

この定式化の弱点は、データのサニタイズを考慮しておらず、そのため、データが有害でないことを確認するチェックが行われている場合でも、事例が返される点である。サニタイザを考慮するための一つの可能性は、構文のみの追加記述を導入することである。しかし、これは文の順序を考慮しないため、チェックが正しい位置に置かれているかどうかを検出できない。われわれは、制御フロー情報とデータフロー情報の組み合わせを用いることで、この欠点に対処する。特に、SOURCESと同等の機能を提供しつつ、サニタイザについて構文のみの記述を追加できるようなトラバーサルの構築を目指す。

トラバーサルUNSANITIZED<sup>3</sup>を、SOURCESのドロップイン置換として定義する。このトラバーサルは、記号sに対して、記号固有の構文のみのサニタイザー記述S<sup>s</sup> valを追加で指定でき、これによって正しくサニタイズされたすべての場合を除外できる。トラバーサルは、以下の二つの条件を満たす場合に限り、攻撃者が制御可能なソースのみを返す。

- 制御フローグラフにおいて、ソース文からシンク文への経路が存在し、その経路上のいかなるノードもサニタイザーの記述と一致しない。
- ソースによって定義され、シンクによって使用される変数が、制御フローパスを介してシンクに到達する、すなわち、そのパス上のいかなるノードによっても変数が再定義されていない、ということである。

構文のみの記述とUNSANITIZEDトラバーサルを組み合わせ、テイント型脆弱性記述を次のように定義する。

定義6. *taint-styleな脆弱性記述*とは、攻撃者が制御可能なソースに対する構文のみの記述Ssrc、セキュリティに敏感なシンクSdst、及びサニタイザーに対する構文のみの記述の集合(S<sup>s</sup> san)からなる3-タプル(Ssrc, Sdst, S<sup>s</sup> san)である。ノードvがtaint-styleな記述に合致するとは、vを根とするASTが、Ssrcに合致するvsourceを根とする部分木と、Sdstに合致するvsinkを根とする別の部分木の両方を含む場合である。

- vsource から vsink へのデータ依存エッジのパスが存在する、すなわち (v0,...,vn) というノード列が存在し、v<sup>0</sup> = vsource、v<sup>n</sup> = vsink、e<sup>i</sup> = (vi, v<sup>i</sup>+1) ∈ E かつ λ(ei) = D であることが、すべての i = 0,...,n − 1 について成り立つ。
- これらの各データ依存エッジ e<sup>i</sup> = (vi, v<sup>i</sup>+1) について、制御フローグラフにおいて v<sup>i</sup> から v<sup>i</sup>+1 へのパス (v0,...,vm) が存在し、全ての k, 0 ≤ k ≤ m について v<sup>k</sup> である。

μ(ei,*symbol*)を定義しておらず、v<sup>k</sup>はサニタイザーの説明<sup>S</sup><sup>μ</sup>((vi,vi+1),*symbol*) sanと一致しない。

テイントスタイルの記述は、検証済みのソース・シンクシステムで記述可能な脆弱性のトラバーサルを定義するのに適している［18参照］。この種の脆弱性の例としては、インジェクション脆弱性、バッファオーバーフロー、整数オーバーフロー、整数型の脆弱性、安全でない引数、権限チェックの欠如、さらにはメモリの漏洩などが挙げられる。以下の例がこれを示している。

• *バッファオーバーフローの脆弱性。* フローベースの記述を動機付けるために議論したように、多くのバッファオーバーフローはコピー操作に渡される長さフィールドの検証が不十分であることが原因で発生する。例えば、Linuxカーネルのコードでは、多くのバッファオーバーフローが*get user*関数によって読み取られ、*memcpy*や*copy from user*の第3引数として渡されるサイズフィールドが検証を受けずに処理されることによって生じている。この脆弱性パターンは、以下のようなトラバーサルによって表現できる。

$$
\text{ARG}^{1}_{get\_user} \circ \text{UNSANITIZED}_{\{\mathcal{T}_s\}} \circ \text{ARG}^{3}_{memory}
$$

このトラバーサルは、*get user* の第一引数によって直接的に汚染され、かつトラバーサル Ts に一致するノードによって検証されていない *memcpy* の全ての第三引数を選択するものである。例えば、トラッキングされている変数 s を含む関係式に一致するマッチトラバーサルが挙げられる。この種のトラバーサルは、UNSANITIZED トラバーサルを連鎖させることによって、間接的に汚染された引数も含めるよう容易に拡張できる。

• *Code injection vulnerabilities.* SQLやコマンドインジェクションなどの脆弱性は、Taintスタイルの記述を用いてよく説明できる。例えば、攻撃者が任意のシェルコマンドを実行できるような典型的なコマンドインジェクションの脆弱性は、次のようなトラバーサルを用いて記述できる。

$$
\text{ARG}^2_{recv} \circ \text{UNSANITIZED}_{\{\mathcal{T}_s\}} \circ \text{ARG}^1_{system}
$$

ここで T<sup>s</sup> は、比較とセミコロン、そしてよく知られた検証関数への呼び出しに一致するトラバーサルである。このトラバーサルは、*recv* の第二引数が、セミコロンを含むかどうかの検査なしに *system* の第一引数へ到達するすべての場合を返す。

• *権限チェックの欠如。* ウェブアプリケーションとカーネルコードの両方は、操作を実行する前にユーザーの権限を確認する必要があるが、これを怠ると権限昇格が可能となる［27, 44参照］。この種の脆弱性は以下のように表現できる。

$$
\text{Match}_{p1} \circ \text{Unsanitized}_{\{ \text{Match}_{p2} \}} \circ \text{Match}_{p3}
$$

ここで、p1、p2、およびp3は、それぞれ攻撃者が制御するソース、ユーザーが十分な権限を持っていることを確認するチェック、およびセキュリティ上重要な操作を記述する述語である。

汚染スタイルの記述により、攻撃者が制御するソース、セキュリティ上重要な操作、サニタイザー、型情報、さらにデータおよび制御フローにおける文同士の相互作用までを記述することができる。これにより、広範囲な脆弱性を網羅する検索クエリの提供が可能となる。次のセクションでは、

<sup>3</sup>UNSANITIZEDの正式な定義は付録IX-Eに記載されている。

我々のアプローチの評価を提示し、対象とする脆弱性の種類が、今日のセキュリティクリティカルなコードに実際に関連していることを示す。

#### VI. EVALUATION

我々は、我々のアプローチの実用的な有効性をLinuxカーネルのソースコード上で評価する。Linuxカーネルは大規模なコードベースであり、複数のソフトウェアベンダーおよびオープンソースコミュニティによって定期的に脆弱性の監査が行われている。我々の評価は2段階で実施される。まず、2012年に報告されたLinuxカーネルの全脆弱性のコードをレビューし、どの脆弱性タイプがグラフトラバーサルを用いてモデル化できるかを決定することで*カバレッジ分析*を行う（Section VI-B）。次に、我々のアプローチが脆弱性を*発見する能力*を調査するため、一般的な脆弱性に対するトラバーサルを構築し、それをLinuxカーネルのコードプロパティグラフに適用する（Section VI-C）。

#### *A. Implementation*

本評価のために、コードプロパティグラフのアイデアに基づいた静的コード解析システムを実装している。我々のシステムは、頑健なC/C++パーサを用いて、まず与えられたコードベース内の各関数のASTを抽出する。その後、これらのASTをCFGおよびPDGへ変換し、第IV章で概説したように、三つの表現全てをコードプロパティグラフへ統合する。さらに、コード中のグローバル変数および構造体宣言に対してノードを追加する。最後に、可視な呼び出し元・呼び出し先の関係に基づき、全関数のグラフを結合し、結果としてコードベース全体を一つの大規模なコードプロパティグラフとして表現する。

Linuxカーネルのソースコードについては、5200万ノードと8700万エッジからなるグラフが得られる。このように大規模なグラフ上で情報を探索することは、一般的なハードウェアでは決して容易な作業ではない。しかし幸いなことに、非常に大きなプロパティグラフへの効率的なアクセスを提供できる専用のグラフデータベースを利用することができる（*Neo4J Version 1.9.5*を使用している）。さらに、これらのグラフデータベースは、グラフの探索を高速化する高度なキャッシュアルゴリズムの恩恵も受けられる。

プロトタイプ実装を用いた場合、約130万行のコードを持つLinux kernel version 3.10-rc1のインポートには、2.5 GHz Intel Core i5 CPUと8 GBのメインメモリを搭載したノートパソコンで合計110分を要する。その結果として得られるデータベースは、ノードとエッジのために14 GBのディスク容量、および効率的なインデックス作成のためにさらに14 GBを必要とする。

グラフ探索を実装するために、*Gremlin*は非常に適したグラフ言語であると考える。なぜなら、ユーザー定義の探索処理を連結してデータベースに提供できるため、SQLデータベースにおけるストアドプロシージャに類似したメカニズムを実現できるからである。これにより、Section Vで提示した様々な探索処理を直接Gremlinコードに変換することが可能となる。さらに、Gremlinは*Blueprints*という互換レイヤーを介してデータベースと連携する数少ない言語の一つであり、このため、作成した探索処理すべてを他のグラフデータベース実装で修正することなく実行できる。

本論文で提示した脆弱性発見のためのトラバーサルの実行は、コールドデータベース、すなわちデータベース内容をハードディスクから読み込む必要がある場合でも40秒未満で完了する。ノードとエッジがメインメモリにキャッシュされると、実行時間は30秒まで短縮され、その大部分はトラバーサルUNSANITIZEDを用いて大規模な関数内の実行可能な制御フローパスを判定する作業に費やされる。

# *B. Coverage Analysis*

我々は、MITRE組織が管理している中央脆弱性データベースを照会することから分析を開始する。このデータベースから、2012年にLinuxカーネルの脆弱性に割り当てられたすべてのCVE識別子を取得した。合計で、カーネルのソースコードに存在する88件の固有の脆弱性に対応する69件の識別子を取得した。これらの脆弱性をさまざまなタイプに分類するために、それぞれの脆弱性に対するパッチを手動で調査し、報告された欠陥の根本原因を特定した。この情報によって、88件の脆弱性を表Iに示す12種類の共通タイプに分類することができた。脆弱性の半数以上（88件中47件）は、メモリ開示、バッファオーバーフロー、またはリソースリークであり、これらはいずれも第V節で述べられるグラフトラバーサルを用いて適切に表現することができる。

本手法のカバレッジを評価するために、Linuxカーネルで発見された12種類の脆弱性タイプを記述するのに必要なコード表現を分析する。特に、(a) AST単独、(b) ASTとPDGの組み合わせ、(c) ASTとCFGの組み合わせ、(d) AST・PDG・CFGの組み合わせ、これらのカバレッジを分析する。この分析の結果はTable IIに示す。

| 脆弱性の種類             | コード表現            |         |         |             |
|---------------------------|----------------------|---------|---------|-------------|
|                           | AST                  | AST+PDG | AST+CFG | AST+CFG+PDG |
| メモリ情報漏洩            |                      |         |         | ✓           |
| バッファオーバーフロー     |                      | (✓)     |         | ✓           |
| リソースリーク            |                      |         | ✓       | ✓           |
| 設計ミス                  |                      |         |         | ✓           |
| ヌルポインタ参照          |                      |         |         | ✓           |
| 権限チェック漏れ          |                      | ✓       |         | ✓           |
| レースコンディション       |                      | ✓       |         | ✓           |
| 整数オーバーフロー        |                      |         |         | ✓           |
| ゼロ除算                  |                      | ✓       |         | ✓           |
| 解放後参照                |                      |         | (✓)     | (✓)         |
| 整数型問題                |                      |         |         | ✓           |
| 安全でない引数            | ✓                    |         | ✓       | ✓           |

TABLE II: 脆弱性タイプをモデル化するためのさまざまなコード表現のカバレッジを示す。

明らかに、AST単体ではセキュリティ上の欠陥を発見するには情報が乏しく、不適切な型変換のような一部の不安全な引数の形式のみがこの表現によって発見できるに過ぎない。ASTとPDGの情報を組み合わせることで、コードをよりよく把握でき、バッファオーバーフローの様々なクラスや、権限チェックの欠如、ゼロによる除算などを記述できる。しかし、ASTとPDGの組み合わせは、文の順序が重要となるケース、例えばセキュリティチェックの場所を特定する必要がある場合には限定的な有用性しか持たない。ASTとCFGの組み合わせでも、依然としていくつかの脆弱性は見逃される。

<sup>4</sup>http://mlsec.org/joern/

| Vulnerability types          | Description                                                                                                                       | #  |
|------------------------------|-----------------------------------------------------------------------------------------------------------------------------------|----|
| Memory Disclosure            | 構造体がユーザ空間へコピーされる際、すべてのフィールドやパディングバイトが適切に初期化されておらず、その結果としてメモリ漏洩が発生する。         | 21 |
| Buffer Overflows             | コピー操作に関与する長さフィールドが検証されておらず、その結果としてバッファオーバーフローが発生する。                                        | 16 |
| Resource Leaks               | 関数がリソースを生成するが、すべてのエラーパスにおいてそのリソースが破棄されていない。                                                       | 10 |
| Design Errors                | プログラム設計が十分にセキュリティポリシーを実装していない。                                                                           | 10 |
| Null Pointer Dereference     | 攻撃者によって制御されるポインタが、nullかどうかを確認せずにデリファレンスされる。                                                         | 8  |
| Missing Permission Checks    | セキュリティ上センシティブな操作が、事前の権限チェックを経ずにアクセス可能である。                                                          | 6  |
| Race Conditions              | 同時実行されるプロセスが様々な種類の脆弱性を引き起こす。                                                                              | 6  |
| Integer Overflows            | コピー操作に関与する長さフィールドが検証されるが、その検証が不十分であり、整数オーバーフローが考慮されていない。                            | 3  |
| Division by Zero             | 攻撃者が制御する値が除算の分母となり、それがゼロであることが許容されている。                                                             | 3  |
| Use After Free               | 割り当てられたメモリブロックが、アロケータによって解放された後に使用される。                                                              | 3  |
| Integer Type Vulnerabilities | コピー操作に関与する長さフィールドが検証されるが、その検証が不十分であり、長さフィールドが符号付き整数となっている。                         | 1  |
| Insecure Arguments           | 関数に引数を渡す際、暗黙的かつ安全でない型キャストが発生する。                                                                          | 1  |
| Total vulnerabilities        |                                                                                                                                   | 88 |

TABLE I: 2012年にLinuxカーネルで発見された脆弱性を脆弱性の種類別に分類したものである。

脆弱性の種類は、攻撃者が制御するデータのフローをモデル化することを必要とする。しかし、リソースリークや一部のuse-after-free脆弱性は、CFGにエンコードされた文のフローから特定できる。

すべての表現をコードプロパティグラフに組み合わせることで、最終的にAST、CFG、PDGから得られる情報を利用して12種類の脆弱性タイプのうち10種類をモデル化できるようになった。残りの2種類、すなわちレースコンディションと設計上のエラーは、前者が実行時の特性に依存し、後者がプログラムの意図された設計に関する詳細なしにはモデル化が難しいため、グラフトラバーサルによる表現が困難である。さらに、実行時情報なしでは記述が困難なユースアフターフリー脆弱性の作為的なケースも多数存在する。我々のアプローチの限界についてはセクションVIIで議論する。

# *C. Discovery of Vulnerabilities*

コードプロパティグラフ上でのグラフトラバーサルは、多くの脆弱性タイプを記述するのに適しているが、実際に効果的であるかどうかはまだ示されていない。この目的のために、Linuxカーネルのコードプロパティグラフをさまざまな種類の脆弱性に対するトラバーサルを用いて実際に評価する。

まず、2012年に最も一般的に遭遇した2つの脆弱性タイプ、すなわち境界チェックの欠如による*バッファオーバーフロー*と、不完全に初期化された構造体が原因となる*メモリ漏洩*について、走査方法を定義する。次に、2012年には遭遇しなかった脆弱性タイプ、すなわち*メモリマッピング脆弱性*および*ゼロバイト割当て*の走査方法を構築する。これらはいずれもLinuxカーネル特有の脆弱性タイプであり、従来のツールでは発見が難しいものである。要約すると、本研究の実験では以下の走査方法を用いた。

- *バッファオーバーフロー。* 攻撃者が制御する長さフィールドに対する検査の欠如に起因するバッファオーバーフローのためのトラバーサルを構成する。このトラバーサルについては、VI-D節で詳細に論じている。
- *メモリ開示。* 2012年にLinuxカーネルで発見された最も多くのセキュリティ重大な脆弱性は、適切に初期化されていない構造体がユーザ空間にコピーされることによって引き起こされている。これらの脆弱性は、攻撃者によってカーネルメモリに格納された機密オブジェクトを漏洩させるために利用されうる。判別するためには

これらの脆弱性に対して、構造体のローカル宣言からユーザ空間へのコピー操作まで、*memset* を通過しない経路を追跡するテイント方式の探索を構築する。また、構造体の型を調べ、すべてのフィールドに代入が行われているかどうかを判断するために、構文のみの説明を使用する。

- *メモリマッピング*。カーネルは、機密情報の漏洩や任意コードの実行を防ぐために、ユーザーが任意の物理メモリアドレスをユーザースペースへマッピングできないようにしなければならない。この種の脆弱性は、カーネルに特有のものである。我々は、これらの脆弱性を特定するための単純な構文のみの脆弱性記述を策定し、本手法がプログラム特有のバグにも十分に適応できることを示す。
- *ゼロバイト割り当て*。攻撃者が割り当て関数にゼロバイトの長さフィールドを渡すことができる場合、多くの割り当て関数が割り当てられたメモリではなくエラーコードを返すため、Linuxカーネルではクラッシュにつながりやすい。他のアロケーターと比べてこれは一般的ではなく、そのためプログラム特有の脆弱性となる。本稿では、これらのケースを汚染スタイルのトラバーサルでカバーする。

全体として、4つのトラバーサルを実行することにより、これまで知られていなかった18件の脆弱性を特定した。これらはすべてカーネル開発者によって対処済みである。特に憂慮すべき点は、18件中9件が昨年普及していた脆弱性タイプであったことである。これは、攻撃者にとって既存の脆弱性パターンをモデル化することが十分であり、トラバーサルを用いることでコードベース内の同様の不具合を効果的に発見できることを示している。Table IIIに本調査結果をまとめた。

これから、脆弱性発見プロセスをグラフトラバーサルを用いて説明する事例について議論する。単純なトラバーサルによって、わずか11個の関数をレビューしただけで7つの未知のバッファオーバーフロー脆弱性を特定できたことを示す。

# *D. Case Study: Buffer Overflow Identification*

以下において、長さフィールドに対する検証チェックの欠如によって引き起こされるバッファオーバーフローを特定するためのトラバーサルを提示する。この種の脆弱性は、テイントスタイルの記述を用いて巧みに表現できるため、T<sup>0</sup> ◦ UNSANITIZED<sup>T</sup> <sup>s</sup> <sup>1</sup> ◦ T2 という形のトラバーサルとして捉えることができる。この目的のためには、単に定義するだけでよい。

| 種類                  | 場所                                        | 開発者フィードバック  | 識別子         |
|----------------------|------------------------------------------|--------------------|---------------|
| バッファオーバーフロー | arch/um/kernel/exitcode.c                | 修正済み            | CVE-2013-4512 |
| バッファオーバーフロー | drivers/staging/ozwpan/ozcdev.c          | 修正済み            | CVE-2013-4513 |
| バッファオーバーフロー | drivers/s390/net/qeth_core_main.c        | 修正済み            | CVE-2013-6381 |
| バッファオーバーフロー | drivers/staging/wlags49_h2/wl_priv.c     | 修正済み            | CVE-2013-4514 |
| バッファオーバーフロー | drivers/scsi/megaraid/megaraid_mm.c      | 修正済み            | -             |
| バッファオーバーフロー | drivers/infiniband/hw/ipath/ipath_diag.c | 修正済み            | -             |
| バッファオーバーフロー | drivers/infiniband/hw/qib/qib_diag.c     | 修正済み            | -             |
| メモリ漏洩            | drivers/staging/bcm/Bcmchar.c            | 修正済み            | CVE-2013-4515 |
| メモリ漏洩            | drivers/staging/sb105x/sb_pci_mp.c       | 修正済み            | CVE-2013-4516 |
| メモリマッピング      | drivers/video/au1200fb.c                 | 修正済み            | CVE-2013-4511 |
| メモリマッピング      | drivers/video/aul100fb.c                 | 修正済み            | CVE-2013-4511 |
| メモリマッピング      | drivers/uio/uio.c                        | 修正済み            | CVE-2013-4511 |
| メモリマッピング      | drivers/staging/.../drv_interface.c      | 修正済み            | -             |
| メモリマッピング      | drivers/gpu/drm/i810/i810_dma.c          | 修正作業中である    | -             |
| 0バイト割り当て       | fs/xfs/xfs_ioctl.c                       | 修正済み            | CVE-2013-6382 |
| 0バイト割り当て       | fs/xfs/xfs_ioctl32.c                     | 修正済み            | CVE-2013-6382 |
| 0バイト割り当て       | drivers/net/wireless/libertas/debugfs.c  | 修正済み            | CVE-2013-6378 |
| 0バイト割り当て       | drivers/scsi/aacraid/commctrl.c          | 修正済み            | CVE-2013-6380 |

TABLE III: 我々の4つのグラフトラバーサルを用いて発見されたゼロデイ脆弱性

攻撃者が制御するソースには適切なトラバーサルT<sup>0</sup>、サニタイザにはT<sup>s</sup> <sup>1</sup>、そして最後にセキュリティ上重要なシンクにはT<sup>2</sup>を用いる。本稿ではまず攻撃者が制御するソースから始めるが、これらは調査対象アプリケーションに固有である。Linuxカーネルの場合、潜在的に有害な入力の著名なソースとして、以下の2つが考慮される。

- *ユーザー／カーネル空間インターフェース*。データはさまざまなAPI関数を用いてユーザー空間からカーネル空間にコピーできる。例として、*copy from user* 関数を考える。この関数は、その第1引数を攻撃者が制御するデータで汚染する。この動作は、遷移 T <sup>0</sup> <sup>0</sup> = ARG<sup>1</sup> *copy from user* によって表現できる。
- *システムコールハンドラのパラメータ*。攻撃者は、対応するシステムコールを呼び出すことによって、システムコールハンドラのパラメータを直接制御できる。本稿では、書き込み系システムコールの*count*パラメータを例として考察し、トラバーサルT <sup>1</sup> <sup>0</sup> = FUNC( *write*) ◦ PARAM*cnt* を用いる。ここで、PARAM<sup>p</sup>およびFUNC<sup>f</sup>は、それぞれpという名前を持つパラメータおよび名前にfという部分文字列を含む関数ノードに対して非空である。

データシンクとして、*copy from user*や*memcpy*呼び出しに渡される長さフィールド（すなわち第3引数）を考慮する。なぜなら、攻撃者がバッファにコピーされるデータ量を制御できるケースの特定に関心があるためである。システムコールハンドラの場合、*copy from user*への呼び出しのみを解析対象とすることで、長さフィールドだけでなくコピーされるデータ自体も攻撃者の制御下にあることを保証できるよう、解析範囲をさらに限定する。したがって、シンクトラバーサルは T <sup>0</sup> <sup>2</sup> = ARG<sup>3</sup> *memcpy* および T <sup>1</sup> <sup>2</sup> = ARG<sup>3</sup> *copy from user* によって与えられる。

最後に、次のいずれかの条件が満たされていれば、長さフィールドが適切にサニタイズされているとみなすことで、偽陽性の数を減らす。

- *宛先バッファの動的割り当て。* 宛先バッファは、そのサイズを指定するためにlengthフィールドを用いて動的に割り当てられる。このため、バッファはデータを格納するのに十分な大きさとなる。
- *関係式。* 長さフィールドは条件内の関係式で使用される、例えば、x <

バッファサイズ、あるいはマクロ *min* の呼び出し時に行われる。なお、このような検査は不正確である可能性があるため、本ルールは偽陽性と偽陰性とのトレードオフの実用的な例である。

したがって、サニタイザートラバーサル T <sup>s</sup> <sup>1</sup> を <sup>T</sup> <sup>s</sup> <sup>1</sup> = OR(V<sup>s</sup> <sup>0</sup> , <sup>V</sup><sup>s</sup> <sup>1</sup> ) と定義する。ここで、<sup>V</sup><sup>s</sup> <sup>0</sup> は第一引数が s を含むアロケーションと一致するトラバーサルであり、V<sup>s</sup> <sup>1</sup> は s を含む相対式および *min* への呼び出しと一致するトラバーサルである。最終的なトラバーサルは次のように与えられる。

OR(
$$
\mathcal{T}_0^0 \circ \text{UNSANITIZED}_{\mathcal{T}_1^s} \circ \text{OR}(\mathcal{T}_2^0, \mathcal{T}_2^1),
$$
 $\mathcal{T}_0^1 \circ \text{UNSANITIZED}_{\mathcal{T}_1^s} \circ \mathcal{T}_2^1$ )

このトラバーサルをLinuxソースコード全体に対して実行すると、表IVに示す11個の関数が返される。そのうち7つの関数がバッファオーバーフロー脆弱性である。一例として、図6は脆弱な関数*qeth snmp command*を示している。13行目で攻撃者が制御するデータによってローカル変数req lenが初期化されている。この変数は、28行目でコピー操作の長さフィールドとして、サニタイズされずに使用されている。したがって、攻撃者はバッファ*snmp*をオーバーフローさせ、任意のコードが実行可能となる可能性がある。

| Filename                                 | Function             |
|------------------------------------------|----------------------|
| arch/um/kernel/exitcode.c                | exitcode_proc_write  |
| security/smack/smackfs.c                 | smk_write_rules_list |
| drivers/staging/ozwpan/ozcdev.c          | oz_cdev_write        |
| drivers/infiniband/hw/ipath/ipath_diag.c | ipath_diagpkt_write  |
| drivers/infiniband/hw/qib/qib_diag.c     | qib_diagpkt_write    |
| drivers/scsi/megaraid/megaraid_mm.c      | mimd_to_kioc         |
| drivers/scsi/megaraid.c                  | megadev_ioctl        |
| drivers/char/xilinx_.../xilinx_hwicap.c  | hwicap_write         |
| drivers/s390/net/qeth_core_main.c        | qeth_snmp_command    |
| drivers/staging/wlags49_h2/wl_priv.c     | wvlan_uil_put_info   |
| arch/ia64/sn/kernel/sn2/sn_hwperf.c      | sn_hwperf_ioctl      |

TABLE IV: 本節で述べたグラフトラバーサルを用いてLinuxカーネルから抽出された11個の関数を示す。脆弱性のあるものは網掛けされている。

| int qeth_snmp_command(struct qeth_card *card, | 1  |
|-----------------------------------------------|----|
| char __user *udata)                           | 2  |
| {                                             | 3  |
| struct qeth_cmd_buffer *iob;                  | 4  |
| struct qeth_ipa_cmd *cmd;                     | 5  |
| struct qeth_snmp_ureq *ureq;                  | 6  |
| int req_len;                                  | 7  |
| struct qeth_arp_query_info qinfo = {0, };     | 8  |
| int rc = 0;                                   | 9  |
| // []                                         | 10 |
| /* 4バイト（data_len構造体メンバ）をスキップして | 11 |
| req_lenを取得する */                         | 12 |
| if (copy_from_user(&req_len, udata            | 13 |
| + sizeof(int),sizeof(int)))                   | 14 |
| return -EFAULT;                               | 15 |
|                                               | 16 |
| ureq = memdup_user(udata, req_len +           | 17 |
| sizeof(struct qeth_snmp_ureq_hdr));           | 18 |
| if (IS_ERR(ureq)) {                           | 19 |
| QETH_CARD_TEXT(card, 2, "snmpnome");          | 20 |
| return PTR_ERR(ureq);                         | 21 |
| }                                             | 22 |
| // []                                         | 23 |
| iob = qeth_get_adapter_cmd(card,              | 24 |
| IPA_SETADP_SET_SNMP_CONTROL,                  | 25 |
| QETH_SNMP_SETADP_CMDLENGTH + req_len);        | 26 |
| // []                                         | 27 |
| memcpy(&cmd->data.setadapterparms.data.snmp,  | 28 |
| &ureq->cmd, req_len);                         | 29 |
| rc = qeth_send_ipa_snmp_cmd(card, iob,        | 30 |
| QETH_SETADP_BASE_LEN + req_len,               | 31 |
| qeth_snmp_command_cb, (void *)&qinfo);        | 32 |
| // []                                         | 33 |
| kfree(ureq);                                  | 34 |
| kfree(qinfo.udata);                           | 35 |
| return rc;                                    | 36 |
| }                                             | 37 |

図6：本手法を用いて発見したLinuxカーネルドライバにおけるバッファオーバーフロー脆弱性である。

### VII. LIMITATIONS

Linuxカーネルにおけるいくつかの未知の脆弱性の発見は、我々の手法の有効性を明確に示している。しかしながら、考慮すべき制限も存在する。まず、我々の手法は純粋に静的であり、静的プログラム解析に内在する制限を克服することはできない。制御フローおよびデータフロートラッキングは実装しているが、記号実行で可能なように、異なる表現であっても本質的に等価な式を見つけるためのコード解釈などは行っていない。その結果、競合状態のような実行時動作に起因する脆弱性は、コードプロパティグラフを用いてモデル化することができない。

第二に、脆弱性発見の問題が一般の場合には決定不能であるという事実により[33]、我々の手法は潜在的に脆弱なコードのみを発見できるに過ぎない。特定の種類の脆弱性を対象とする手法とは対照的に、我々はセキュリティ上の欠陥の存在を必ずしも保証しないものの、非常に大規模なソフトウェアプロジェクトにおける潜在的な脆弱性を特定可能な、汎用的な脆弱性発掘手法に注目している。

第三に、我々の現時点での実装は、手続き間解析には対応していない。グラフデータベース内で呼び出し関係に基づき関数を連結しているが、効果的な手続き間トラバーサルの定式化にはさらなる課題がある。これは我々の手法の本質的な制限ではなく、制御フローグラフやプログラム依存グラフには、手続き間制御フローグラフやシステム依存グラフのような手続き間変種が存在する［17参照］。今後は、手続き間解析に向けた拡張を目指す予定である。

#### VIII. RELATED WORK

脆弱性のパターンをソースコードからスキャンする手法には長い歴史があり、Microsoft PREfast [23]、PScan [5]、RATS [4] など、実際に利用されている複数の脆弱性スキャナがこの考え方を採用し、いくつかのよく知られた脆弱性を検出してきた。これらのツールは、特に開発プロセスにおいて有用であるが、通常はコード内の複雑で微妙な脆弱性を特定できない。また、こうしたツールを特定のコードベースの事情に合わせて適応させることも不可能である。この問題への対策として、いくつかの研究者は専門家の知識を静的解析手法に取り込むことを検討してきた。例えば、Evans と Larochelle [8] は、Splint というツールを説明しており、これはアナリストが注釈を付与することで、異なるアプリケーションにおけるバッファオーバーフローやフォーマットストリング脆弱性の出現を発見できるようになっている。さらに、Vanegue と Lahiri [39] は、Microsoft COM コンポーネントの脆弱性を特定するための拡張静的チェッカー HAVOC-Lite を提案している。我々のアプローチはこれらに関連するが、分析の精度を多少犠牲にするかわり、より幅広い脆弱性を検出可能にしている。

セキュリティ研究の別の分野では、ソースコード内の脆弱性 [例: 22, 25] やその他の欠陥 [例: 14, 15, 30] を発見するためのクエリ言語が研究されている。例えば、Livshits と Lam [24] は、クエリ言語 PQL で定式化された高水準なプログラム記述から静的チェッカーを構築している。その後、静的汚染解析を用いて、Java コード中のクロスサイトスクリプティングや SQL インジェクションの脆弱性を発見している。同様に、Shankar ら [36] も静的汚染解析を利用し、C プログラムにおけるフォーマット文字列脆弱性の特定を行っている。これらの手法は特定の種類の脆弱性を識別する点で非常に効果的であるが、メモリ情報漏洩やリソースリークといったより広範な脆弱性タイプに適用できることは示されていない。さらに、静的汚染解析は本質的にデータフローに対して受動的な視点に制約されており、たとえば式の評価ができないという限界がある。

静的プログラム解析の欠点を解決するために、ファズテスト[10, 13, 42]や動的テイントトラッキング[例えば、28, 40]といった動的アプローチが提案されている。しかしながら、この方法で発見できるのは実行時にトリガされる脆弱性のみであり、そのため、異常な制御経路におけるセキュリティ上の欠陥はしばしば発見されない。これを改善する手段として、ファズテストとシンボリック実行を組み合わせ、分析を積極的に異常経路の探索へと導くことがいくつかの研究者によって提案されている。しかし、これらの手法はコストが高く、考慮すべきプログラム経路の数が指数的に増加するため、実際の運用はしばしば困難である。

最後に、脆弱性発見に直接関連しているわけではないが、Reps [32] はグラフ到達可能性問題を解くことによるプログラム解析というアイデアを先駆的に提案し、多くのデータフロー問題やプログラムスライシングがグラフ探索によって解決可能であることを示した。また、Kinloch and Munro [19] によって、バグ発見やプログラム理解を支援するための新しい表現手法の作成も検討されてきた。彼らは本質的にシステム全体のプログラム依存グラフであるCombined C Graph (CCG)を提示している。同様に、Krinke and Snelting [20] は、構文情報に加え、制御・データフロー情報も組み合わせた細粒度なシステム依存グラフを提案し、制約解決による精密なプログラムスライスの計算を可能にしている。しかし、彼らは本研究で探求されているような、グラフ探索によるバグや脆弱性パターンの記述というアイデアには踏み込んでいない。

#### IX. CONCLUSION

ソフトウェアの脆弱性を発見するための実践的な手段を分析者に提供することは、コンピュータシステムの安全性を確保する上で極めて重要である。本論文では、脆弱性を探すために大量のコードをマイニングする手法を提示した。この手法は、ソースコードの新しい表現であるコードプロパティグラフに基づいており、グラフトラバーサルを用いて一般的な脆弱性パターンのモデリングを可能にするものである。この表現を用いることで、バッファオーバーフローやフォーマット文字列脆弱性、メモリアドレスリークなど、よく知られた多くの脆弱性タイプに対して簡潔で小規模なトラバーサルを提示した。さらに、本手法によって大規模なコードベース、すなわちLinuxカーネルをコードプロパティグラフで監査し、ベンダーによって確認・修正された、合計18件のこれまで未知であった脆弱性をソースコード内で特定した。

コードプロパティグラフとグラフトラバーサルは、一般的な脆弱性の種類を発見するのに適しているが、さらに重要なのは、コードベース固有の脆弱性を特定するためにうまくカスタマイズできる点である。トラバーサルを洗練させることで、アナリストは偽陽性率と偽陰性率を完全に制御でき、分析の発見フェーズでは曖昧なトラバーサルを作成し、十分に理解された脆弱性の種類の事例を捉える際には非常に精密なトラバーサルを設定することができる。

#### ACKNOWLEDGMENTS

著者らは、プロジェクトPROSEC（FKZ 01BY1145）におけるBMBFからの助成金およびプロジェクトDEVIL（RI 2469/1-1）におけるDFGからの助成金に感謝する。

### REFERENCES

- [1] A. Aho, R. Sethi, and J. Ullman. *Compilers Principles, Techniques, and Tools*. Addison-Wesley, 1985年である。
- [2] T. Avgerinos, S. K. Cha, B. L. T. Hao, and D. Brumley. AEG: Automatic Exploit Generation. *Network and Distributed System Security Symposium (NDSS)*の論文集にて、2011年に発表されたものである。
- [3] I. D. Baxter, A. Yahin, L. Moura, M. S. Anna, and L. Bier. 抽象構文木を用いたクローン検出である。*Proc. of International Conference on Software Maintenance (ICSM)* にて、1998年。
- [4] B. Chess and M. Gerschefske. セキュリティのためのRough Auditing Toolである。Google Code、http://code.google.com/p/rough-auditing-tool-for-security/、2013年11月にアクセスした。
- [5] A. DeKok. Pscan: Cソースファイル向け限定問題スキャナーである。http://deployingradius.com/pscan/, 2013年2月閲覧。
- [6] S. Eidemiller と E. Dalci. CWE-676: 潜在的に危険な関数の使用。MITRE Corporation., 2012.
- [7] S. Esser. Mountain Lion/iOSの脆弱性ガレージセール。SyScan Conferenceでの発表、2013年。
- [8] D. EvansおよびD. Larochelle. 拡張可能な軽量静的解析を用いてセキュリティを向上させる。*IEEE Software*, 19 (1):42–51, 2002年。
- [9] J. Ferrante、K. J. Ottenstein、J. D. Warren。「プログラム依存グラフとその最適化への応用」*ACM Transactions on Programming Languages and Systems*、9:319–349、1987年。
- [10] V. Ganesh, T. Leek, and M. Rinard. タイントベースの指向性ホワイトボックスファジング。*Proc. of the International Conference on Software Engineering*, 2009 にて発表。
- [11] H. Gascon, F. Yamaguchi, D. Arp, and K. Rieck. 埋め込み呼び出しグラフを用いたAndroidマルウェアの構造的検出である。*Proc. of ACM CCS Workshop on Artificial Intelligence and Security (AISEC)*、2013年11月。
- [12] gera and riq. フォーマット文字列攻撃の進展である。*Phrack Magazine*, 0x3b(0x07), 2002.
- [13] P. Godefroid、M. Y. Levin、D. Molnar. SAGE: セキュリティテストのためのホワイトボックスファジングである。*Communications of the ACM*, 55(3):40–44, 2012.
- [14] S. F. Goldsmith、R. O'Callahan、およびA. Aiken。「Relational queries over program traces」。*Proc. of ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages and Applications (OOPSLA)*、2005年に発表されたものである。
- [15] S. Hallem、B. Chelf、Y. Xie、D. Englerによる「システム固有の静的解析を構築するためのシステムと言語」。*Proc. of ACM SIGPLAN International Conference on Programming Languages Design and Implementation (PLDI)*、2002年。
- [16] S. Heelan. 脆弱性検出システム：ロボットではなくサイボーグとして考えるべきである。*IEEE Security & Privacy*, 9(3):74–77, 2011.
- [17] S. Horwitz、T. Reps、および D. Binkley。依存グラフを用いた手続き間スライシングである。*Proc. of ACM SIGPLAN International Conference on Programming Languages Design and Implementation (PLDI)*、35–46ページ、1988年。
- [18] N. Jovanovic, C. Kruegel, and E. Kirda. Pixy: Webアプリケーションの脆弱性を検出するための静的解析ツールである。*Proc. of IEEE Symposium on Security and Privacy*において、ページ6–263、2006年に発表された。
- [19] D. A. Kinloch および M. Munro. 結合されたCグラフ表現を用いたCプログラムの理解である。*Proc. of International Conference on Software Maintenance (ICSM)*, 1994 にて発表された。
- [20] J. Krinke and G. Snelting. スライシングおよび制約解決の応用としての計測ソフトウェアの検証である。*Information and Software Technology*, 40(11):661– 675, 1998.
- [21] J. A. Kupsch and B. P. Miller. 手動による脆弱性評価と自動化された脆弱性評価の比較に関するケーススタディである。In *Proc. of Workshop on Managing Insider Security Threats (MIST)*, pages 83–97, 2009.
- [22] M. S. Lam、J. Whaley、V. B. Livshits、M. C. Martin、D. Avots、M. Carbin、およびC. Unkelによる「コンテキスト感応型プログラム解析をデータベースクエリとして扱う」。*Proc. of Symposium on principles of database systems*、2005年。
- [23] J. R. Larus、T. Ball、M. Das、R. DeLine、M. Fahndrich、

J. Pincus、S. K. Rajamani、およびR. Venkatapathy。「Righting software」『IEEE Software』、21(3):92–100、2004年。

- [24] V. B. Livshits and M. S. Lam. 静的解析によってJavaアプリケーションにおけるセキュリティ脆弱性を発見する。*Proc. of USENIX Security Symposium*, 2005において発表された。
- [25] M. Martin、B. Livshits、および M. S. Lam. pql: プログラムクエリ言語を使用したアプリケーションエラーおよびセキュリティ欠陥の検出。*Proc. of ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages and Applications (OOPSLA)*、2005年。
- [26] H. Moore. ユニバーサルプラグアンドプレイにおけるセキュリティの欠陥：プラグを抜いて、遊ばないこと。テクニカルレポート、Rapid 7、2013年。
- [27] D. Muthukumaran, T. Jaeger, and V. Ganapathy. 選択を活用して認可フックの配置を自動化する。In *Proc. of ACM conference on Computer and Communications Security*, 2012.
- [28] J. NewsomeとD. Songによる「一般的なソフトウェアに対するエクスプロイトの自動検出・分析・シグネチャ生成のための動的テイント解析」に関する研究である。*Proc. of Network and Distributed System Security Symposium (NDSS)*, 2005に掲載された。
- [29] J. W. Oh. 最近のJava悪用動向とマルウェア。Black Hat Las Vegasにおけるプレゼンテーション、2012年。
- [30] S. PaulとA. Prakashによる、プログラムパターンを用いたソースコード検索のためのフレームワークである。*IEEE Transactions on Software Engineering*, 1994年。
- [31] C. Planet. フォーマット文字列への賛辞である。*Phrack Magazine*, 0x43(0x09), 2010.
- [32] T. Reps. グラフ到達可能性によるプログラム解析である。*Information and Software Technology*, 1998.
- [33] H. G. Rice. 再帰的可算集合の類とそれらの決定問題。*Transactions of the American Mathematical Society*, 74:358–366, 1953年。
- [34] M. A. Rodriguez and P. Neubauer. グラフトラバーサルパターンである。*Graph Data Management: Techniques and Applications*, 2011年。
- [35] E. Schwartz、T. Avgerinos、およびD. Brumleyによる「動的テイント解析とフォワードシンボリック実行について知りたかったこと全て（しかし尋ねるのを恐れていたかもしれない）」である。*Proc. of IEEE Symposium on Security and Privacy*に収録、ページ317–331、2010年。
- [36] U. Shankar、K. Talwar、J. S. Foster、D. Wagner。型修飾子を用いたフォーマット文字列脆弱性の検出について述べられている。*USENIX Security Symposium 論文集*、201–218ページ、2001年。
- [37] S. Sparks、S. Embleton、R. Cunningham、およびC. C. Zouによる。「自動化された脆弱性分析: 制御フローを活用した進化的インプット作成」。*Annual Computer Security Applications Conference (ACSAC)*の論文集において、pp. 477–486。IEEE Computer Society、2007年。
- [38] M. Sutton、A. Greene、P. Amini. *Fuzzing: Brute Force Vulnerability Discovery*. Addison-Wesley Longman, 2007年。
- [39] J. Vanegue, L. Bloomberg, および S. K. Lahiriによる「実用的なリアクティブセキュリティ監査に向けた拡張静的チェッカーの利用」について述べるものである。*Proc. of IEEE Symposium on Security and Privacy*, 2013に掲載された。
- [40] T. Wang、T. Wei、Z. Lin、および W. Zou。IntScope: x86における整数オーバーフロー脆弱性を自動的に検出する。

シンボリック実行を用いたバイナリである。『Network and Distributed System Security Symposium (NDSS)』、2009年。

- [41] M. Weiser. プログラムスライシング。*Proc. of International Conference on Software Engineering*, 1981にて発表。
- [42] M. Woo, S. K. Cha, S. Gottlieb, and D. Brumley. ブラックボックス突然変異型ファジングのスケジューリングである。*Proc. of ACM Conference on Computer and Communications Security (CCS)*, 2013 に掲載。
- [43] F. Yamaguchi、M. Lottmann、K. Rieckによる「抽象構文木を用いた一般化脆弱性外挿」の論文である。*Annual Computer Security Applications Conference (ACSAC)* の会議録に掲載されており、359–368ページ、2012年12月発表である。
- [44] F. Yamaguchi, C. Wressnegger, H. Gascon, and K. Rieck. Chucky: 脆弱性発見のためにソースコードにおける不足している検査を明らかにする手法である。*Proc. of ACM Conference on Computer and Communications Security (CCS)*, 2013 に掲載された。
- [45] M. Zitser、R. Lippmann、T. Leek。オープンソースコードの悪用可能なバッファオーバーフローを用いた静的解析ツールのテストである。*Proc. of ACM SIGSOFT International Symposium on Foundations of Software Engineering SIG-SOFT FSE*、97–106ページ、2004年。

# APPENDIX

# *A. The Traversal* TNODES

トラバーサルTNODESは、集合X内のいずれかのノードを根とするASTのすべての子ノードを識別するために使用される。本トラバーサルは、次のように形式的に定義できる。

$$
\text{TNODES}(X) = \bigcup_{v \in X} \left( v \cup \left( \bigcup_{v_c \in \text{OUT}_{\mathcal{A}}(\{v\})} \text{TNODES}(\{v_c\}) \right) \right).
$$

再帰的定義は、ASTエッジ（Aとラベル付けされている）に適用される基本的な走査OUT<sup>l</sup>のみに基づいており、木に含まれるノードは、そのノード自身と、その部分木に含まれるノードによって与えられる、ということを単に述べている。

### *B. The Traversals* STATEMENT *and* FUNCTION

ステートメントノードは、コードプロパティグラフが提供する三つのビューの中心的な接続点である。その結果、任意の非ステートメントノードからそれを囲むステートメントへのトラバーサルがしばしば必要となる。この目的のために、Section V-D で使用されているように、トラバーサルSTATEMENTを導入し、集合X内のすべてのノードに対してステートメントノードを特定する。

STATEMENT(X) = v∈X s({v})

どこ

$$
s(X) = \begin{cases} X_1, & \text{もし } \mu(X_1, code) = \text{Strut} \text{ であるなら} \\ s(\text{In}_{\mathcal{A}}(X)), & \text{そうでない場合} \end{cases}
$$

そしてX<sup>1</sup>は、集合Xの唯一の要素を示す。この走査は、*Stmt*型のノードに到達するまで、ASTの入力エッジに沿って進む。類似の定義は、文を囲む関数に到達するための走査FUNCTIONにも与えることができ、親ノードへたどっていき、囲む関数ノードが見つかるまで進むことで実現される。

### *C.* PAIRS *and* PAIRFILTER

ASTの2つの部分木を比較することは、脆弱性の検出のための走査処理を定式化する際によく発生する問題である。この目的のために、2つの走査処理 T<sup>1</sup> と T<sup>2</sup> に対して、関数 PAIRS<sup>T</sup><sup>2</sup> <sup>T</sup><sup>1</sup> を定義する。

$$
\mathrm{PAIRS}_{\mathcal{T}_1}^{\mathcal{T}_2}(X) = \bigcup_{v \in X} \{(\mathcal{T}_1(\{v\}), \mathcal{T}_2(\{v\})\}
$$

（この数式は指定により翻訳対象外であるため、そのままとする。）

および対応する関数

$$
PAIRFILTER_p(X) = \{(v_1, v_2) : (v_1, v_2) \in X \text{ かつ } p(v_1, v_2)\}
$$

抽象構文木のすべての組 (v1, v2) について、基準 p(v1, v2) が真であるものを取得する。

#### *D. Traversals for Type Information*

セクションIVで説明したコードプロパティグラフは、既に次のようなトラバーサルを用いて抽象構文木から変数の型を決定することを可能にしている。

$$
Type_s = TypeNode \circ Filter_{p_s} \circ TNODES
$$

ps(v)は、vがシンボルsの識別子もしくはパラメータ宣言である場合に真となり、TYPENODEは識別子またはパラメータ宣言の型ノードへとたどるものである。しかし、実際には、変数の定義や文で利用されているシンボルへの迅速なアクセスを可能にするため、追加のグラフ構造をコードプロパティグラフに付加している。制御フローグラフからプログラム依存グラフを構築する際には、すでにすべての文によって*使用*・*定義*されるシンボルの算出が必要となるため、この情報を*関数シンボルグラフ*において明示的にしている。

関数シンボルグラフ G<sup>S</sup> = (VS, ES, λS, μS) はプロパティグラフであり、V<sup>S</sup> は関数で使用される各シンボルに対して属性付きノードを含む。関数 μ<sup>S</sup> は、それぞれのノードに対応するシンボルを保持し、そのノードに *code* という名前のプロパティを追加する。プロパティキーと値の集合は、それぞれASTの集合の部分集合である。さらに、エッジ集合 E<sup>S</sup> は、それぞれの文からその文によって使用または定義される各シンボルへのエッジを含み、そのラベル付けはエッジラベル関数 λ<sup>S</sup> : E<sup>S</sup> → Σ<sup>S</sup> により、それぞれDおよびUで与えられる。

関数記号グラフによって、我々の作業において有用であると判明した以下のような走査を定義できる。

• DEFINES。DEFINESトラバーサルである。

$$
\text{DEFINES}(V) = \text{OUT}_{\mathcal{D}}(V)
$$

ノードを、そのノードが定義するすべての記号のノードへと変換する。

• 用途。このトラバーサルは、ノードをすべて使用されているシンボルに変換する。

$$
Users(V) = OUT_{\mathcal{U}}(V)
$$

• TYPEs。走査 TYPE<sup>s</sup> は、ASTノードから開始してローカルシンボル s の型を決定するために使用できる。

$$
\text{Type}_s = \text{TypeNode} \circ \text{Filter}_{p_s} \circ \text{In}_{\mathcal{D}} \circ \text{Uses}
$$

ps(v) は、v が記号 s の識別子またはパラメータ宣言ノードである場合に真となり、それ以外の場合は偽となる。

これらのトラバーサルを備えることで、次のセクションで示すUNSANITIZEDトラバーサルを表現することが容易になる。

### *E. The Traversal* UNSANITIZED

最後に、トラバーサルUNSANITIZEDMの形式的な定義を与える。これは、テイント型脆弱性記述の中核となる要素である。このトラバーサルは、制御フローの出力エッジに沿って深さ優先で進み、目的ノードである場合、もしくは以下の三つの条件のいずれかが成立した場合に終端する：（1）ノードがMのいずれかのサニタイザ記述に一致する場合、（2）ノードが追跡中のシンボルに代入し上書きする場合、（3）ノードがすでに二度訪問されている場合である。

これらの終了基準を捉えるために、述語ps <sup>M</sup>(v, V)を定義する。これは任意の0 ≤ i ≤ |M|−1に対して、Mi({v}) = ∅、すなわちvがM<sup>i</sup>に一致する、またはFILTER(μ(v,*code*)=s)◦DEFINES({v}) = ∅、すなわちvがシンボルsに割り当てる場合に真となることを意味する。さらに、ノードが訪問された回数を追跡するためにマルチセットVを保持する。そのため、p<sup>s</sup> <sup>M</sup>(v, V)はV(v)=2の場合にも真となる。

関数u(v, d)<sup>s</sup> <sup>M</sup>を定義する。これは、制御フローグラフにおいて、ソースノードvからデスティネーションノードdまでの全ての経路のうち、Mによる検証を受けず、かつシンボルsを再定義しない経路を示すものとする。

$$
u(v, d)_{\mathcal{M}}^s = g(v, d, \emptyset, [])_{\mathcal{M}}^s
$$

gは再帰的に定義されている。

$$
g(v, d, \mathcal{V}, p)_{\mathcal{M}}^{s} = \begin{cases}\begin{cases} {\{p : v\}} & \text{もし } v = d \text{ なら} \\ \emptyset & \text{もし } v \neq d \land p \neq [] \text{ なら} \\ \end{cases} \\ h(v, d, \mathcal{V}, p)_{\mathcal{M}}^{s} & \text{それ以外の場合} \end{cases}
$$
  
そして、$h(v, d, \mathcal{V}, p)_{\mathcal{M}}^{s} = \bigcup_{v_{c} \in OUT_{c}(\{v\})} g(v_{c}, d, \mathcal{V} \uplus v, p : v)_{\mathcal{M}}^{s}$ である。

<sup>v</sup>c∈OUTC({v})

この定義において、OUTC(v)は、vから出る制御フローエッジによって接続されたノードを表す。Vは、ノードが訪問された回数を記録するために使用されるマルチセットであり、pはこれまでに通過した経路である。関数uは、後者の2つの変数をそれぞれ空集合および空リストに初期化し、深さ優先探索を実装する再帰的定義gを参照する。最後に、UPATH関数を定義することで、文によって使用されるすべての記号についてuを計算することができる。

$$
\text{UPATH}_{\mathcal{M}}(d) = \bigcup_{s \in \text{Users}(\{d\})} \bigcup_{\text{src} \in S(s,d)} u(\text{src}, d)^s_{\mathcal{M}}
$$

ここで S(s, d) = PRODUCERS{s}({d}) であり、最後に

$$
\text{UNSANITIZED}_{\mathcal{M}}(X) = \text{FIRST} \circ \bigcup_{d \in \text{STATEMENT}(X)} \text{UPATH}_{\mathcal{M}}(d)
$$

これは、集合Xのすべての要素に対してUPATHを計算し、走査FIRSTを用いて各パスの開始ノードを抽出するものである。

実際には、未サニタイズパスが存在するかどうかだけを判定できれば十分である場合が多く、そのため我々の実装では1つでもパスが発見された時点でUPATHの計算を終了する。さらに、UNSANITIZEDはSに曖昧なソース記述を渡すことでさらに最適化でき、これによりuが検討するソース／シンクの組み合わせの数を減少させることができる。最後に、精度と必要な計算時間とのトレードオフとして、最大パス長までしか深さ優先探索を行わないという方法も取ることができる。
