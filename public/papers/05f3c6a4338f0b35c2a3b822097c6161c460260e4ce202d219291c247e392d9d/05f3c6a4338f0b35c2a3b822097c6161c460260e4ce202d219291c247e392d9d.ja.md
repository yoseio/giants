# _Devign_: Effective Vulnerability Identification by Learning Comprehensive Program Semantics via Graph Neural Networks

Yaqin Zhou Nanyang Technological University yaqinchou@gmail.com

Jingkai Siow Nanyang Technological University JINGKAI001@e.ntu.edu.sg

Shangqing Liu Nanyang Technological University shangqingliu666@gmail.com

Xiaoning Du Nanyang Technological University dxn0733@gmail.com

Yang Liu 南洋理工大学 yangliu@ntu.edu.sg

# Abstract

脆弱性の特定は、サイバーセキュリティの観点からソフトウェアシステムを攻撃から守るために非常に重要です。特に、修正を容易にするために、ソースコード中の脆弱な関数を特定することが重要となります。しかし、これは困難で手間のかかる作業であり、また専門的なセキュリティ知識も求められます。さまざまなコード表現グラフに対する脆弱性の手動定義パターンに関する研究や、近年のグラフニューラルネットワークの進展に着想を得て、私たちは、豊富なコードセマンティクス表現の学習を通じてグラフレベルの分類を行う、一般的なグラフニューラルネットワークベースのモデル _Devign_ を提案します。このモデルには、グラフレベルの分類のために、学習された豊かなノード表現から有用な特徴を効率的に抽出する新しい _Conv_ モジュールが含まれています。モデルの学習には、高い複雑性と多様性を持ち、過去の研究で用いられてきた合成コードではなく実際のソースコードを取り入れた、4つの多様な大規模オープンソースCプロジェクトに基づく手動ラベル付きデータセットを用いています。データセットに対する広範な評価の結果、_Devign_ は最先端手法と比較して平均10.51%高い精度と8.68%のF1スコアを達成し、_Conv_ モジュールによって平均4.66%の精度向上と6.37%のF1向上が見られました。

# 1 Introduction

近年、ソフトウェアの脆弱性の数は急速に増加しています。これはCVE（Common Vulnerabilities and Exposures）を通じて公に報告される場合もあれば、プロプライエタリコード内で内部的に発見される場合もあります。特に、オープンソースライブラリの普及は、増加の一因となるだけでなく、その影響を広げる役割も果たしています。これらの脆弱性は主に安全でないコードによって引き起こされており、悪用されるとソフトウェアシステムへの攻撃や、経済的・社会的に大きな損害をもたらす可能性があります。

脆弱性の特定は、セキュリティにおいて極めて重要でありながらも困難な課題です。従来の手法としては、静的解析や動的解析、シンボリック実行などが挙げられますが、機械学習を補助的なアプローチとして応用する試みも進展しています。これら初期の手法では、人間の専門家によって手作業で作成された特徴やパターンが、機械学習アルゴリズムに入力として与えられ、脆弱性の検出に利用されてきました。しかし、脆弱性の根本的な原因は多様であり

弱点の種類やライブラリごとに、すべてのライブラリに存在する脆弱性を手作業で特徴付けるのは非現実的です。

既存アプローチの使いやすさを向上させ、特徴抽出における専門家による膨大な作業を避けるため、近年の研究では、より自動化された脆弱性特定方法としてディープニューラルネットワークの可能性が探求されています。しかし、これらの先行研究すべてが、実際のソースコードにおける多様性と複雑性の高い脆弱性を特徴づけるための包括的なプログラムセマンティクスの学習において、大きな制限を抱えています。まず、学習手法の観点では、ソースコードを自然言語のような平坦なシーケンスとして扱うか、一部の情報だけでコードを表現しています。しかし実際のソースコードは自然言語よりも構造的かつ論理的であり、抽象構文木（AST）、データフロー、制御フローなど、異なる側面で表現されます。さらに、脆弱性は時に微妙な欠陥であり、複数のセマンティクスの観点から包括的な分析が必要です。したがって、これまでの研究設計における欠点が、さまざまな脆弱性への対応力を制限しています。次に、学習データの観点では、[11] のデータの一部は静的解析ツールでラベリングされており、実際には脆弱性でないものまで多く誤検出されています。また [10] などでは、実際のコードの複雑さとはかけ離れた、極めて単純な人工的なコード（「good」や「bad」といった印がコード内に含まれている）を用いています [13]。

この目的のために、私たちはファクトベースの脆弱性データに対して、複合プログラミング表現を用いた新しいグラフニューラルネットワークモデルを提案します。これにより、さまざまな脆弱性の特徴を捉えるために、従来のプログラムコードのセマンティクス全体を符号化することが可能となります。重要な革新点は、新たに設計した_Conv_モジュールであり、これはゲート付きリカレントユニットから得られるグラフの異種ノード特徴量を入力として受け取ります。_Conv_モジュールは、グラフレベルの分類のために、従来の畳み込み層や全結合層を活用しながら、より粗い特徴を階層的に選択します。さらに、ソースコードの複合プログラミング埋め込みの可能性と、提案するグラフニューラルネットワークモデルが脆弱性特定という困難なタスクに対して有効であることを検証するため、C言語の4つの人気かつ多様なライブラリから手作業でラベル付けしたデータセットを作成しました。このモデルを_Devign_（Deep Vulnerability Identification via Graph Neural Networks）と名付けました。

- 複合コード表現においては、ASTを基盤として、プログラムの制御依存関係およびデータ依存関係を異なるレベルで明示的にエンコードし、それぞれのタイプが対応する関係を示す異種エッジによる統合グラフに組み込んでいます。この包括的な表現は、従来の研究では考慮されておらず、できる限り多様な種類やパターンの脆弱性を捉えることを可能にし、グラフニューラルネットワークを通じてより優れたノード表現の学習を実現します。
- 私たちは、グラフ全体の分類のために _Conv_ モジュールを備えたゲート付きグラフニューラルネットワークモデルを提案します。_Conv_ モジュールはノード特徴量から階層的に学習し、グラフレベルの分類タスクのためにより高次の表現を捉えます。
- 私たちは _Devign_ を実装し、4つの有名なCライブラリから収集した_手作業で_ラベル付けされたデータセット（_約600人時_を要した）を用いてその有効性を評価しました。2つのデータセットと詳細情報を[こちら](https://sites.google.com/view/devign)で公開しています。結果として、_Devign_ はベースライン手法よりも平均で10.51%高い精度と8.68%高いF1スコアを達成しました。また、_Conv_ モジュールは平均4.66%の精度向上と6.37%のF1向上をもたらしました。さらに、4つのプロジェクトから収集した最新40件のCVEに対して _Devign_ を適用したところ、74.11%の精度を得ることができ、新たな脆弱性発見への実用性が示されました。

## 2 The _Devign_ Model

コードプロパティグラフを用いて手作業で作成された脆弱性パターンは、すべての構文や依存関係のセマンティクスを統合し、ソフトウェアの脆弱性を検出するための最も効果的な手法の一つであることが証明されています [\[14\]](#page-9-6)。これに着想を得て、私たちはコードプロパティグラフ上で上記のプロセスを自動化し、グラフニューラルネットワークを使って脆弱なパターンを学習するために _Devign_ を設計しました [\[15\]](#page-9-7)。_Devign_ のアーキテクチャは図 [1,](#page-2-0) に示されており、三つの連続したコンポーネントから構成されます。1) _Graph Embedding Layer of Composite Code Semantics_ では、関数の生のソースコードを包括的なプログラムセマンティクスを持つ結合グラフ構造にエンコードします。2) _Gated Graph Recurrent Layers_ では、グラフ内の隣接ノード間で情報を集約・伝播することでノードの特徴を学習します。3) _The Conv module_ では、グラフレベルの予測のために意味のあるノード表現を抽出します。

<span id="page-2-0"></span>![](_page_2_Figure_0.jpeg)

Figure 1: _Devign_ のアーキテクチャ

#### 2.1 Problem Formulation

ほとんどの機械学習やパターンベースのアプローチは、ソースファイルやアプリケーションといった粗い粒度で脆弱性を予測します。つまり、ソースファイルやアプリケーションが潜在的に脆弱であるかどうかを判定するものです [\[7](#page-9-8), [14,](#page-9-6) [10,](#page-9-2) [12](#page-9-3)]。本研究では、脆弱性解析の全体的な流れの中でより細かい粒度となる_関数レベル_で脆弱なコードを分析します。脆弱な関数の特定を2クラス分類問題として定式化しており、すなわち、生のソースコード中のある関数が脆弱かどうかを判定することを学習します。データのサンプルは ((c<sup>i</sup> , yi)|c<sup>i</sup> ∈ C, y<sup>i</sup> ∈ Y), i ∈ {1, 2, . . . , n} と定義します。ここで C はコード内の関数集合、Y = {0, 1} <sup>n</sup>はラベル集合で、1が脆弱、0がそうでない場合、nはインスタンスの数です。c<sup>i</sup>は関数であるため、これを多重辺グラフ gi(V, X, A) ∈ G としてエンコードすると仮定します（埋め込みの詳細はSection [2.2](#page-2-1)を参照）。mをV内のノードの総数とし、X ∈ R m×dは各頂点v<sup>j</sup>がd次元の実数ベクトルx<sup>j</sup> ∈ R dで表現される初期ノード特徴行列です。A ∈ {0, 1} <sup>k</sup>×m×<sup>m</sup>は隣接行列で、kはエッジタイプの総数です。A内の要素e p s,t が1であれば、ノードvsとv<sup>t</sup>がタイプpのエッジで接続されていることを示し、そうでなければ0となります。_Devign_の目的は、GからYへの写像、すなわち関数が脆弱かどうかを予測するf : G 7→ Yを学習することです。予測関数fは、以下の損失関数を最小化することで学習できます。

$$
\min \sum_{i=1}^{n} \mathcal{L}(f(g_i(V, X, A), y_i|c_i)) + \lambda \omega(f) \tag{1}
$$

ここで、L(·)はクロスエントロピー損失関数、ω(·)は正則化項、λは調整可能な重みである。

#### 2.2 Graph Embedding Layer of Composite Code Semantics

図 [1,](#page-2-0) に示されているように、グラフ埋め込み層 EMB は関数コード c<sup>i</sup> をモデルへの入力となるグラフデータ構造へ写像します。

$$
g_i(V, X, A) = EMB(c_i), \forall i = \{1, ..., n\}
$$

(2)

このセクションでは、なぜ古典的なコード表現を利用し、どのようにしてコードを複合グラフに埋め込んで特徴学習を行うのか、その動機と方法について説明します。

#### 2.2.1 Classical Code Graph Representation and Vulnerability Identification

プログラム解析においては、テキストコードの背後にあるより深いセマンティクスを明らかにするために、さまざまなプログラムの表現が利用されます。ここで、従来の概念としては、AST（抽象構文木）、制御フロー、データフローグラフが含まれており、ソースコード中の異なるトークン間の構文的および意味的な関係を捉えます。多くの脆弱性（例えばメモリリークなど）は、複合的なコードセマンティクスを総合的に考慮しないと見つけるのが非常に困難です[\[14](#page-9-6)]。例えば、ASTだけを用いた場合、検出できるのは主に安全でない引数だけであると報告されています[\[14\]](#page-9-6)。ASTと制御フローグラフを組み合わせることで、リソースリークや一部のUse-after-free脆弱性といった、さらに2種類の脆弱性もカバーできるようになります。さらに3種類のコードグラフを統合することで、外部情報が別途必要な2種類（実行時プロパティに依存する競合状態、およびプログラムの意図された設計に関する詳細なしにはモデル化が難しい設計ミス）を除いて、大部分の脆弱性タイプを記述することが可能になります。

[\[14](#page-9-6)]では、脆弱性テンプレートをグラフトラバーサルの形で_手動で_作成しましたが、この方法は重要な洞察を示し、AST、フローグラフ、データフローグラフの特性を統合したデータ構造によって、より広範な脆弱性パターンを学習する可能性を実証しました。これら3つの古典的なコード構造に加えて、近年の深層学習を用いた脆弱性検出の進展がその有効性を示したことから[\[10](#page-9-2), [11\]](#page-9-4)、ソースコードの自然な並び順も考慮しています。この表現は独自のフラットな構造によって、コードトークン間の関係を「人間が読みやすい」形で捉えることができ、古典的な表現を補完します。

<span id="page-3-0"></span>![](_page_3_Figure_0.jpeg)

Figure 2: 整数オーバーフローを含むコードスニペットのグラフ表現

## 2.2.2 Graph Embedding of Code

次に、各種類のコード表現と、さまざまなサブグラフをどのようにして1つの統合グラフに表現するかについて簡単に紹介します。これは、Figure [2\(](#page-3-0)a) の整数オーバーフローのコード例と、Figure [2\(](#page-3-0)b) に示されているそのグラフ表現に従っています。

Abstract Syntax Tree (AST)  
ASTは、ソースコードを順序づけられた木構造で表現したものです。通常、コードパーサがプログラムの基本構造を理解したり、構文エラーを検出したりするために最初に利用される表現です。そのため、他の多くのコード表現を生成する基盤となり、AST V astのノード集合は本論文で使用される他の三つのコード表現の全てのノードを含みます。ルートノードから始まり、コードはコードブロック、文、宣言、式などへと分解され、最終的にはリーフノードを構成する基本的なトークンへと細分化されます。主なASTノードはFigure [2.](#page-3-0) に示されています。すべての枠がASTノードを表し、最初の行に具体的なコード、ノードの種類が注記されています。青色の枠はASTのリーフノードであり、紫色の矢印は子-親の_AST_関係を表しています。

Control Flow Graph (CFG) CFGは、プログラムの実行中にたどる可能性のあるすべての経路を記述します。経路の分岐は、条件文、例えば_if_、_for_、_switch_文などによって決定されます。CFGでは、ノードが文や条件を表し、それらが有向エッジで接続されていて、制御の移動を示します。_CFG_エッジは、図[2.](#page-3-0)で緑色の破線矢印で強調されています。特に、フローはエントリから開始し、出口で終了し、_if_文のところで2つの異なる経路に分かれます。

Data Flow Graph（DFG）は、CFG全体を通じて変数の使用状況を追跡します。データフローは変数を中心としており、あらゆるデータフローは特定の変数へのアクセスまたは変更を伴います。DFGのエッジは、同じ変数に対する後続のアクセスや変更を表します。これは、図[2](#page-3-0)でオレンジ色の二重矢印として示されており、関連する変数がエッジ上に注記されています。たとえば、パラメータbは_if_条件と代入文の両方で使用されています。

Natural Code Sequence (NCS)  
ソースコードの自然な順序をエンコードするために、_NCS_ エッジを使ってAST内の隣接するコードトークン同士を接続します。このようなエンコーディングによる主な利点は、ソースコードの順序によって反映されたプログラミングロジックを保持できることです。_NCS_ エッジはFigure [2,](#page-3-0) において赤い矢印で示されており、ASTの全てのリーフノードを接続します。

したがって、関数 c<sup>i</sup> は、同じノード集合 V = V ast を共有する4種類の部分グラフ（または4種類のエッジ）を持つ結合グラフ g で表すことができます。図 [\(2\)](#page-3-0) に示すように、すべてのノード v ∈ V には _Code_ と _Type_ という2つの属性があります。_Code_ にはノード v が表すソースコードが格納されており、v のタイプは type 属性によって示されます。初期のノード表現 x<sup>v</sup> は、この2つの属性を反映したものである必要があります。そのため、プロジェクト全体のソースコードファイルをもとに構築したコードコーパスで学習済みの word2vec モデルを用いて _Code_ をエンコードし、_Type_ はラベルエンコーディングによってエンコードします。これら2つのエンコーディングを結合して、初期のノード表現 xv とします。

### 2.3 Gated Graph Recurrent Layers

グラフニューラルネットワークの主なアイデアは、近傍集合を通じてノード表現を埋め込むことです。近傍情報を集約するさまざまな手法に基づき、グラフ畳み込みネットワーク、GraphSAGE、ゲート付きグラフリカレントネットワークおよびその派生モデルがあります。今回、ノード埋め込みの学習にはゲート付きグラフリカレントネットワークを選択しました。これは、他の二つよりもより深い構造を扱え、意味情報とグラフ構造の両方を持つ本研究のデータにより適しているためです。

与えられた埋め込みグラフ gi(V, X, A) に対して、各ノード v<sup>j</sup> ∈ V について、ノード状態ベクトル h (1) <sup>j</sup> <sup>∈</sup> <sup>R</sup> z , z ≥ d を初期アノテーションを用いて初期化します。これは、x<sup>j</sup> を最初の次元にコピーし、アノテーションサイズよりも大きい隠れ状態を許容するために余分な 0 でパディングすることによって行います。すなわち、h 1 <sup>j</sup> = [x ⊤ j , 0] <sup>⊤</sup> となります。T を近傍集約のための総タイムステップ数とします。グラフ全体に情報を伝播させるため、各タイムステップ t ≤ T では、すべてのノードが互いに通信し、エッジの種類や向きによって決まるエッジ（A の p 番目の隣接行列 A<sup>p</sup> で表現されます―定義から、隣接行列の個数はエッジの種類と等しくなります）を介して情報を伝達します。

$$
a_{j,p}^{(t-1)} = A_p^{\top} \left( W_p \left[ h_1^{(t-1)\top}, \dots, h_m^{(t-1)\top} \right] + b \right)
$$

（3）

ここで、W<sup>p</sup> ∈ R z×z は学習される重み、b はバイアスです。特に、ノード v<sup>j</sup> の新しい状態 aj,p は、エッジタイプ p の隣接行列 A<sup>p</sup> 上で定義された全ての隣接ノードの情報を集約することで計算されます。残りのステップは、ノード v および前のタイムステップから全てのタイプの情報を取り込むゲート付きリカレントユニット（GRU）であり、これにより現在のノードの隠れ状態 h (t) i,v を得ます。つまり、

$$
h_j^{(t)} = GRU(h_j^{(t-1)}, AGG(\{a_{j,p}^{(t-1)}\}_{p=1}^k))
$$

（4）

ここで AGG(·) は集約関数を表し、異なるエッジタイプからの情報を集約して次のタイムステップのノード埋め込み h (t) を計算するために、{MEAN, MAX, SUM, CONCAT} のいずれかの関数となり得ます。実装では SUM 関数を使用しています。上記の伝播手順は T タイムステップにわたって繰り返され、最後のタイムステップにおける状態ベクトル H (T) <sup>i</sup> = {h (T) j } m <sup>j</sup>=1 がノード集合 V の最終的なノード表現行列となります。

#### 2.4 The Conv Layer

ゲート付きグラフリカレント層から生成されたノード特徴量は、ノード、リンク、グラフレベルの予測など、任意の予測層への入力として使用でき、そしてモデル全体をエンドツーエンドで学習させることができます。本研究の課題では、関数 c<sup>i</sup> が脆弱かどうかを判断するために、グラフレベルの分類タスクを行う必要があります。グラフ分類の標準的なアプローチは、生成されたノード埋め込みをグローバルに集約することであり、例えば、全ての埋め込みを線形重み付き総和で単純に加算する方法があります [\[15,](#page-9-7) [19\]](#page-9-12)。これは式 [\(5\)](#page-4-0) で示されています。

<span id="page-4-0"></span>

$$
\tilde{y}_i = Sigmoid\bigg(\sum MLP([H_i^{(T)}, x_i])\bigg) \tag{5}
$$

ここで、分類にはシグモイド関数が使用され、MLPはH (T) iとx<sup>i</sup>の連結をR <sup>m</sup>ベクトルにマッピングする多層パーセプトロン（MLP）を示します。このような手法は、グラフ全体にわたる効果的な分類を妨げます[\[20,](#page-9-13) [21\]](#page-9-14)。

したがって、_Conv_モジュールは、現在のグラフレベルのタスクに関連するノードや特徴量の集合を選択するように設計します。先行研究 [\[21\]](#page-9-14) では、グラフ畳み込み層の後にSortPooling層を用いて、グラフ内のノード順序が固定されていない場合でもノード特徴量を一貫した順序で並べ替え、その後に従来のニューラルネットワークを追加し、グラフに含まれる豊富な情報を特徴づける有用な特徴量を抽出するように学習させる方法が提案されています。本研究で扱う各コード表現グラフは、隣接行列にエンコードされた独自のノード順序と接続を持っており、ノード特徴量は、グラフ畳み込みネットワークではなく、ゲート付きリカレントグラフ層によって学習されるため、異なるチャネルからのノード特徴量を並べ替える必要がありません。したがって、より効果的な予測のために、1次元畳み込みと全結合ニューラルネットワークを直接適用し、グラフレベルのタスクに関連する特徴量を学習します[1](#page-4-1)。ここで、σ(·)を1次元畳み込み層およびマックスプーリングと定義します。

$$
\sigma(\cdot) = MAXPOOL(Relu(CONV(\cdot)))\tag{6}
$$

畳み込み層の数を l とすると、この _Conv_ モジュールは次のように表すことができます。

$$
Z_i^{(1)} = \sigma([H_i^{(T)}, x_i]), \dots, Z_i^{(l)} = \sigma(Z_i^{(l-1)})
$$

\n（７）

$$
Y_i^{(1)} = \sigma(H_i^{(T)}), \dots, Y_i^{(l)} = \sigma(Y_i^{(l-1)})
$$

\n（8）

$$
\tilde{y}_i = Sigmoid\big(AVG(MLP(Z_i^{(l)}) \odot MLP(Y_i^{(l)}))\big) \tag{9}
$$

まず、連結された [H (T) i , x<sup>i</sup> ] と最終的なノード特徴 H (T) i に対して、それぞれ従来の1次元畳み込み層および全結合層を適用します。次に、この2つの出力に対して要素ごとの積を行い、その結果得られたベクトルに対して平均的な集約処理を施し、最終的に予測を行います。

<span id="page-4-1"></span><sup>1</sup>また、AST順に並べられたノードに対して、LSTMやBiLSTM（アテンション機構の有無両方）も試しましたが、全体的には畳み込みネットワークが最も良い結果を示しました。

<span id="page-5-0"></span>

| Project      | Sec. Rel. Commits VFCs Non-VFCs Graphs Vul Graphs Non-Vul Graphs |       |       |       |       |       |     |     |     |     |     |
| ------------ | ---------------------------------------------------------------- | ----- | ----- | ----- | ----- | ----- | --- | --- | --- | --- | --- |
| Linux Kernel | 12811                                                            | 8647  | 4164  | 16583 | 11198 | 5385  |     |     |     |     |     |
| QEMU         | 11910                                                            | 4932  | 6978  | 15645 | 6648  | 8997  |     |     |     |     |     |
| Wireshark    | 10004                                                            | 3814  | 6190  | 20021 | 6386  | 13635 |     |     |     |     |     |
| FFmpeg       | 13962                                                            | 5962  | 8000  | 6716  | 3420  | 3296  |     |     |     |     |     |
| Total        | 48687                                                            | 23355 | 25332 | 58965 | 27652 | 31313 |     |     |     |     |     |

Table 1: データセットの概要

# 3 Evaluation

私たちは、_Devign_ の利点を、最先端の脆弱性発見手法のいくつかと比較評価し、次のような疑問を明らかにすることを目指します。

Q1 私たちの _Devign_ は、他の学習ベースの脆弱性識別手法と比べてどのような特徴や違いがありますか？Q2 私たちの _Conv_ モジュールを搭載した _Devign_ は、グラフレベル分類タスクにおいて、式 [\(5\)](#page-4-0) の単純な総和を用いる _Ggrn_ と比較してどのような性能を示しますか？

Q3 _Devign_は各種コード表現（例：1種類の情報を持つ単一エッジグラフ）から学習することができますか？また、複合グラフ（例：すべてのタイプのコード表現）を用いた_Devign_モデルは、各単一エッジグラフと比較してどのような結果になりますか？

Q4 データセットが非常に低い割合の脆弱な関数を含むアンバランスな状態という現実的なシナリオにおいて、_Devign_ は一部の静的解析ツールと比較してより良いパフォーマンスを示すことができますか？

Q5 _Devign_ は、CVE で公に報告された最新の脆弱性に対してどのような性能を示しますか？

## 3.1 Data Preparation

高品質な脆弱関数のデータセットを入手することは、熟練した専門知識が求められるため、決して簡単なことではありません。[\[12\]](#page-9-3) では脆弱関数のデータセットが公開されていますが、そのラベルは統計解析ツールによって生成されており、正確ではありません。[\[22\]](#page-9-15) で利用されている他の潜在的なデータセットも入手できません。本研究では、産業界のパートナーの支援のもと、セキュリティチームを編成し、ゼロからデータの収集とラベル付けを行いました。生の関数を収集するだけでなく、各関数ごとにグラフ表現を生成し、グラフ内の各ノードに初期表現を与える必要があります。以下に詳細な手順を説明します。

Raw Data Gathering  
_Deving_ の脆弱性パターン学習能力を検証するために、開発者の間で人気があり機能も多様な4つの大規模C言語オープンソースプロジェクト（Linux Kernel、QEMU、Wireshark、FFmpeg）から収集した手動ラベル付き関数を用いて評価を行った。

データラベリングの質を確保し、作業を円滑に進めるために、まずセキュリティ関連のコミットを収集し、それらを脆弱性修正コミットまたは非脆弱性修正コミットとしてラベリングしました。続いて、ラベリングされたコミットから脆弱または非脆弱な関数を直接抽出しました。脆弱性修正コミット（VFC）は、潜在的な脆弱性を修正したコミットであり、これらのコミットで修正が行われる前のバージョンのソースコードから脆弱な関数を抽出できます。一方、非脆弱性修正コミット（non-VFC）は、脆弱性の修正を行っていないコミットであり、同様に変更前のソースコードから非脆弱な関数を抽出することができます。コミットの収集には [\[23](#page-9-16)] で提案された手法を採用しました。この手法は以下の2つのステップからなります。1) _コミットのフィルタリング_。脆弱性に関連するコミットはごくわずかであるため、DoS や injection などのセキュリティ関連キーワードに一致しないメッセージのコミットはセキュリティと無関係と判断し除外します。残ったものは、セキュリティ関連である可能性が高いため、手動でラベリングを行います。2) _手動ラベリング_。4人の専門的なセキュリティ研究者チームが、合計 _600人時_ をかけて2回のデータラベリングおよびクロス検証作業を実施しました。

VFCまたはnon-CFCの場合、変更された関数に基づいて、コミットが適用される前のこれらの関数のソースコードを抽出し、それに応じてラベルを割り当てます。

Graph Generation

C/C++ 用のコードプロパティグラフに基づいたオープンソースのコード解析プラットフォームである Joern [\[14\]](#page-9-6) を利用して、データセット内のすべての関数から AST と CFG を抽出します。Joern 内部でのコンパイルエラーや例外のため、AST および CFG をすべての関数について取得できるわけではありません。AST や CFG を持たない関数、あるいは AST や CFG に明らかなエラーがある関数は除外しています。元の DFG のエッジには関与する変数のラベルが付与されており、これによってエッジの種類が大幅に増加し、埋め込みグラフも複雑になるため、DFG の代わりに他の 3 つの関係、_LastRead (DFG_R)_、_LastWrite (DFG_W)_ に置き換えます。

以下は各モデルの精度・F1値を示した表です。各手法はLinux Kernel、QEMU、Wireshark、FFmpeg、またそれらを組み合わせたデータセットで評価されています。また、Max Diffは各モデル間の最大差分、Avg Diffは平均差分を示しています。Metrics + XgboostやBiLSTM、CNNなどの従来手法に比べ、GgrnやDevignを用いた手法の方が全体的に高い精度とF1値を達成しています。さらに、ASTやCFG、NCSなど異なるグラフ構造を採用した場合でも、Devign(Composite)が最も高い性能を示しています。また、Diffの値が小さいほどモデル間での結果のばらつきが少ないことを意味しています。

Table 2: 分類精度およびF1スコア（パーセンテージ表示）：最も右側の2列は、複合コード表現を用いた _Devign_ モデル、すなわち _Devign_ (Composite) と比較した場合の精度およびF1スコアの最大および平均相対差を示しています。

および _ComputedFrom (DFG_C)_ [\[24\]](#page-9-17) は、グラフ埋め込みへより適応的にするためのものです。_DFG_R_ は、各変数の出現ごとの直前の読み取りを表します。各出現は、ASTの葉ノードから直接認識できます。_DFG_W_ は、各変数の出現ごとの直前の書き込みを表します。同様に、これらのアノテーションも葉ノードの変数に付与します。_DFG_C_ は、変数の由来となるソースを特定します。代入文では、左辺（lhs）の変数に右辺（rhs）の式によって新しい値が割り当てられます。DFG_C は、lhs変数と各rhs変数との関係をこのように捉えます。

さらに、計算効率のためにノードサイズが500を超える関数を除外しており、これは全体の15%に相当します。データセットの統計情報は表 [1.](#page-5-0) にまとめています。

## 3.2 Baseline Methods

パフォーマンスの比較では、_Devign_ を最先端の機械学習ベースの脆弱性予測手法、および線形加重和による分類を用いたゲート付きグラフリカレントネットワーク（_Ggrn_）と比較します。

Metrics + Xgboost [\[22\]](#page-9-15): Joernを用いて、各関数ごとに合計で4つの複雑さメトリクスと11の脆弱性メトリクスを収集し、分類にはXgboostを利用しています。ここでは、提案されたビニングおよびランキング手法は使用していません。なぜなら、それは機械学習に基づいたものではなく、脆弱である可能性をランキングするために設計されたヒューリスティックだからです。最適なパラメータは、Bayes Optimization [\[25\]](#page-10-0) を用いて探索しました。

3-layer BiLSTM [\[10](#page-9-2)]：この手法ではソースコードを自然言語として扱い、トークン化したコードをbidirectional LSTMに入力します。初期埋め込みはWord2vecを使って学習されています。ここでは最良のパフォーマンスを得るために、3層のbidirectionalを実装しました。

3-layer BiLSTM + Att: これは、アテンション機構 [\[26\]](#page-10-1) を導入することで、[\[10\]](#page-9-2) の改良版となっています。

CNN [\[11\]](#page-9-4): [\[10\]](#page-9-2)と同様に、ソースコードを自然言語として扱い、コードトークンの初期埋め込みを得るためにバッグ・オブ・ワーズを利用し、その後CNNに入力して学習を行います。

## 3.3 Performance Evaluation

_Devign_ の設定  
埋め込み層では、初期ノード表現のための word2vec の次元数を 100 にしています。ゲート付きグラフリカレント層では、隠れ状態の次元数を 200、タイムステップ数を 6 に設定しています。_Devign_ の _Conv_ パラメータについては、最初の畳み込み層に ReLU 活性化関数を持つ (1, 3) フィルターを適用し、その後に (1, 3) フィルターと (1, 2) ストライドの最大プーリング層を配置しています。2 番目の畳み込み層には (1, 1) フィルターを使い、これにも (2, 2) フィルターと (1, 2) ストライドの最大プーリング層を続けています。オプティマイザーには Adam を用い、学習率 0.0001、バッチサイズ 128、さらに過学習を防ぐために L2 正則化を使用しています。各データセットはランダムにシャッフルし、75% を分割しています。

| Method                      | Cppcheck<br>ACC | F1   | Flawfinder<br>ACC | F1   | CXXX<br>ACC            | F1<br>ACC | F1    | ACC   | 3-layer BiLSTM 3-layer BiLSTM + Att<br>F1 | ACC   | CNN<br>F1         | ACC   | Devign (Composite)<br>F1 |
| --------------------------- | --------------- | ---- | ----------------- | ---- | ---------------------- | --------- | ----- | ----- | ----------------------------------------- | ----- | ----------------- | ----- | ------------------------ |
| Linux                       | 75.11           | 0    |                   |      | 78.46 12.57 19.44 5.07 | 18.25     | 13.12 | 8.79  | 16.16                                     |       | 29.03 15.38 69.41 |       | 24.64                    |
| QEMU                        | 89.21           | 0    | 86.24             | 7.61 | 33.64 9.29             | 29.07     | 15.54 | 78.43 | 10.50                                     |       | 75.88 18.80 89.27 |       | 41.12                    |
| Wireshark 89.19 10.17 89.92 |                 |      |                   | 9.46 | 33.26 3.95             | 91.39     | 10.75 | 84.90 | 28.35                                     | 86.09 | 8.69              | 89.37 | 42.05                    |
| FFmpeg                      | 87.72           | 0    |                   |      | 80.34 12.86 36.04 2.45 | 11.17     | 18.71 | 8.98  | 16.48                                     |       | 70.07 31.25 69.06 |       | 34.92                    |
| Combined 85.41              |                 | 2.27 |                   |      | 85.65 10.41 29.57 4.01 | 9.65      | 16.59 | 15.58 | 16.24                                     |       | 72.47 17.94 75.56 |       | 27.25                    |

<span id="page-7-0"></span>表3: 不均衡な設定における分類精度およびF1スコア（パーセンタイル）

トレーニングには全体の75％、残りの25％を検証用に使用しました。モデルの学習はNvidia Graphics Tesla M40およびP40上で行い、アーリーストッピングのために100エポックのパシエンスを設定しました。

Results Analysis  
我々はパフォーマンスを測るために _accuracy_ と _F1 score_ を使用した。Table [3.3](#page-7-0) には、すべての実験結果をまとめている。まずQ1、つまり _Devign_ の他の学習ベース手法とのパフォーマンスについて結果を分析する。ベースライン手法、複合的なコード表現を用いた _Ggrn_ および _Devign_ の結果から、_Ggrn_ と _Devign_ の両者がすべてのデータセットにおいてベースライン手法を大きく上回っていることが分かる。特に、すべてのベースライン手法と比較した場合、_Devign_ による相対的なaccuracyの向上は平均10.51%、QEMUデータセットにおいても最低8.54%となっている。また、_Devign_ (Composite) はF1スコアにおいても4つのベースライン手法を上回っており、F1スコアの相対的な向上は平均8.68%、各データセット（Linux Kernel、QEMU、Wirshark、FFmpeg、およびCombined）での最小相対的向上率はそれぞれ2.31%、11.80%、6.65%、4.04%、4.61%となっている。Linuxはコーディングスタイルのベストプラクティスに従っているため、_Devign_ によるF1スコア84.97はすべてのデータセットの中で最高値である。_したがって、_ グラフに包括的なセマンティクスをエンコードした Devign _は、最先端の脆弱性特定手法と比較して著しく優れた性能を示す。_

次に、Q2に関する _Devign_ が _Ggrn_ に対してどれほど性能向上しているかを調査します。まず、複合コード表現でのスコアを見てみます。これにより、すべてのデータセットにおいて _Devign_ の精度が _Ggrn_ よりも高いこと（平均で3.23%）が示されています。特に、FFmpeg データセットでは精度向上が最大5.12%となっています。また、F1スコアについても _Devign_ は平均で3.92%高く、QEMU データセットにおいては最大6.82%のF1スコア向上が見られます。次に、各単一コード表現ごとのスコアを確認すると、全体として同様の結論が得られ、一般に _Devign_ は _Ggrn_ を大きく上回っています。具体的には、DFG_Wエッジで最大9.21%の精度向上、DFG_Cで最大17.13%のF1スコア向上が見られます。_全体として、すべてのケースにおける_ Devign _による_ Ggrn _に対する平均精度、およびF1スコアの向上はそれぞれ4.66%、6.37%となり、Convモジュールがグラフレベルの予測により関連するノードや特徴量を抽出できていることを示しています。_

次に、Q3の結果を確認し、_Devign_ がさまざまな種類のコード表現を学習できるかどうか、および複合グラフでの性能について検証します。驚くべきことに、単一エッジグラフから学習した結果は、_Ggrn_ と _Devign_ の両方において非常に良好であることが分かりました。_Ggrn_ では、特定の種類のエッジにおいては、複合グラフよりも精度がやや高い場合も見られました。例えば、CFG や NCS グラフは FFmpeg や combined データセットでより良い結果を示しています。_Devign_ では、精度の観点から言えば、Linux データセットを除き、複合グラフ表現がすべての単一エッジグラフよりも全体的に優れており、その差は0.11%から3.75%の範囲です。F1スコアについては、単一エッジグラフと比較した場合、複合グラフによる改善は平均で2.69%、すべてのテストで0.4%から7.88%の範囲となっています。_まとめると、複合グラフは Devign が単一エッジグラフよりも優れた予測モデルを学習するのに役立ちます。_

Q4の実際の不均衡データセットに関する静的解析ツールとの比較について答えるために、大規模な産業レベルの分析[\[23](#page-9-16)]に従い、テストデータをランダムにサンプリングして、脆弱な関数が10%含まれる不均衡なデータセットを作成しました。私たちは、よく知られているオープンソースの静的解析ツールCppcheck、Flawfinder、そして法的な理由から名前を公表できない商用ツールCXXXと比較しました。結果はTableに示しており、私たちの手法は全ての静的解析ツールに比べてF1スコアで27.99高く、大きく上回りました。一方、静的解析ツールは多くの脆弱な関数を見逃し、誤検知も多い傾向があり、例えばCppcheckは4つの単一プロジェクトデータセットのうち3つで脆弱性を全く検出できませんでした。

最後に、Q5の「最新の公開された脆弱性」について回答するために、各プロジェクトごとに最新の10件のCVEを収集し、_Devign_ がゼロデイ脆弱性の特定に応用可能かどうかを確認します。40件のCVEについてコミット修正を基に調査した結果、合計で112個の脆弱な関数が得られました。_これらの関数を学習済みの_ Devign _モデルに入力したところ、平均74.11%の精度を達成しました。これは、_ Devign _が実際の応用で新しい脆弱性を発見できる可能性を示しています。_

# 4 Related Work

ディープラーニングの成功により、研究者たちはソースコードの脆弱性発見をより自動化するためにそれを応用するようになりました[\[12,](#page-9-3) [10,](#page-9-2) [11](#page-9-4)]。最近の研究[\[10,](#page-9-2) [12,](#page-9-3) [11\]](#page-9-4)では、ソースコードをフラットな自然言語シーケンスとして扱い、脆弱性検出における自然言語処理技術の可能性を探っています。例えば、[\[12](#page-9-3), [10\]](#page-9-2)はLSTM/BiLSTMニューラルネットワークを用いたモデルを構築し、一方で[\[11\]](#page-9-4)は代わりにCNNの使用を提案しました。

上述のモデルがコード内の論理や構造を表現する際の限界を克服するため、多くの研究が木構造やグラフ構造のような、より構造的なニューラルネットワークを様々なタスクに適用しようと試みてきました。たとえば、[\[15\]](#page-9-7) ではゲーテッドグラフリカレントネットワークを用いてプログラム検証のための論理式生成を提案しており、[\[24](#page-9-17)] では変数名や変数の誤使用の予測を目的としています。[\[28\]](#page-10-3) ではバイナリコードの類似性検出のために Gemini を提案し、バイナリコード内の関数を属性付き制御フローグラフで表現し、Structure2vec [\[19](#page-9-12)] を入力としてグラフ埋め込みの学習を行っています。これらの研究とは異なり、本研究では脆弱性の特定を目的とし、できるだけ多くの種類の脆弱性を表現できるよう包括的なコード表現を取り入れています。また、本研究では、ノードの意味（たとえばノードの注釈）と構造的特徴の両方を考慮するために [\[15](#page-9-7)] のゲーテッドグラフリカレント層を採用しており、これらはいずれも脆弱性特定において重要です。Structure2vec は主に構造的特徴の学習に焦点を当てています。さらに、[\[24\]](#page-9-17) が変数予測にゲーテッドグラフリカレントネットワークを適用しているのに対し、本研究では制御フローグラフを複合グラフに明示的に組み込み、効率的なグラフレベル分類のために _Conv_ モジュールを提案しています。

## 5 Conclusion and Future Work

私たちは、新しい脆弱性識別モデル _Devign_ を紹介します。このモデルは、ソースコードの関数を複数の構文およびセマンティクス表現から結合されたグラフ構造にエンコードし、その複合グラフ表現を活用して、脆弱なコードを効果的に発見することを学習します。これは、実際のオープンソースプロジェクトにおける機械学習ベースの脆弱関数発見において、新たな最先端を達成しました。興味深い今後の課題としては、プログラムスライシングを統合した大規模関数からの効率的な学習や、学習済みモデルを用いたプロジェクト横断的な脆弱性検出、人間が読める／説明可能な脆弱性評価の生成などがあります。

## References

- <span id="page-8-0"></span>[1] Z. Xu, B. Chen, M. Chandramohan, Y. Liu, and F. Song, "Spain: security patch analysis for binaries towards understanding the pain and pills," in _Proceedings of the 39th International Conference on Software Engineering_. IEEE Press, 2017, pp. 462–472.
- <span id="page-8-1"></span>[2] M. Chandramohan, Y. Xue, Z. Xu, Y. Liu, C. Y. Cho, and H. B. K. Tan, "Bingo: Crossarchitecture cross-os binary search," in _Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering_. ACM, 2016, pp. 678–689.
- <span id="page-8-2"></span>[3] Y. Li, Y. Xue, H. Chen, X. Wu, C. Zhang, X. Xie, H. Wang, and Y. Liu, "Cerebro: contextaware adaptive fuzzing for effective vulnerability detection," in _Proceedings of the 2019 27th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering_. ACM, 2019, pp. 533–544.
- [4] H. Chen, Y. Xue, Y. Li, B. Chen, X. Xie, X. Wu, and Y. Liu, "Hawkeye: Towards a desired directed grey-box fuzzer," in _Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security_. ACM, 2018, pp. 2095–2108.
- <span id="page-8-3"></span>[5] Y. Li, B. Chen, M. Chandramohan, S.-W. Lin, Y. Liu, and A. Tiu, "Steelix: program-state based binary fuzzing," in _Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering_. ACM, 2017, pp. 627–637.
- <span id="page-8-4"></span>[6] S. Neuhaus、T. Zimmermann、C. Holler、およびA. Zellerによる “Predicting vulnerable software components” は、_Proceedings of the 14th ACM Conference on Computer and Communications Security_（CCS '07シリーズ）に収録されています。2007年、New York, NY, USA: ACM、pp. 529–540。 [オンライン]。入手先: <http://doi.acm.org/10.1145/1315245.1315311>
- <span id="page-9-8"></span>[7] V. H. Nguyen と L. M. S. Tran による "Predicting vulnerable software components with dependency graphs" は、_Proceedings of the 6th International Workshop on Security Measurements and Metrics_、MetriSec '10 シリーズに掲載されています。New York, NY, USA: ACM、2010年、pp. 3:1–3:8。 [オンライン]. 利用可能: <http://doi.acm.org/10.1145/1853919.1853923>
- <span id="page-9-0"></span>[8] Y. Shin, A. Meneely, L. Williams, and J. A. Osborne, "Evaluating complexity, code churn, and developer activity metrics as indicators of software vulnerabilities," _IEEE Trans. Softw. Eng._, vol. 37, no. 6, pp. 772–787, Nov. 2011. [Online]. Available: <http://dx.doi.org/10.1109/TSE.2010.81>
- <span id="page-9-1"></span>[9] "CWE List Version 3.1," ["https://cwe.mitre.org/data/index.html",]("https://cwe.mitre.org/data/index.html") 2018.
- <span id="page-9-2"></span>[10] Z. Li, D. Zou, S. Xu, X. Ou, H. Jin, S. Wang, Z. Deng, and Y. Zhong, "Vuldeepecker: A deep learning-based system for vulnerability detection," in _25th Annual Network and Distributed System Security Symposium (NDSS 2018)_, 2018.
- <span id="page-9-4"></span>[11] R. Russell, L. Kim, L. Hamilton, T. Lazovich, J. Harer, O. Ozdemir, P. Ellingwood, and M. Mc-Conley, "Automated vulnerability detection in source code using deep representation learning," in _2018 17th IEEE International Conference on Machine Learning and Applications (ICMLA)_. IEEE, 2018, pp. 757–762.
- <span id="page-9-3"></span>[12] H. K. Dam, T. Tran, T. Pham, S. W. Ng, J. Grundy, and A. Ghose, "Automatic feature learning for vulnerability prediction," _arXiv preprint arXiv:1708.02368_, 2017.
- <span id="page-9-5"></span>[13] Juliet test suite. [オンライン]. 利用可能: <https://samate.nist.gov/SRD/around.php>
- <span id="page-9-6"></span>[14] F. Yamaguchi、N. Golde、D. Arp、および K. Rieck による「code property graphs を用いた脆弱性のモデリングと発見」、_Proceedings of the 2014 IEEE Symposium on Security and Privacy_、SP '14 シリーズ。ワシントンDC、米国: IEEE Computer Society、2014年、pp. 590–604。[オンライン]。入手先: <http://dx.doi.org/10.1109/SP.2014.44>
- <span id="page-9-7"></span>[15] Y. Li, D. Tarlow, M. Brockschmidt, and R. Zemel, "Gated graph sequence neural networks," _arXiv preprint arXiv:1511.05493_, 2015.
- <span id="page-9-9"></span>[16] M. Schlichtkrull, T. N. Kipf, P. Bloem, R. Van Den Berg, I. Titov, and M. Welling, "Modeling relational data with graph convolutional networks," in _European Semantic Web Conference_. Springer, 2018, pp. 593–607.
- <span id="page-9-10"></span>[17] P. Velickovi ˇ c, G. Cucurull, A. Casanova, A. Romero, P. Lio, and Y. Bengio, ´ "Graph attention networks," _arXiv preprint arXiv:1710.10903_, 2017.
- <span id="page-9-11"></span>[18] "Representation Learning on Networks," ["http://snap.stanford.edu/proj/embeddings-www/",]("http://snap.stanford.edu/proj/embeddings-www/") 2018.
- <span id="page-9-12"></span>[19] H. Dai, B. Dai, and L. Song, "Discriminative embeddings of latent variable models for structured data," in _International conference on machine learning_, 2016, pp. 2702–2711.
- <span id="page-9-13"></span>[20] Z. Ying, J. You, C. Morris, X. Ren, W. Hamilton, and J. Leskovec, "Hierarchical graph representation learning with differentiable pooling," in _Advances in Neural Information Processing Systems_, 2018, pp. 4805–4815.
- <span id="page-9-14"></span>[21] M. Zhang, Z. Cui, M. Neumann, および Y. Chen, 「グラフ分類のためのエンドツーエンドのディープラーニングアーキテクチャ」，_Thirty-Second AAAI Conference on Artificial Intelligence_, 2018.
- <span id="page-9-15"></span>[22] X. Du、B. Chen、Y. Li、J. Guo、Y. Zhou、Y. Liu、Y. Jiangによる"Leopard: Identifying vulnerable code for vulnerability assessment through program metrics," _arXiv preprint arXiv:1901.11479_, 2019年。
- <span id="page-9-16"></span>[23] Y. ZhouとA. Sharmaによる「コミットメッセージとバグ報告からのセキュリティ問題の自動識別」では、コミットメッセージやバグ報告からセキュリティに関する課題を自動的に特定する方法について述べられている。この研究はソフトウェア開発プロセスにおけるセキュリティ強化の観点から重要な意義を持っている。
- <span id="page-9-17"></span>[24] M. Allamanis, M. Brockschmidt, and M. Khademi, "Learning to represent programs with graphs," 2017年11月。
- <span id="page-10-0"></span>[25] J. Snoek, H. Larochelle, および R. P. Adams, "Practical bayesian optimization of machine learning algorithms," in _Advances in neural information processing systems_, 2012, pp. 2951–2959.
- <span id="page-10-1"></span>[26] Z. Yang, D. Yang, C. Dyer, X. He, A. Smola, and E. Hovy, "Hierarchical attention networks for document classification," in _Proceedings of the 2016 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies_, 2016, pp. 1480–1489.
- <span id="page-10-2"></span>[27] L. Mou, G. Li, L. Zhang, T. Wang, and Z. Jin, "Convolutional neural networks over tree structures for programming language processing." in _AAAI_, vol. 2, no. 3, 2016, p. 4.
- <span id="page-10-3"></span>[28] X. Xu, C. Liu, Q. Feng, H. Yin, L. Song, and D. Song, "Neural network-based graph embedding for cross-platform binary code similarity detection," in _Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security_. ACM, 2017, pp. 363–376.
