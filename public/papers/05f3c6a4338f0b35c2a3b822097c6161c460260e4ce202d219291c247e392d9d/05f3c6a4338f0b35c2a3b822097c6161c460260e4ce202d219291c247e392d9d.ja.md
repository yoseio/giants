# *Devign*: Effective Vulnerability Identification by Learning Comprehensive Program Semantics via Graph Neural Networks

Yaqin Zhou 南洋理工大学 yaqinchou@gmail.com

Jingkai Siow Nanyang Technological University JINGKAI001@e.ntu.edu.sg

Shangqing Liu Nanyang Technological University shangqingliu666@gmail.com

Xiaoning Du Nanyang Technological University dxn0733@gmail.com

Yang Liu Nanyang Technological University yangliu@ntu.edu.sg

# Abstract

脆弱性の特定は、サイバーセキュリティのためにソフトウェアシステムを攻撃から守る上で極めて重要です。特に、修正作業を容易にするために、ソースコードの中から脆弱な関数を特定することが重要となります。しかし、これは困難で手間のかかるプロセスであり、また専門的なセキュリティ知識も求められます。さまざまなコード表現グラフからの脆弱性パターンの手動定義に関する研究や、グラフニューラルネットワークの近年の進歩に着想を得て、我々は*Devign*を提案します。これは、豊富なコードセマンティック表現を用いて学習することによる、グラフレベルの分類のための汎用グラフニューラルネットワークベースのモデルです。本モデルは、グラフレベルの分類のために、学習された高密度なノード表現から有用な特徴を効率的に抽出する新規な*Conv*モジュールを含んでいます。このモデルは、先行研究で用いられていた合成コードではなく、実際のソースコードが持つ高度な複雑性と多様性を取り入れた、4つの多様な大規模オープンソースCプロジェクトから構築された手動ラベル付きデータセット上で学習されています。データセットに対する広範な評価の結果、*Devign*は最先端手法と比べて平均10.51%高い精度および8.68%のF1スコアを達成し、*Conv*モジュールによって平均4.66%の精度向上と6.37%のF1スコア向上が得られることが示されました。

# 1 Introduction

近年、ソフトウェアの脆弱性の数は急速に増加しています。これはCVE（Common Vulnerabilities and Exposures）を通じて公に報告されたものや、独自コード内で内部的に発見されたものなどが含まれます。特に、オープンソースライブラリの普及は、脆弱性の増加に寄与するだけでなく、その影響を広げています。これらの脆弱性は主に安全でないコードによって引き起こされており、悪用されることでソフトウェアシステムへの攻撃や、経済的・社会的に多大な被害をもたらす可能性があります。

脆弱性の特定は、セキュリティにおいて極めて重要でありながらも困難な問題です。従来の手法としては、静的解析や動的解析、さらにシンボリック実行などが挙げられますが、これらに加えて、補完的な手法として機械学習を応用するためのさまざまな進展が見られます。これら初期の方法では、専門家によって手作業で設計された特徴やパターンが機械学習アルゴリズムへの入力として用いられ、脆弱性の検出が行われてきました。しかし、脆弱性の根本的な原因は多岐にわたり

脆弱性の種類 [\[9\]](#page-9-1) やライブラリごとに、手作業で特徴量を作成してすべてのライブラリにおける脆弱性を特徴付けるのは現実的ではありません。

既存の手法のユーザビリティを向上させ、人間の専門家による特徴抽出という多大な労力を回避するため、近年の研究では、脆弱性の特定をより自動化する方法としてディープニューラルネットワークの可能性が検討されています[\[10](#page-9-2)[–12](#page-9-3)]。しかし、これらすべての研究には、実際のソースコードにおける多様で複雑な脆弱性を特徴づけるための包括的なプログラム意味論の学習に大きな限界があります。まず、学習手法の観点では、ソースコードを単なるフラットなシーケンスとして扱い、自然言語に近い方法で処理したり、一部の情報だけで表現したりしています。しかし、ソースコードは実際には自然言語よりも構造的かつ論理的であり、抽象構文木（AST）、データフロー、制御フローなど、異なる側面の表現が存在します。さらに、脆弱性はしばしば微妙な欠陥であり、複数の意味的側面からの包括的な解析が必要となります。したがって、従来の研究手法の設計上の課題は、さまざまな脆弱性を網羅する能力を制限しています。次に、学習データの観点では、[\[11](#page-9-4)]の一部のデータは静的解析ツールによってラベル付けされており、実際には脆弱性でない多くの偽陽性が含まれています。さらに[\[10\]](#page-9-2)のようなものは、コード中に"good"や"bad"といった記述があり、脆弱性コードと非脆弱性コードが区別できる単純な人工コードであり、実際のコードの複雑さとはかけ離れています[\[13](#page-9-5)]。

この目的のために、私たちは事実に基づく脆弱性データに対し、複合的なプログラミング表現を用いた新しいグラフニューラルネットワークモデルを提案します。これにより、さまざまな脆弱性の特徴を捉えるために、従来のプログラミングコードのセマンティクス全体をエンコードすることが可能になります。主な革新点は、新しい*Conv*モジュールであり、これはゲート付きリカレントユニットによるグラフの異種ノード特徴を入力として受け取ります。*Conv*モジュールは、グラフレベルの分類のために、伝統的な畳み込み層や全結合層を活用し、階層的により粗い特徴を選択します。さらに、複合的なプログラミング埋め込みがソースコードに対して持つ可能性と、提案するグラフニューラルネットワークモデルが脆弱性特定という難しい課題において持つ性能の両方を評価するため、C言語の4つの人気かつ多様なライブラリから手動でラベル付けしたデータセットを作成しました。このモデルを*Devign*（Deep Vulnerability Identification via Graph Neural Networks）と名付けています。

- 複合コード表現では、ASTを基盤として、プログラムの制御依存関係とデータ依存関係を異なるレベルで明示的に符号化し、それぞれの表現に対応する異種エッジで結合されたグラフとして構築します。この包括的な表現は、従来の研究では考慮されていなかったものであり、できる限り多様な種類やパターンの脆弱性を捉えるのに役立ち、またグラフニューラルネットワークを通じてより優れたノード表現を学習することを可能にします。
- 私たちは、グラフレベルの分類のために *Conv* モジュールを備えたゲート付きグラフニューラルネットワークモデルを提案します。*Conv* モジュールは、ノード特徴量から階層的に学習し、グラフレベルの分類タスクに向けたより高次の表現を捉えます。
- 私たちは *Devign* を実装し、4つの有名なCライブラリから収集した *手作業* でラベル付けしたデータセット（*約600人時*を要する）を用いてその有効性を評価しました。これら2つのデータセットと詳細情報は、[\(https://sites.google.com/view/devign\)](https://sites.google.com/view/devign) で公開しています。結果として、*Devign* はベースライン手法よりも平均で10.51%高い精度と8.68%高いF1スコアを達成しました。一方、*Conv*モジュールは平均で4.66%の精度と6.37%のF1向上をもたらしました。さらに、*Devign* を4つのプロジェクトから収集した最新の40件のCVEに適用したところ、74.11%の精度を達成し、新たな脆弱性の発見にも有用であることが示されました。

# 2 The *Devign* Model

コードプロパティグラフを用いて手動で作成された脆弱性パターンは、すべての構文的および依存関係のセマンティクスを統合しており、ソフトウェアの脆弱性検出において最も効果的なアプローチの一つであることが証明されています[\[14\]](#page-9-6)。このアイデアに着想を得て、コードプロパティグラフ上での上記プロセスを自動化し、グラフニューラルネットワークを用いて脆弱性パターンを学習するために*Devign*を設計しました[\[15\]](#page-9-7)。*Devign*のアーキテクチャはFigure [1,](#page-2-0)に示されており、以下の三つの連続するコンポーネントで構成されています。1) *Composite Code SemanticsのためのGraph Embedding Layer*は、関数の生のソースコードを包括的なプログラムセマンティクスを含む結合グラフ構造にエンコードします。2) *Gated Graph Recurrent Layers*は、グラフ内の近傍ノード間で情報を集約・伝播することでノードの特徴を学習します。3) *Convモジュール*は、グラフ全体の予測のために意味のあるノード表現を抽出します。

<span id="page-2-0"></span>![](_page_2_Figure_0.jpeg)

Figure 1: *Devign* のアーキテクチャ

#### 2.1 Problem Formulation

ほとんどの機械学習やパターンベースの手法は、ソースファイルやアプリケーションといった大まかな粒度で脆弱性を予測します。つまり、あるソースファイルやアプリケーションが潜在的に脆弱かどうかを判定します [\[7](#page-9-8), [14,](#page-9-6) [10,](#page-9-2) [12](#page-9-3)]。ここでは、脆弱なコードを*関数レベル*で分析します。これは、脆弱性分析の全体的な流れの中で最も細かい粒度にあたります。脆弱な関数の特定を二値分類問題として定式化し、生のソースコード内の与えられた関数が脆弱であるかどうかを判定することを学習します。データのサンプルは、((c<sup>i</sup>, y<sup>i</sup>)|c<sup>i</sup> ∈ C, y<sup>i</sup> ∈ Y), i ∈ {1, 2, . . . , n} と定義されます。ここで、Cはコード中の関数の集合、Y = {0, 1} <sup>n</sup>は1が脆弱、0がそれ以外を表すラベル集合、nはインスタンスの数です。c<sup>i</sup>は関数であるため、これが多重辺グラフgi(V, X, A) ∈ Gとしてエンコードされていると仮定します（埋め込みの詳細はSection [2.2](#page-2-1)を参照）。mをVに含まれるノードの総数とし、X ∈ R m×dは初期ノード特徴行列であり、各頂点v<sup>j</sup>はd次元の実数ベクトルx<sup>j</sup> ∈ R dとして表現されます。A ∈ {0, 1} <sup>k</sup>×m×<sup>m</sup>は隣接行列であり、kはエッジの種類の総数です。Aの要素e p s,tが1であれば、ノードv<sup>s</sup>とv<sup>t</sup>がタイプpのエッジで接続されていることを示し、それ以外は0となります。*Devign*の目的は、GからYへの写像、すなわち f : G 7→ Y を学習し、関数が脆弱かどうかを予測することです。予測関数fは、以下の損失関数を最小化することによって学習できます。

$$
\min \sum_{i=1}^{n} \mathcal{L}(f(g_i(V, X, A), y_i|c_i)) + \lambda \omega(f) \tag{1}
$$

ここで、L(·)はクロスエントロピー損失関数、ω(·)は正則化項、λは調整可能な重みです。

#### 2.2 Graph Embedding Layer of Composite Code Semantics

図[1,](#page-2-0)に示されているように、グラフ埋め込み層EMBは、関数コードc<sup>i</sup>をモデルへの入力となるグラフデータ構造へとマッピングするものです。

$$
g_i(V, X, A) = EMB(c_i), \forall i = \{1, ..., n\}
$$
（2）

このセクションでは、クラシックなコード表現を利用してコードを特徴学習のための合成グラフに埋め込む理由と方法について説明します。

#### 2.2.1 Classical Code Graph Representation and Vulnerability Identification

プログラム解析においては、プログラムのさまざまな表現が利用され、テキストとして記述されたコードの背後にあるより深いセマンティクスが明らかにされます。代表的な概念としては、AST（抽象構文木）、制御フローグラフ、データフローグラフがあり、これらはソースコード中の異なるトークン間の構文的・意味的な関係を捉えます。メモリリークのような脆弱性の大半は、複合的なコードのセマンティクスを総合的に考慮しなければ見抜くことが難しいほど微妙です[\[14](#page-9-6)]。例えば、ASTのみでは安全でない引数の検出にしか使えないと報告されています[\[14\]](#page-9-6)。ASTに制御フローグラフを組み合わせることで、リソースリークや一部のuse-after-free脆弱性といった、さらに2種類の脆弱性をカバーできるようになります。さらに三つのコードグラフを統合することで、追加の外部情報を必要とする2種類（実行時の特性に依存する競合状態、およびプログラムの意図された設計に関する詳細情報なしではモデル化が難しい設計上の誤り）を除き、ほとんどのタイプを記述できるようになります。

[\[14](#page-9-6)] では、*手動で*グラフトラバーサルの形で脆弱性テンプレートを作成しましたが、このアプローチによって、AST、制御フローグラフ、データフローグラフの特性を統合して共同のデータ構造に取り込むことで、より幅広い脆弱性パターンを学習できるという重要な洞察が得られ、その実現可能性も示されました。従来の3つのコード構造に加えて、ソースコード本来の記述順序も考慮しています。これは、深層学習ベースの脆弱性検出に関する最近の進展がその有効性を示しているためです[\[10](#page-9-2), [11\]](#page-9-4)。この特徴的なフラットな構造は、コードトークン間の関係を「人間が読める」形で捉えることができ、従来の表現方法を補完しうる手法です。

<span id="page-3-0"></span>![](_page_3_Figure_0.jpeg)

Figure 2: 整数オーバーフローを含むコードスニペットのグラフ表現

## 2.2.2 Graph Embedding of Code

次に、各種コード表現について簡単に説明し、さまざまなサブグラフをどのように一つの統合グラフに表現するかを紹介します。その際、Figure [2\(](#page-3-0)a) に示した整数オーバーフローのコード例と、Figure [2\(](#page-3-0)b) に記載されたそのグラフ表現を参照します。

Abstract Syntax Tree (AST)  
ASTはソースコードの順序付けられた木構造の表現です。通常、コードパーサがプログラムの基本的な構造を理解し、構文エラーを検査するために最初に用いる表現となります。したがって、多くの他のコード表現を生成するための基盤となっており、この論文で使用している他の3つのコード表現のノードもすべて含まれています。ルートノードから始まり、コードはコードブロック、文、宣言、式などに分解され、最終的には葉ノードとなる主要なトークンまで分割されます。主なASTノードはFigure [2.](#page-3-0) に示されています。すべてのボックスはASTノードであり、最初の行に具体的なコードとノード型が注記されています。青いボックスはASTの葉ノードを示し、紫色の矢印は親子の*AST*関係を表しています。

Control Flow Graph (CFG) CFGは、プログラムの実行中にたどりうるすべての経路を表現します。経路の分岐は、*if*、*for*、*switch*文などの条件文によって決まります。CFGでは、ノードが文や条件を表し、制御の流れを示すために有向エッジで接続されています。*CFG*のエッジは図[2.](#page-3-0)で緑色の破線矢印で強調されています。特に、フローはエントリから開始し、出口で終了し、*if*文で二つの異なる経路に分岐します。

Data Flow Graph (DFG) は、CFG 全体にわたる変数の使用状況を追跡します。データフローは変数志向であり、あらゆるデータフローは特定の変数へのアクセスや変更を伴います。DFG のエッジは、同じ変数への後続のアクセスや変更を表します。これは、Figure [2](#page-3-0) でオレンジ色の二重矢印で示されており、関係する変数がエッジ上に注釈されています。例えば、パラメータ b は *if* 条件式と代入文の両方で使用されています。

Natural Code Sequence (NCS)  
ソースコードの自然な順序をエンコードするために、*NCS* エッジを用いてAST内の隣接するコードトークンをつなぎます。このようなエンコーディングの主な利点は、ソースコードの順序によって表されるプログラミングロジックを保持できることです。*NCS* エッジはFigure [2,](#page-3-0) に赤い矢印で示されており、ASTのすべてのリーフノードを繋いでいます。

したがって、関数 c<sup>i</sup> は、同じノード集合 V = V ast を共有する4種類のサブグラフ（または4種類のエッジ）を持つ結合グラフ g で表すことができます。図[\(2\)](#page-3-0)に示すように、すべてのノード v ∈ V には *Code* と *Type* という2つの属性があります。*Code* には v が表しているソースコードが格納されており、v の type 属性は型を示します。初期ノード表現 x<sup>v</sup> はこの2つの属性を反映する必要があります。そのため、*Code* はプロジェクト内のすべてのソースコードファイルから構築したコードコーパスを使って、事前学習済みのword2vecモデルでエンコードし、*Type* はラベルエンコーディングで表現します。これら2つのエンコーディングを連結して、初期ノード表現 xv とします。

#### 2.3 Gated Graph Recurrent Layers

グラフニューラルネットワークの重要な考え方は、近傍集約を通じてノード表現をローカルな近傍から埋め込むことです。近傍情報を集約するさまざまな手法に基づき、グラフ畳み込みネットワーク、GraphSAGE、ゲーティッドグラフリカレントネットワークおよびそのバリアントがあります。ノード埋め込みを学習する手法としては、他の2つよりもより深い構造を持つことができ、かつ意味情報とグラフ構造の両方を持つ我々のデータにより適しているため、ゲーティッドグラフリカレントネットワークを選択しました。

与えられた埋め込みグラフ gi(V, X, A) に対して、各ノード v<sup>j</sup> ∈ V について、ノード状態ベクトル h (1) <sup>j</sup> <sup>∈</sup> <sup>R</sup> z , z ≥ d を初期注釈を用いて初期化する。これは、x<sup>j</sup> を最初の次元にコピーし、注釈サイズよりも大きい隠れ状態を許容するために余分な 0 をパディングして行う。つまり、h 1 <sup>j</sup> = [x ⊤ j , 0] <sup>⊤</sup> となる。T を近傍集約のための総タイムステップ数とする。グラフ全体で情報を伝播させるために、各タイムステップ t ≤ T では、すべてのノードがエッジを介して情報をやり取りする。このとき、エッジの種類と方向に依存してやり取りが行われる（これは、A の p 番目の隣接行列 A<sup>p</sup> で記述される。定義から、隣接行列の数はエッジタイプの数に等しいことが分かる）、すなわち、

$$
a_{j,p}^{(t-1)} = A_p^{\top} \left( W_p \left[ h_1^{(t-1)\top}, \dots, h_m^{(t-1)\top} \right] + b \right)
$$
（3）

ここで、W<sup>p</sup> ∈ R z×z は学習すべき重みであり、b はバイアスです。特に、ノード v<sup>j</sup> の新しい状態 aj,p は、エッジタイプ p において隣接行列 A<sup>p</sup> で定義された全ての隣接ノードの情報を集約することで計算されます。残りのステップはゲート付きリカレントユニット（GRU）であり、全てのタイプからの情報をノード v と前の時刻から取り入れて、現在のノードの隠れ状態 h (t) i,v を得ます。

$$
h_j^{(t)} = GRU(h_j^{(t-1)}, AGG(\{a_{j,p}^{(t-1)}\}_{p=1}^k))
$$
\n(4)

ここで、AGG(·)は集約関数を表しており、これは{MEAN, MAX, SUM, CONCAT}のいずれかの関数となり、異なるエッジタイプからの情報を集約して次のタイムステップのノード埋め込み h (t) を計算します。実装ではSUM関数を使用しています。上記の伝播手順はTタイムステップにわたって繰り返され、最後のタイムステップにおける状態ベクトル H (T) <sup>i</sup> = {h (T) j } m <sup>j</sup>=1 がノード集合Vに対する最終的なノード表現行列となります。

#### 2.4 The Conv Layer

ゲーテッドグラフリカレントレイヤーによって生成されたノード特徴量は、任意の予測層への入力として利用することができます。例えば、ノードやリンク、グラフレベルの予測などに用いることができ、その後、モデル全体をエンドツーエンドで学習させることが可能です。本課題では、関数 c<sup>i</sup> が脆弱かどうかを判定するグラフレベルの分類を行う必要があります。グラフ分類の標準的な手法は、すべての生成されたノード埋め込みをグローバルに集約することであり、例えば線形重み付きの総和を使い、すべての埋め込みを単純に加算する方法が [\[15,](#page-9-7) [19\]](#page-9-12) で示されているように、式 [\(5\)](#page-4-0) に従ってよく用いられます。

<span id="page-4-0"></span>
$$
\tilde{y}_i = Sigmoid\bigg(\sum MLP([H_i^{(T)}, x_i])\bigg) \tag{5}
$$

ここで、シグモイド関数は分類に用いられ、MLPは、H (T) i と x<sup>i</sup> の連結を R <sup>m</sup> ベクトルに写像する多層パーセプトロン（MLP）を指します。このような手法は、グラフ全体にわたる効果的な分類を妨げます [\[20,](#page-9-13) [21\]](#page-9-14)。

そのため、*Conv* モジュールを設計し、現在のグラフレベルのタスクに関連するノードや特徴量の集合を選択しています。[\[21\]](#page-9-14) の先行研究では、グラフ畳み込み層の後に SortPooling レイヤーを使用し、固定された順序を持たないグラフでノード特徴量を一貫したノードの順番に並べ替え、その後に従来のニューラルネットワークを追加して、グラフにエンコードされた豊富な情報を特徴付ける有用な特徴を抽出し学習できるようにしています。今回扱っている課題では、各コード表現グラフごとに事前に定められたノードの順序と接続が隣接行列にエンコードされており、またノードの特徴量はグラフ畳み込みネットワークではなく、ゲート付きリカレントグラフ層によって学習されるため、異なるチャンネルからノードの特徴量を並べ替える必要はありません。したがって、グラフレベルのタスクに関連する特徴をより効果的に予測するために、1 次元畳み込み層および全結合ニューラルネットワークを直接適用しています[1](#page-4-1)。ここで、σ(·) を 1 次元畳み込み層とマックスプーリングの組み合わせとして定義します。

$$
\sigma(\cdot) = MAXPOOL(Relu(CONV(\cdot)))\tag{6}
$$

l を適用された畳み込み層の数とすると、*Conv* モジュールは次のように表すことができます。

$$
Z_i^{(1)} = \sigma([H_i^{(T)}, x_i]), \dots, Z_i^{(l)} = \sigma(Z_i^{(l-1)})
$$
\n(7)

$$
Y_i^{(1)} = \sigma\big(H_i^{(T)}\big), \dots, Y_i^{(l)} = \sigma\big(Y_i^{(l-1)}\big) \tag{8}
$$

$$
\tilde{y}_i = Sigmoid\big(AVG(MLP(Z_i^{(l)}) \odot MLP(Y_i^{(l)}))\big) \tag{9}
$$

まず、連結された [H (T) i , x<sup>i</sup> ] と最終的なノード特徴量 H (T) i に対して、それぞれ従来の1次元畳み込み層と全結合層を適用します。その後、これら2つの出力に対して要素ごとの積を計算し、得られたベクトルを平均集約し、最後に予測を行います。

<span id="page-4-1"></span><sup>1</sup>また、ASTの順序でソートしたノードに対してLSTMやBiLSTM（アテンション機構あり／なし）も試しましたが、全体的には畳み込みネットワークが最も良い結果を示しました。

<span id="page-5-0"></span>

| プロジェクト   | セキュリティリリース | コミット数 | 脆弱性関連コミット (VFCs) | 非脆弱性関連コミット (Non-VFCs) | グラフ数 | 脆弱性グラフ数 | 非脆弱性グラフ数 |
|--------------|------------------|----------|-------------------|------------------------|--------|------------------|--------------------|
| Linux Kernel | 12811            | 8647     | 4164              | 16583                  | 11198  | 5385             |                    |
| QEMU         | 11910            | 4932     | 6978              | 15645                  | 6648   | 8997             |                    |
| Wireshark    | 10004            | 3814     | 6190              | 20021                  | 6386   | 13635            |                    |
| FFmpeg       | 13962            | 5962     | 8000              | 6716                   | 3420   | 3296             |                    |
| 合計         | 48687            | 23355    | 25332             | 58965                  | 27652  | 31313            |                    |

Table 1: データセットの概要

# 3 Evaluation

私たちは、最先端の脆弱性発見手法と比較して*Devign*の利点を評価し、次の問いを理解することを目的としています。

Q1 私たちの *Devign* は、他の学習ベースの脆弱性識別手法と比べてどのような特徴がありますか？Q2 *Conv* モジュールを搭載した私たちの *Devign* は、グラフレベルの分類タスクにおいて、Eq [\(5\)](#page-4-0) のフラットサマリーを用いた *Ggrn* と比べてどのような違いがありますか？

Q3 *Devign* は各種のコード表現（例えば、一種類の情報のみを持つ単一エッジグラフ）から学習することはできますか？また、複合グラフ（例えば、すべてのタイプのコード表現を含む）を用いた *Devign* モデルは、それぞれの単一エッジグラフと比べてどうなりますか？

Q4 *Devign*は、データセット内の脆弱な関数の割合が極端に低いという実際のシナリオで、一部の静的解析ツールと比べてより良いパフォーマンスを発揮することができますか？

Q5 *Devign* は、CVE を通じて公開された最新の脆弱性に対してどのような性能を示していますか？

## 3.1 Data Preparation

質の高い脆弱な関数のデータセットを取得することは、十分な専門知識が求められるため決して容易ではありません。私たちは、[\[12\]](#page-9-3) にて脆弱な関数のデータセットが公開されているものの、ラベル付けが統計解析ツールによって行われており、正確ではないことに気付きました。また、[\[22](#page-9-15)] で利用されている他の候補となるデータセットは入手できません。本研究では、産業界のパートナーの支援のもと、セキュリティの専門チームを編成し、ゼロからデータの収集とラベル付けを行いました。生の関数データを集めるだけでなく、各関数ごとにグラフ表現を生成し、グラフ内各ノードの初期表現を生成する必要があります。詳細な手順については以下で説明します。

Raw Data Gathering  
*Devign* の脆弱性パターン学習能力を評価するために、私たちは開発者の間で人気があり、機能面でも多様性のある4つの大規模C言語オープンソースプロジェクト（Linux Kernel、QEMU、Wireshark、FFmpeg）から手作業でラベル付けされた関数を収集し、評価を行います。

データラベリングの質を高め、効率化するために、まずセキュリティ関連のコミットを収集し、それらを脆弱性修正コミットまたは非脆弱性修正コミットとしてラベル付けし、ラベル付けされたコミットから脆弱または非脆弱な関数を直接抽出しました。脆弱性修正コミット（VFC）は、潜在的な脆弱性を修正するコミットであり、これらのコミットによる修正以前のソースコードから脆弱な関数を抽出することができます。非脆弱性修正コミット（non-VFC）は、脆弱性を修正しないコミットであり、同様に、その修正前のソースコードから非脆弱な関数を抽出できます。コミットの収集には[\[23](#page-9-16)]で提案された手法を採用しました。これは以下の2つのステップで構成されています。1) *コミットのフィルタリング*。コミットのうち、セキュリティ関連はごく一部であるため、DoSやインジェクションなどのセキュリティ関連キーワードにメッセージが一致しない、セキュリティに無関係なコミットを除外します。残りの、よりセキュリティ関連である可能性が高いものを手動でラベル付けします。2) *手動によるラベル付け*。4名の専門的なセキュリティ研究者チームが合計*600人時*をかけて、2回にわたるデータラベリングとクロス検証を行いました。

変更された関数がVFCか非CFCかに基づいて、コミットが適用される前にこれらの関数のソースコードを抽出し、それに応じてラベルを割り当てます。

グラフ生成  
私たちは、コードプロパティグラフに基づくC/C++向けのオープンソースコード解析プラットフォームであるJoern [\[14\]](#page-9-6) を利用し、データセット内のすべての関数についてASTとCFGを抽出しました。Joern内部でコンパイルエラーや例外が発生したため、ASTとCFGを取得できたのは一部の関数だけでした。ASTやCFGを持たない関数、またはASTやCFGに明らかなエラーがある関数は除外しています。元のDFGのエッジは関与している変数でラベル付けされており、それによってエッジの種類が非常に多くなり、埋め込みグラフが複雑化してしまうため、DFGの代わりに他の三つの関係で置き換えています。*LastRead (DFG\_R)*、*LastWrite (DFG\_W)*、

| Method               | Linux Kernel |       | QEMU  |       | Wireshark |       | FFmpeg |       | Combined |       | Max Diff |       | Avg Diff |       |
|----------------------|--------------|-------|-------|-------|-----------|-------|--------|-------|----------|-------|----------|-------|----------|-------|
|                      | ACC          | F1    | ACC   | F1    | ACC       | F1    | ACC    | F1    | ACC      | F1    | ACC      | F1    | ACC      | F1    |
| Metrics + Xgboost    | 67.17        | 79.14 | 59.49 | 61.27 | 70.39     | 61.31 | 67.17  | 63.76 | 61.36    | 63.76 | 14.84    | 11.80 | 10.30    | 8.71  |
| 3-layer BiLSTM       | 67.25        | 80.41 | 57.85 | 57.75 | 69.08     | 55.61 | 53.27  | 69.51 | 59.40    | 65.62 | 16.48    | 15.32 | 14.04    | 8.78  |
| 3-layer BiLSTM + Att | 75.63        | 82.66 | 65.79 | 59.92 | 74.50     | 58.52 | 61.71  | 66.01 | 69.57    | 68.65 | 8.54     | 13.15 | 5.97     | 7.41  |
| CNN                  | 70.72        | 79.55 | 60.47 | 59.29 | 70.48     | 58.15 | 53.42  | 66.58 | 63.36    | 60.13 | 16.16    | 13.78 | 11.72    | 9.82  |
| Ggrn (AST)           | 72.65        | 81.28 | 70.08 | 66.84 | 79.62     | 64.56 | 63.54  | 70.43 | 67.74    | 64.67 | 6.93     | 8.59  | 4.69     | 5.01  |
| Ggrn (CFG)           | 78.79        | 82.35 | 71.42 | 67.74 | 79.36     | 65.40 | 65.00  | 71.79 | 70.62    | 70.86 | 4.58     | 5.33  | 2.38     | 2.93  |
| Ggrn (NCS)           | 78.68        | 81.84 | 72.99 | 69.98 | 78.13     | 59.80 | 65.63  | 69.09 | 70.43    | 69.86 | 3.95     | 8.16  | 2.24     | 4.45  |
| Ggrn (DFG_C)         | 70.53        | 81.03 | 69.30 | 56.06 | 73.17     | 50.83 | 63.75  | 69.44 | 65.52    | 64.57 | 9.05     | 17.13 | 6.96     | 10.18 |
| Ggrn (DFG_R)         | 72.43        | 80.39 | 68.63 | 56.35 | 74.15     | 52.25 | 63.75  | 71.49 | 66.74    | 62.91 | 7.17     | 16.72 | 6.27     | 9.88  |
| Ggrn (DFG_W)         | 71.09        | 81.27 | 71.65 | 65.88 | 72.72     | 51.04 | 64.37  | 70.52 | 63.05    | 63.26 | 9.21     | 16.92 | 6.84     | 8.17  |
| Ggrn (Composite)     | 74.55        | 79.93 | 72.77 | 66.25 | 78.79     | 67.32 | 64.46  | 70.33 | 70.35    | 69.37 | 5.12     | 6.82  | 3.23     | 3.92  |
| Devign (AST)         | 80.24        | 84.57 | 71.31 | 65.19 | 79.04     | 64.37 | 65.63  | 71.83 | 69.21    | 69.99 | 3.95     | 7.88  | 2.33     | 3.37  |
| Devign (CFG)         | 80.03        | 82.91 | 74.22 | 70.73 | 79.62     | 66.05 | 66.89  | 70.22 | 71.32    | 71.27 | 2.69     | 3.33  | 1.00     | 2.33  |
| Devign (NCS)         | 79.58        | 81.41 | 72.32 | 68.98 | 79.75     | 65.88 | 67.29  | 68.89 | 70.82    | 68.45 | 2.29     | 4.81  | 1.46     | 3.84  |
| Devign (DFG_C)       | 78.81        | 83.87 | 72.30 | 70.62 | 79.95     | 66.47 | 65.83  | 70.12 | 69.88    | 70.21 | 3.75     | 3.43  | 2.06     | 2.30  |
| Devign (DFG_R)       | 78.25        | 80.33 | 73.77 | 70.60 | 80.66     | 66.17 | 66.46  | 72.12 | 71.49    | 70.92 | 3.12     | 4.64  | 1.29     | 2.53  |
| Devign (DFG_W)       | 78.70        | 84.21 | 72.54 | 71.08 | 80.59     | 66.68 | 67.50  | 70.86 | 71.41    | 71.14 | 2.08     | 2.69  | 1.27     | 1.77  |
| Devign (Composite)   | 79.58        | 84.97 | 74.33 | 73.07 | 81.32     | 67.96 | 69.58  | 73.55 | 72.26    | 73.26 | -        | -     | -        | -     |

この表は、さまざまなモデルや手法がLinux Kernel、QEMU、Wireshark、FFmpegといった異なるプロジェクトに対して、Accuracy（ACC）やF1スコアを指標としてどのようなパフォーマンスを示したかをまとめています。  
各手法について個別プロジェクトでの精度やF1スコアのほか、Combined（すべてを統合した場合）、Max Diff（プロジェクト間での最大差）、Avg Diff（平均差分）も併記されています。  
このデータにより、手法ごとの安定性や一般化性能の違いを比較することができます。

Table 2: 分類精度およびF1スコア（パーセンテージ表示）：一番右側の2列は、複合コード表現を用いた*Devign*モデル（すなわち*Devign* (Composite)）と比較した場合の、精度およびF1スコアにおける最大および平均の相対差を示している。

そして *ComputedFrom (DFG\_C)* [\[24\]](#page-9-17) は、グラフ埋め込みにより適応できるよう工夫されています。*DFG\_R* は、各変数の出現ごとに直前で読まれた箇所を示します。各出現はASTの葉ノードから直接判別できます。*DFG\_W* は、各変数の出現ごとに直前で書き込まれた箇所を示します。同様に、これらの注釈は葉ノードの変数に対して付与します。*DFG\_C* は、変数の元となる情報源を特定します。代入文においては、左辺（lhs）の変数に右辺（rhs）の式によって新しい値が代入されます。DFG\_Cは、lhs変数と各rhs変数との間のこのような関係を捉えます。

さらに、計算効率のためにノードサイズが500を超える関数を除外しており、これは全体の15％に相当します。データセットの統計情報は、表[1.](#page-5-0)にまとめています。

## 3.2 Baseline Methods

パフォーマンス比較では、*Devign* を最先端の機械学習ベースの脆弱性予測手法や、分類のために線形重み付き総和を用いたゲーテッドグラフリカレントネットワーク（*Ggrn*）と比較しています。

Metrics + Xgboost [\[22\]](#page-9-15): Joernを使用して、各関数ごとに合計で4つの複雑性メトリクスと11の脆弱性メトリクスを収集し、分類にはXgboostを利用しました。ここでは、提案されたビニングおよびランキング手法は使用していません。なぜなら、それは学習ベースのものではなく、脆弱性の可能性をランキングするためのヒューリスティック手法だからです。最適なパラメータの探索にはBayes Optimization [\[25\]](#page-10-0)を用いています。

3層BiLSTM [\[10](#page-9-2)]：ソースコードを自然言語として扱い、トークン化されたコードをWord2vecで事前学習された初期埋め込みを用いて双方向LSTMに入力します。ここでは最良の性能を得るため、3層構成の双方向モデルを実装しました。

3-layer BiLSTM + Att: これは、アテンション機構 [\[26\]](#page-10-1) を加えることで [\[10\]](#page-9-2) を改良したバージョンです。

CNN [\[11\]](#page-9-4): [\[10\]](#page-9-2)と同様に、ソースコードを自然言語として扱い、単語の集合（Bag of Words）を利用してコードトークンの初期埋め込みを取得し、それらをCNNに入力して学習させる。

## 3.3 Performance Evaluation

*Devign* の設定  
埋め込み層では、初期ノード表現のための word2vec の次元数を100に設定しています。ゲーテッドグラフリカレント層では、隠れ状態の次元数を200、タイムステップ数を6に設定しています。*Devign* の *Conv* パラメータについては、最初の畳み込み層で ReLU 活性化関数を使い、(1, 3) フィルタを適用し、その後に (1, 3) フィルタと (1, 2) ストライドの最大プーリング層を続けています。2つ目の畳み込み層では (1, 1) フィルタを用い、(2, 2) フィルタと (1, 2) ストライドの最大プーリング層を後続させています。オプティマイザとして Adam を使用し、学習率は0.0001、バッチサイズは128に設定し、過学習を防ぐために L2 正則化を加えています。各データセットをランダムにシャッフルし、75% を分割しています。

| Method    | Cppcheck<br>ACC | F1    | Flawfinder<br>ACC | F1    | CXXX<br>ACC | F1   | 3-layer BiLSTM<br>ACC | F1    | 3-layer BiLSTM + Att<br>ACC | F1    | CNN<br>ACC | F1    | Devign (Composite)<br>ACC | F1    |
|-----------|-----------------|-------|-------------------|-------|-------------|------|-----------------------|-------|-----------------------------|-------|------------|-------|---------------------------|-------|
| Linux     | 75.11           | 0     | 78.46             | 12.57 | 19.44       | 5.07 | 18.25                 | 13.12 | 8.79                        | 16.16 | 29.03      | 15.38 | 69.41                     | 24.64 |
| QEMU      | 89.21           | 0     | 86.24             | 7.61  | 33.64       | 9.29 | 29.07                 | 15.54 | 78.43                       | 10.50 | 75.88      | 18.80 | 89.27                     | 41.12 |
| Wireshark | 89.19           | 10.17 | 89.92             | 9.46  | 33.26       | 3.95 | 91.39                 | 10.75 | 84.90                       | 28.35 | 86.09      | 8.69  | 89.37                     | 42.05 |
| FFmpeg    | 87.72           | 0     | 80.34             | 12.86 | 36.04       | 2.45 | 11.17                 | 18.71 | 8.98                        | 16.48 | 70.07      | 31.25 | 69.06                     | 34.92 |
| Combined  | 85.41           | 2.27  | 85.65             | 10.41 | 29.57       | 4.01 | 9.65                  | 16.59 | 15.58                       | 16.24 | 72.47      | 17.94 | 75.56                     | 27.25 |

<span id="page-7-0"></span>表3：不均衡な設定における分類精度およびF1スコア（パーセンタイル）

トレーニングにはそのうちの75%を使用し、残りの25%は検証用に使用します。モデルの学習はNvidia Graphics Tesla M40およびP40上で行い、早期終了のためにエポック数は100を上限としています。

Results Analysis

私たちはパフォーマンスの測定に*accuracy*と*F1 score*を使用しています。表 [3.3](#page-7-0) はすべての実験結果をまとめたものです。まずQ1、つまり*Devign*と他の学習ベース手法との比較について結果を分析します。ベースライン手法、*Ggrn*、および複合コード表現を用いた*Devign*の結果から、*Ggrn*と*Devign*の両方が全てのデータセットでベースライン手法を大幅に上回ることがわかります。特にすべてのベースライン手法と比べた場合、*Devign*による相対的なaccuracyの向上は平均で10.51%、QEMUデータセットでは最低でも8.54%となっています。*Devign*（Composite）はF1 scoreにおいても4つのベースライン手法全てより優れており、つまりF1 scoreの相対的な平均向上率は8.68%、それぞれのデータセット（Linux Kernel、QEMU、Wirshark、FFmpeg、Combined）における最低の相対向上率は2.31%、11.80%、6.65%、4.04%、4.61%となっています。Linuxはコーディングスタイルのベストプラクティスに従っているため、*Devign*によるF1 scoreが84.97で、全データセット中最も高くなっています。*したがって、*Devign*はグラフにエンコードされた包括的なセマンティクスのおかげで、最先端の脆弱性識別手法よりも有意に優れた性能を示しています。

次に、*Devign* が *Ggrn* に対してどれだけ性能向上を示すかという Q2 の答えを調査します。まず、複合コード表現でのスコアを見ます。すべてのデータセットにおいて、*Devign* は *Ggrn* よりも高い精度（平均で3.23%）を達成しており、FFmpeg データセットでは最大の精度向上率 5.12% を示しています。また、*Devign* は F1 スコアでも *Ggrn* より高く（平均で3.92%）、QEMU データセットでは最大 F1 向上率 6.82% となっています。次に、各単一コード表現でのスコアを確認すると、同様に一般的に *Devign* が *Ggrn* を大幅に上回っている結果が得られました。最大の精度向上率は DFG\_W エッジで 9.21%、最大の F1 向上率は DFG\_C で 17.13% です。*全体として、すべてのケースにおける* Devign *の* Ggrn *に対する平均精度向上率と F1 向上率は、それぞれ 4.66%、6.37% となっており、Conv モジュールがグラフレベルの予測において、より関連するノードと特徴を抽出していることが示唆されます。*

次に、Q3の結果を確認し、*Devign* が異なる種類のコード表現を学習できるかどうか、および複合グラフにおける性能について検証します。驚くべきことに、単一エッジグラフから学習した結果は、*Ggrn* と *Devign* の両方で非常に有望なものとなりました。*Ggrn* については、特定の種類のエッジでは、複合グラフよりもわずかに高い精度を示している場合があり、例えばCFGやNCSグラフはFFmpegおよびcombinedデータセットでより良い結果となりました。*Devign* では、精度の観点で見ると、Linuxデータセットを除き、複合グラフ表現はどの単一エッジグラフよりも全体的に優れており、その向上率は0.11%から3.75%となっています。F1スコアの観点では、*Devign* の全てのテストで、複合グラフによる改善は平均2.69%、範囲は0.4%から7.88%です。*まとめると、複合グラフは* Devign *が単一エッジグラフよりも優れた予測モデルを学習するのに役立ちます。*

Q4の実際の不均衡データセットにおける静的解析ツールとの比較について回答するために、大規模な産業規模の分析 [\[23](#page-9-16)] に従い、テストデータをランダムにサンプリングして、脆弱な関数が10%だけ含まれる不均衡なデータセットを作成しました。よく知られているオープンソースの静的解析ツールCppcheck、Flawfinder、および法的な理由から名前を伏せている商用ツールCXXXと比較しました。結果はTable に示されており、私たちの手法はすべての静的解析ツールを大きく上回り、F1スコアで27.99高い値を達成しています。一方で、静的解析ツールはほとんどの脆弱な関数を検出できず、誤検知も多い傾向があります。たとえば、Cppcheckは4つのシングルプロジェクトデータセットのうち3つで脆弱性を1件も発見できていませんでした。

最後にQ5の最新の脆弱性に関する問いに答えるため、それぞれのプロジェクトについて最新の10件のCVEを収集し、*Devign*がゼロデイ脆弱性の特定に応用できる可能性があるかを調査しました。40件のCVEに対する修正コミットを元に、合計112個の脆弱な関数を抽出しました。*これらの関数を学習済みの* Devign *モデルに入力したところ、平均精度74.11%を達成し、*Devign*が実際の応用で新たな脆弱性を発見する可能性を示しました。*

# 4 Related Work

ディープラーニングの成功により、研究者たちはソースコードの脆弱性発見をより自動化するためのソリューションにこれを応用し始めています[\[12,](#page-9-3) [10,](#page-9-2) [11](#page-9-4)]。最近の研究[\[10,](#page-9-2) [12,](#page-9-3) [11\]](#page-9-4)では、ソースコードを平坦な自然言語のシーケンスとして扱い、脆弱性検出における自然言語処理技術の可能性を探求しています。例えば、[\[12](#page-9-3), [10\]](#page-9-2)ではLSTM/BiLSTMニューラルネットワークを基盤としたモデルが構築されており、[\[11\]](#page-9-4)では代わりにCNNを用いることが提案されています。

上述のモデルがコードにおける論理や構造を表現する際の限界を克服するために、いくつかの研究では、木構造やグラフ構造のような、より構造的なニューラルネットワークを様々なタスクに応用しようと試みられています。たとえば、[\[15\]](#page-9-7) では、プログラム検証のための論理式をゲート付きグラフ再帰ネットワークを使って生成する方法を提案しており、[\[24](#page-9-17)] では変数名や変数の誤使用の予測を目的としています。また、[\[28\]](#page-10-3) ではバイナリコードの類似性検出のためにGeminiを提案しており、バイナリコード中の関数を属性付き制御フローグラフで表現し、グラフ埋め込みの学習にはStructure2vec [\[19](#page-9-12)] を用いています。これらの研究とは異なり、本研究は脆弱性の特定を目的としており、できるだけ多くの種類の脆弱性を表現するために包括的なコード表現を組み込んでいます。さらに本研究では、[\[15](#page-9-7)] で提案されているゲート付きグラフ再帰層を採用し、ノードの意味（例：ノードの注釈）と構造的特徴の両方を考慮しています。これらは脆弱性の特定において重要な要素です。Structure2vecは主に構造的特徴の学習に焦点を当てています。[\[24\]](#page-9-17) でゲート付きグラフ再帰ネットワークを変数予測に適用しているのに対し、本研究では制御フローグラフを合成グラフへ明示的に組み込み、高効率なグラフレベル分類のために *Conv* モジュールを提案しています。

# 5 Conclusion and Future Work

私たちは、新しい脆弱性識別モデル *Devign* を紹介します。このモデルは、ソースコード関数を複数の構文的および意味的表現からの統合グラフ構造にエンコードし、その複合グラフ表現を活用して、効果的に脆弱なコードを発見することを学習します。実際のオープンソースプロジェクトにおいて、機械学習ベースの脆弱関数検出で新たな最先端の成果を達成しました。今後の興味深い課題としては、プログラムスライシングを統合することで大規模な関数から効率的に学習すること、学習されたモデルを使ってプロジェクトをまたがって脆弱性を検出すること、人間が読みやすい、または説明可能な脆弱性評価を生成することなどが挙げられます。

# References

- <span id="page-8-0"></span>[1] Z. Xu、B. Chen、M. Chandramohan、Y. Liu、F. Song、「Spain: security patch analysis for binaries towards understanding the pain and pills」、*Proceedings of the 39th International Conference on Software Engineering*、IEEE Press、2017年、462–472ページ。
- <span id="page-8-1"></span>[2] M. Chandramohan, Y. Xue, Z. Xu, Y. Liu, C. Y. Cho, and H. B. K. Tan, "Bingo: Crossarchitecture cross-os binary search," in *Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering*. ACM, 2016, pp. 678–689.
- <span id="page-8-2"></span>[3] Y. Li, Y. Xue, H. Chen, X. Wu, C. Zhang, X. Xie, H. Wang, and Y. Liu, "Cerebro: contextaware adaptive fuzzing for effective vulnerability detection," in *Proceedings of the 2019 27th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering*. ACM, 2019, pp. 533–544.
- [4] H. Chen, Y. Xue, Y. Li, B. Chen, X. Xie, X. Wu, and Y. Liu, "Hawkeye: Towards a desired directed grey-box fuzzer," in *Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security*. ACM, 2018, pp. 2095–2108.
- <span id="page-8-3"></span>[5] Y. Li, B. Chen, M. Chandramohan, S.-W. Lin, Y. Liu, and A. Tiu, "Steelix: program-state based binary fuzzing," in *Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering*. ACM, 2017, pp. 627–637.
- <span id="page-8-4"></span>[6] S. Neuhaus, T. Zimmermann, C. Holler, and A. Zeller, "Predicting vulnerable software components," in *Proceedings of the 14th ACM Conference on Computer and Communications Security*, ser. CCS '07. New York, NY, USA: ACM, 2007, pp. 529–540. [Online]. Available: <http://doi.acm.org/10.1145/1315245.1315311>
- <span id="page-9-8"></span>[7] V. H. Nguyen と L. M. S. Tran による "Predicting vulnerable software components with dependency graphs" は、*Proceedings of the 6th International Workshop on Security Measurements and Metrics* （MetriSec '10） に掲載されています。発行元は New York, NY, USA の ACM で、2010 年、pp. 3:1–3:8 です。[オンライン]。入手先:<http://doi.acm.org/10.1145/1853919.1853923>
- <span id="page-9-0"></span>[8] Y. Shin, A. Meneely, L. Williams, and J. A. Osborne, "Evaluating complexity, code churn, and developer activity metrics as indicators of software vulnerabilities," *IEEE Trans. Softw. Eng.*, vol. 37, no. 6, pp. 772–787, Nov. 2011. [Online]. Available: <http://dx.doi.org/10.1109/TSE.2010.81>
- <span id="page-9-1"></span>[9] "CWE List Version 3.1," ["https://cwe.mitre.org/data/index.html",]("https://cwe.mitre.org/data/index.html") 2018年。
- <span id="page-9-2"></span>[10] Z. Li, D. Zou, S. Xu, X. Ou, H. Jin, S. Wang, Z. Deng, and Y. Zhong, "Vuldeepecker: A deep learning-based system for vulnerability detection," in *25th Annual Network and Distributed System Security Symposium (NDSS 2018)*, 2018.
- <span id="page-9-4"></span>[11] R. Russell, L. Kim, L. Hamilton, T. Lazovich, J. Harer, O. Ozdemir, P. Ellingwood, and M. Mc-Conley, "Automated vulnerability detection in source code using deep representation learning," in *2018 17th IEEE International Conference on Machine Learning and Applications (ICMLA)*. IEEE, 2018, pp. 757–762.
- <span id="page-9-3"></span>[12] H. K. Dam, T. Tran, T. Pham, S. W. Ng, J. Grundy, and A. Ghose, "Automatic feature learning for vulnerability prediction," *arXiv preprint arXiv:1708.02368*, 2017.
- <span id="page-9-5"></span>[13] Julietテストスイート。[オンライン]。利用可能: <https://samate.nist.gov/SRD/around.php>
- <span id="page-9-6"></span>[14] F. Yamaguchi, N. Golde, D. Arp, and K. Rieck, "Modeling and discovering vulnerabilities with code property graphs," in *Proceedings of the 2014 IEEE Symposium on Security and Privacy*, ser. SP '14. Washington, DC, USA: IEEE Computer Society, 2014, pp. 590–604. [Online]. Available:<http://dx.doi.org/10.1109/SP.2014.44>
- <span id="page-9-7"></span>[15] Y. Li, D. Tarlow, M. Brockschmidt, and R. Zemel, "Gated graph sequence neural networks," *arXiv preprint arXiv:1511.05493*, 2015.
- <span id="page-9-9"></span>[16] M. Schlichtkrull, T. N. Kipf, P. Bloem, R. Van Den Berg, I. Titov, and M. Welling, "Modeling relational data with graph convolutional networks," in *European Semantic Web Conference*. Springer, 2018, pp. 593–607.
- <span id="page-9-10"></span>[17] P. Velickovi ˇ c, G. Cucurull, A. Casanova, A. Romero, P. Lio, and Y. Bengio, ´ "Graph attention networks," *arXiv preprint arXiv:1710.10903*, 2017.
- <span id="page-9-11"></span>[18] "Representation Learning on Networks," ["http://snap.stanford.edu/proj/embeddings-www/",]("http://snap.stanford.edu/proj/embeddings-www/") 2018.
- <span id="page-9-12"></span>[19] H. Dai, B. Dai, and L. Song, "Discriminative embeddings of latent variable models for structured data," in *International conference on machine learning*, 2016, pp. 2702–2711.
- <span id="page-9-13"></span>[20] Z. Ying, J. You, C. Morris, X. Ren, W. Hamilton, and J. Leskovec, "Hierarchical graph representation learning with differentiable pooling," in *Advances in Neural Information Processing Systems*, 2018, pp. 4805–4815.
- <span id="page-9-14"></span>[21] M. Zhang, Z. Cui, M. Neumann, and Y. Chen, "An end-to-end deep learning architecture for graph classification," in *Thirty-Second AAAI Conference on Artificial Intelligence*, 2018.
- <span id="page-9-15"></span>[22] X. Du, B. Chen, Y. Li, J. Guo, Y. Zhou, Y. Liu, and Y. Jiang, "Leopard: Identifying vulnerable code for vulnerability assessment through program metrics," *arXiv preprint arXiv:1901.11479*, 2019.
- <span id="page-9-16"></span>[23] Y. Zhou and A. Sharma, "Automated identification of security issues from commit messages and bug reports," in *Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering*, ser. ESEC/FSE 2017. New York, NY, USA: ACM, 2017, pp. 914–919. [Online]. Available:<http://doi.acm.org/10.1145/3106237.3117771>
- <span id="page-9-17"></span>[24] M. Allamanis, M. Brockschmidt, and M. Khademi, "Learning to represent programs with graphs," 2017年11月.
- <span id="page-10-0"></span>[25] J. Snoek, H. Larochelle, and R. P. Adams, "Practical bayesian optimization of machine learning algorithms," in *Advances in neural information processing systems*, 2012, pp. 2951–2959.
- <span id="page-10-1"></span>[26] Z. Yang, D. Yang, C. Dyer, X. He, A. Smola, and E. Hovy, "Hierarchical attention networks for document classification," in *Proceedings of the 2016 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies*, 2016, pp. 1480–1489.

（この文は参考文献リストにある書誌情報のみで、翻訳すべき本文の散文が含まれていません。そのため、翻訳は不要です。）
- <span id="page-10-2"></span>[27] L. Mou, G. Li, L. Zhang, T. Wang, and Z. Jin, "Convolutional neural networks over tree structures for programming language processing." in *AAAI*, vol. 2, no. 3, 2016, p. 4.
- <span id="page-10-3"></span>[28] X. Xu, C. Liu, Q. Feng, H. Yin, L. Song, and D. Song, 「ニューラルネットワークに基づくグラフ埋め込みを用いたクロスプラットフォームのバイナリコード類似性検出」に関する論文が*Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security*で発表されました。ACM、2017年、pp. 363–376。
